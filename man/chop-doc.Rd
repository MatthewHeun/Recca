% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/chop.R
\name{chop-doc}
\alias{chop-doc}
\alias{chop_Y}
\alias{chop_R}
\title{Chop the \strong{R} and \strong{Y} matrices and swim downstream/upstream}
\usage{
chop_Y(
  .sut_data = NULL,
  calc_pfd_aggs = TRUE,
  p_industries = NULL,
  fd_sectors = NULL,
  pattern_type = c("exact", "leading", "trailing", "anywhere"),
  unnest = FALSE,
  method = c("solve", "QR", "SVD"),
  tol_invert = .Machine$double.eps,
  tol_chop_sum = 1e-04,
  R = Recca::psut_cols$R,
  U = Recca::psut_cols$U,
  U_feed = Recca::psut_cols$U_feed,
  V = Recca::psut_cols$V,
  Y = Recca::psut_cols$Y,
  S_units = Recca::psut_cols$S_units,
  aggregates_df = Recca::aggregate_cols$aggregates_df,
  product_sector = Recca::aggregate_cols$product_sector,
  aggregate_primary = Recca::aggregate_cols$aggregate_primary,
  net_aggregate_demand = Recca::aggregate_cols$net_aggregate_demand,
  gross_aggregate_demand = Recca::aggregate_cols$gross_aggregate_demand,
  .prime = "_prime",
  R_colname = Recca::psut_cols$R,
  U_colname = Recca::psut_cols$U,
  U_feed_colname = Recca::psut_cols$U_feed,
  U_eiou_colname = Recca::psut_cols$U_eiou,
  r_eiou_colname = Recca::psut_cols$r_eiou,
  V_colname = Recca::psut_cols$V,
  Y_colname = Recca::psut_cols$Y,
  R_prime_colname = paste0(R_colname, .prime),
  U_prime_colname = paste0(U_colname, .prime),
  U_feed_prime_colname = paste0(U_feed_colname, .prime),
  U_eiou_prime_colname = paste0(U_eiou_colname, .prime),
  r_eiou_prime_colname = paste0(r_eiou_colname, .prime),
  V_prime_colname = paste0(V_colname, .prime),
  Y_prime_colname = paste0(Y_colname, .prime)
)

chop_R(
  .sut_data = NULL,
  calc_pfd_aggs = TRUE,
  p_industries = NULL,
  fd_sectors = NULL,
  pattern_type = c("exact", "leading", "trailing", "anywhere"),
  unnest = FALSE,
  method = c("solve", "QR", "SVD"),
  tol_invert = .Machine$double.eps,
  tol_chop_sum = 1e-04,
  R = Recca::psut_cols$R,
  U = Recca::psut_cols$U,
  U_feed = Recca::psut_cols$U_feed,
  V = Recca::psut_cols$V,
  Y = Recca::psut_cols$Y,
  S_units = Recca::psut_cols$S_units,
  aggregates_df = Recca::aggregate_cols$aggregates_df,
  product_sector = Recca::aggregate_cols$product_sector,
  aggregate_primary = Recca::aggregate_cols$aggregate_primary,
  net_aggregate_demand = Recca::aggregate_cols$net_aggregate_demand,
  gross_aggregate_demand = Recca::aggregate_cols$gross_aggregate_demand,
  .prime = "_prime",
  R_colname = Recca::psut_cols$R,
  U_colname = Recca::psut_cols$U,
  U_feed_colname = Recca::psut_cols$U_feed,
  U_eiou_colname = Recca::psut_cols$U_eiou,
  r_eiou_colname = Recca::psut_cols$r_eiou,
  V_colname = Recca::psut_cols$V,
  Y_colname = Recca::psut_cols$Y,
  R_prime_colname = paste0(R_colname, .prime),
  U_prime_colname = paste0(U_colname, .prime),
  U_feed_prime_colname = paste0(U_feed_colname, .prime),
  U_eiou_prime_colname = paste0(U_eiou_colname, .prime),
  r_eiou_prime_colname = paste0(r_eiou_colname, .prime),
  V_prime_colname = paste0(V_colname, .prime),
  Y_prime_colname = paste0(Y_colname, .prime)
)
}
\arguments{
\item{.sut_data}{A data frame or list of physical supply-use table matrices.
Default is \code{NULL}.}

\item{calc_pfd_aggs}{A boolean that tells whether (\code{TRUE}) or not (\code{FALSE})
to include primary and final demand aggregates to the
nested data frame.}

\item{p_industries}{A vector of names of industries to be aggregated as "primary"
and used if aggregations are requested.
If \code{.sut_data} is a data frame, \code{p_industries} should be the name of a column in the data frame.
If \code{.sut_data} is \code{NULL}, \code{p_industries} can be a single vector of industry names.
These industries in \code{p_industries} will appear in rows of the resource (\strong{R}) and make (\strong{V}) matrices and
columns of the final demand matrix (\strong{Y}).
Entries in \strong{Y_p} will be subtracted from entries in \strong{R_p} \code{+} \strong{V_p} to obtain
the total primary energy aggregate,
where \verb{*_p} is the primary part of those matrices.
The function \code{find_p_industry_names()} might be helpful to find
primary industry names if they can be identified by prefixes.
This argument is passed to \code{primary_aggregates()}.
Default is \code{NULL}.}

\item{fd_sectors}{A vector of names of sectors in final demand
and used if aggregations are requested.
Names should include columns in the \strong{Y} and \strong{U_EIOU} matrices
to cover both net (in \strong{Y}) and gross (in \strong{Y} and \strong{U_EIOU}) final demand.
This argument is passed to \code{finaldemand_aggregates()}.
Default is \code{NULL}.}

\item{pattern_type}{One of "exact", "leading", "trailing", or "anywhere" which specifies
how matches are made for \code{p_industries}.
If "exact", exact matches specify the sectors to be aggregated.
If "leading", sectors are aggregated if any entry in \code{p_industries} matches the leading part of a final demand sector's name.
If "trailing", sectors are aggregated if any entry in \code{p_industries} matches the trailing part of a final demand sector's name.
If "anywhere", sectors are aggregated if any entry in \code{p_industries} matches any part of a final demand sector's name.
Default is "exact".
This argument is passed to both \code{primary_aggregates()} and \code{finaldemand_aggregates()}.}

\item{unnest}{A boolean that tells whether to unnest the outgoing data.
When \code{TRUE}, creates a new column called \code{product_sector} and columns of primary and final demand aggregates.
Default is \code{FALSE}.}

\item{method}{One of "solve", "QR", or "SVD". Default is "solve". See details.}

\item{tol_invert}{The tolerance for detecting linear dependencies in the columns inverted matrices.
Default is \code{.Machine$double.eps}.}

\item{tol_chop_sum}{The allowable deviation from \code{0} for the difference between
the sum of the chopped ECCs and the original ECC.
Default is \code{1e-4}.}

\item{R, U, U_feed, V, Y, S_units}{Matrices that describe the energy conversion chain (ECC).
See \code{Recca::psut_cols} for default values.}

\item{aggregates_df, aggregate_primary, net_aggregate_demand, gross_aggregate_demand}{Names of output columns.
See \code{Recca::aggregate_cols}.}

\item{product_sector}{The name of the output column that contains the product, industry, or sector
for which footprint aggregates are given.
Default is \code{Recca::aggregate_cols$product_sector}.}

\item{.prime}{A string that denotes new matrices.
This string is used as a suffix that is appended to
many variable names.
Default is "_prime".}

\item{R_colname, U_colname, U_feed_colname, U_eiou_colname, r_eiou_colname, V_colname, Y_colname}{Names of input matrices in \code{.sut_data}. See \code{Recca::psut_cols} for default values.}

\item{R_prime_colname, U_prime_colname, U_feed_prime_colname, U_eiou_prime_colname, r_eiou_prime_colname, V_prime_colname, Y_prime_colname}{Names of output matrices in the return value.
Default values are constructed from
\code{Recca::psut_cols} values suffixed with
the value of the \code{.prime} argument.}
}
\value{
Chopped \strong{R} and \strong{Y} energy conversion chains
with optional primary and final demand aggregates.
}
\description{
Chopping the resource (\strong{R}) or final demand (\strong{Y}) matrices
involves isolating products and industries then
swimming downstream/upstream to identify an energy conversion chain (ECC)
associated with each resource or final demand category.
These functions perform those calculations.
}
\details{
Chopping \strong{R} involves calculating an ECC for each product column in the \strong{R} matrix.
This calculation is accomplished for each description of an energy conversion chain (ECC)
by the following algorithm:
\enumerate{
\item Calculate io matrices with \code{calc_io_mats()}.
\item Identify each product from columns of the \strong{R} matrix.
\item For each product independently,
perform an downstream swim with \code{new_R_ps()}
to obtain the ECC induced by that product only.
\item Optionally (but included by default),
calculate primary and final demand aggregates using \code{primary_aggregates()} and
\code{finaldemand_aggregates()}.
Both functions are called with \code{by = "Total"},
yielding total primary and final demand aggregates.
\item Add the chopped ECCs to the right side
of \code{.sut_data} as a nested data frame.
If calculated, add the primary and final demand aggregates
as columns in the nested data frame.
}

Chopping \strong{Y} involves calculating an ECC for each individual
product row and sector column of final demand in the \strong{Y} matrix.
This calculation is accomplished for each description of an ECC
by the following algorithm:
\enumerate{
\item Calculate io matrices with \code{calc_io_mats()}.
\item Identify each product and sector from rows and columns of the \strong{Y} matrix.
\item For each product and sector independently,
perform an upstream swim with \code{new_Y()}
to obtain the ECC requirements to supply that product or sector only.
\item Optionally (but included by default),
calculate primary and final demand aggregates using \code{primary_aggregates()} and
\code{finaldemand_aggregates()}.
Both functions are called with \code{by = "Total"},
yielding total primary and final demand aggregates.
\item Add the chopped ECCs to the right side
of \code{.sut_data} as a nested data frame.
If calculated, add the primary and final demand aggregates
as columns in the nested data frame.
}

Use \code{unnest} to define how the aggregate data are added to the right side of \code{.sut_data}
when \code{.sut_data} is a \code{matsindf} data frame.

Note that the nested data frame includes columns for the ECC matrices
for each isolated product or sector.
Optionally, the nested data frame includes primary and final demand aggregates
for the chopped ECCs.
The names of the columns in the data frame are taken from the \verb{*_prime_colname} arguments.

\code{chop_R()} and \code{chop_Y()} involve downstream and upstream swims
performed by the \code{new_R_ps()} and \code{new_Y()} functions.
Both involve matrix inverses.
The \code{method} arguments specify how the matrix inversion is accomplished.
The \code{tol} argument specifies the tolerance for detecting linearities in the matrix
to be inverted.
See the documentation at \code{matsbyname::invert_byname()} for details.

Both \code{tol} and \code{method} should be a single values and apply to all rows of \code{.sut_data}.

When the \strong{R} and \strong{Y} matrices are chopped by rows or columns, the sum of the ECCs
created from the chopped rows or columns should equal the original ECC.
Internally, this function checks for sum consistency and emits an error if not.
}
\examples{
p_industries <- c("Resources - Crude", "Resources - NG")
fd_sectors <- c("Residential", "Transport", "Oil fields")
psut_mats <- UKEnergy2000mats \%>\%
  tidyr::pivot_wider(names_from = matrix.name, values_from = matrix)
psut_mats \%>\%
  chop_Y(p_industries = p_industries, fd_sectors = fd_sectors)
psut_mats \%>\%
  chop_Y(p_industries = p_industries, fd_sectors = fd_sectors, unnest = TRUE)
psut_mats_2 <- psut_mats \%>\%
  # Slice to avoid the services rows on which NA values are obtained due to unit homogeneity.
  dplyr::filter(Last.stage != "Services")
# Calculate aggregates
psut_mats_2 \%>\%
  chop_R(p_industries = p_industries, fd_sectors = fd_sectors)
psut_mats_2 \%>\%
  chop_R(p_industries = p_industries, fd_sectors = fd_sectors, unnest = TRUE)
}

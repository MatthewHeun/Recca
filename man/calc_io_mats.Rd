% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/io.R
\name{calc_io_mats}
\alias{calc_io_mats}
\title{Calculate several input-output matrices}
\usage{
calc_io_mats(
  .sutdata = NULL,
  method = c("solve", "QR", "SVD"),
  tol = .Machine$double.eps,
  method_q_calculation = c("sum_U_Y_rows", "sum_R_V_cols"),
  R = "R",
  U = "U",
  U_feed = "U_feed",
  V = "V",
  Y = "Y",
  S_units = "S_units",
  y = "y",
  q = "q",
  f = "f",
  g = "g",
  h = "h",
  r = "r",
  W = "W",
  K = "K",
  Z = "Z",
  C = "C",
  D = "D",
  A = "A",
  L_ixp = "L_ixp",
  L_pxp = "L_pxp",
  O = "O",
  Z_feed = "Z_feed",
  K_feed = "K_feed",
  A_feed = "A_feed",
  L_ixp_feed = "L_ixp_feed",
  L_pxp_feed = "L_pxp_feed"
)
}
\arguments{
\item{.sutdata}{a data frame of supply-use table matrices with matrices arranged in columns.}

\item{method}{One of "solve", "QR", or "SVD". Default is "solve". See details.}

\item{tol}{The tolerance for detecting linear dependencies during matrix inversion.
Default is \code{.Machine$double.eps}.}

\item{method_q_calculation}{Specifies the method which with the q vector should be calculated.
Default is \code{sum_U_Y_rows}.
Alternatively, an analyst can choose to use the \code{sum_R_V_cols} method.
In the case of a balanced ECC, the method does not matter.}

\item{R}{The resources (\code{R}) matrix or name of the column in \code{.sutmats} that contains same. Default is "R".}

\item{U}{The use (\code{U}) matrix or name of the column in `.sutmats`` that contains same. Default is "U".}

\item{U_feed}{use matrix or name of the column in \code{.sutmats} that contains same. Default is "U_feed".}

\item{V}{The make (\code{V}) matrix or name of the column in \code{.sutmats}that contains same. Default is "V".}

\item{Y}{The final demand (\code{Y}) matrix or name of the column in \code{.sutmats} that contains same. Default is "Y".}

\item{S_units}{The unit summation matrix (\code{S_units}) or name of the column in \code{.sutmats} that contains same. Default is "S_units".}

\item{y}{The name for the \code{y} vector on output. Default is "y".
\code{y} is calculated by \code{rowsums(Y)}.}

\item{q}{The name for the \code{q} vector on output. Default is "q".
\code{q} is calculated by \code{rowsums(U) + y}.}

\item{f}{The name for the \code{f} vector on output. Default is "f".
\code{f} is calculated by \code{colsums(U)}.}

\item{g}{The name for the \code{g} vector on output. Default is "g".
\code{g} is calculated by \code{rowsums(V)}.}

\item{h}{The name for the \code{h} vector on output. Default is "h".
\code{h} is calculated by \code{colsums(transpose(R))}.}

\item{r}{The name for the \code{r} vector on output. Default is "r".
\code{r} is calculated by \code{rowsums(R)}.}

\item{W}{The name for the \code{W} matrix on output. Default is "W".
\code{W} is calculated by \code{transpose(V) - U}.}

\item{K}{The name for the \code{K} matrix on output. Default is "K".
\code{K} is calculated by \code{U * f_hat_inv}.}

\item{Z}{The name fort the \code{Z} matrix on output. Default is "Z".
\code{Z} is calculated by \code{U * g_hat_inv}.}

\item{C}{The name for the \code{C} matrix on output. Default is "C".
\code{C} is calculated by \code{transpose(V) * g_hat_inv}.}

\item{D}{The name for the \code{D} matrix on output. Default is "D".
\code{D} is calculated by \code{V * q_hat_inv}.}

\item{A}{The name for the \code{A} matrix on output. Default is "A".
\code{A} is calculated by \code{Z * D}.}

\item{L_ixp}{The name for the \code{L_ixp} matrix on output. Default is "L_ixp".
\code{L_ixp} is calculated by \code{D * L_pxp}.}

\item{L_pxp}{The name for the \code{L_pxp_feed} matrix on output. Default is "L_pxp_feed".
\code{L_pxp} is calculated by \code{(I - Z*D)^-1}.}

\item{O}{name for the \code{O} matrix on output. Default is "O".
\code{O} is calculated by \code{R * h_hat_inv}.}

\item{Z_feed}{The name for the \code{Z_feed} matrix on output. Default is "Z_feed".
\code{Z_feed} is calculated by \code{U_feed * g_hat_inv}.}

\item{K_feed}{The name for the \code{K_feed} matrix on output. Default is "K_feed".
\code{K_feed} is calculated by \code{U_feed * f_hat_inv}.}

\item{A_feed}{The name for the \code{A_feed} matrix on output. Default is "A_feed".
\code{A_feed} is calculated by \code{Z_feed * D_feed}.}

\item{L_ixp_feed}{The name for the \code{L_ixp_feed} matrix on output. Default is "L_ixp_feed".
\code{L_ixp_feed} is calculated by \code{D_feed * L_pxp_feed}.}

\item{L_pxp_feed}{The name for the \code{L_pxp_feed} matrix on output. Default is "L_pxp_feed".
\code{L_pxp_feed} is calculated by \code{(I - Z_feed*D)^-1}.}
}
\value{
A list or data frame containing input-output matrices.
}
\description{
This function bundles several others.
}
\details{
Some calculations involve a matrix inversion step.
The \code{method} argument specifies which method should be used for
calculating the inverse.
See \code{matsbyname::invert_byname()}.
}
\examples{
library(dplyr)
library(tidyr)
UKEnergy2000mats \%>\%
  spread(key = matrix.name, value = matrix) \%>\%
  select(Country, Year, Energy.type, Last.stage, U, U_feed, V, Y, r_EIOU, S_units) \%>\%
  calc_io_mats()
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reconstruct.R
\name{new_Y}
\alias{new_Y}
\title{Reconstruct an economy given a new final demand matrix}
\usage{
new_Y(.sutdata = NULL, Y_prime_colname = "Y_prime",
  L_ixp_colname = "L_ixp", L_pxp_colname = "L_pxp", Z_colname = "Z",
  D_colname = "D", U_prime_colname = "U_prime",
  V_prime_colname = "V_prime")
}
\arguments{
\item{.sutdata}{a data frame of supply-use table matrices with matrices arranged in columns.}

\item{Y_prime_colname}{the name of a column containing new final demand matrices
that will be used to reconstruct the economy}

\item{L_ixp_colname}{the name of a column containing industry-by-product L matrices.}

\item{L_pxp_colname}{the name of a column containing product-by-product L matrices.}

\item{Z_colname}{the name of a column containing \code{Z} matrices.}

\item{D_colname}{the name of a column containing \code{D} matrices.}

\item{U_prime_colname}{the name of the output column that contains new Use (\code{U}) matrices.}

\item{V_prime_colname}{the name of the output column that contains new Make (\code{V}) matrices.}
}
\value{
\code{.sutdata} with additional columns \code{U_prime} and \code{V_prime}
}
\description{
When the final demand matrix changes from \code{Y} to \code{Y_prime},
this function calculates new use (\code{U_prime}) and make (\code{V_prime}) matrices
that would be required to meet the new final demand (\code{Y_prime}).
}
\details{
Note that inputs \code{L_ixp_colname}, \code{L_pxp_colname},
\code{Z_colname}, and \code{D_colname} can be
conveniently calculated by the function \code{\link{calc_io_mats}}.

Internally, this function uses \code{\link[matsindf]{matsindf_apply}},
and documentation assumes that
\code{.sutdata} is not \code{NULL} and is a data frame.
If \code{.sutdata} is present, output is a data frame with columns named by string values of output arguments, and
input arguments should be character strings that name columns in \code{.sutdata}.
If \code{.sutdata} is \code{NULL} (the default), output is a list with items named by output strings,
and input arguments should be single matrices or vectors.
}
\examples{
library(dplyr)
library(matsbyname)
library(tidyr)
UKEnergy2000mats \%>\%
  spread(key = matrix.name, value = matrix) \%>\%
  select(Country, Year, Energy.type, Last.stage, U, V, Y, r_EIOU, S_units) \%>\%
  calc_io_mats() \%>\%
  mutate(
    # Give new Y matrices that are double the existing Y matrices
    Y_prime = elementproduct_byname(2, Y)
  ) \%>\%
  # Should give U_prime and V_prime matrices that are double the existing U and V matrices
  new_Y()
}

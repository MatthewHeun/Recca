% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregates.R
\name{region_aggregates_details}
\alias{region_aggregates_details}
\title{Aggregate final-to-useful details matrices into regions}
\usage{
region_aggregates_details(
  .details_data,
  many_colname = IEATools::iea_cols$country,
  few_colname = Recca::aggregate_cols$region,
  drop_na_few = FALSE,
  year = IEATools::iea_cols$year,
  method = IEATools::iea_cols$method,
  energy_type = IEATools::iea_cols$energy_type,
  last_stage = IEATools::iea_cols$last_stage,
  matrix_cols = c(Y_fu_details = Recca::psut_cols$Y_fu_details, U_EIOU_fu_details =
    Recca::psut_cols$U_eiou_fu_details),
  matrix_names = Recca::psut_cols$matnames,
  matrix_values = Recca::psut_cols$matvals
)
}
\arguments{
\item{.details_data}{A wide-by-matrices \code{matsindf}-style data frame of final-to-useful details matrices.}

\item{many_colname}{The name of the column in \code{.sut_data} that contains the "many" descriptions,
for example countries that need to be aggregated to continents.
Default is \code{IEATools::iea_cols$country}.}

\item{few_colname}{The of the column in \code{.sut_data} that contains the "few" descriptions,
for example continents into which countries are to be aggregated.
Default is \code{Recca::aggregate_cols$region}.}

\item{drop_na_few}{A boolean that tells whether to ignore (not aggregate) rows with \code{NA} values in \code{few_colname}.
See details.
Default is \code{FALSE}.}

\item{year, method, energy_type, last_stage}{See \code{IEATools::iea_cols}.}

\item{matrix_cols}{Names of columns in .sut_data containing matrices.
Default is a vector of names from \code{Recca::psut_cols}:
Y_fu_details and U_EIOU_fu_details.}

\item{matrix_names, matrix_values}{Internal column names. See \code{Recca::psut_cols}.}
}
\value{
An aggregated version of \code{.details_data} wherein the \code{many_colname} column is replaced
by \code{few_colname} as specified by \code{aggregation_map}.
}
\description{
Aggregates a data frame according to the regions given in a column of the data frame.
The data frame (\code{.details_data}) should contain metadata columns (including \code{many_colname} and \code{few_colname})
and be wide-by-matrices.
}
\details{
The argument \code{drop_na_few} controls what happens when an item \code{many_colname}
does not have a corresponding value in \code{few_colname}.
This condition can occur when, say, "WRLD" is a country.
"WRLD" (as a country in \code{many_colname})
should not be aggregated to "World" (as a region in the \code{few_colname}).
In those circumstances,
a well-formed \code{aggregation_map} will leave \code{NA} in \code{few_colname}.
Setting \code{drop_na_few} to \code{TRUE} (default is \code{FALSE})
will eliminate rows with \code{NA} in \code{few_colname}
before doing the aggregation so those \code{NA} rows do not end up as
\code{NA} in the outgoing data frame.

The default value for \code{drop_na_few} is \code{FALSE},
because setting to \code{TRUE} will result in data loss.
You need to opt in to this behavior when you know it's what you want.

If all of \code{few_colname} entries are \code{NA} and
\code{drop_na_few} is \code{TRUE},
a zero-row data frame of the same structure as \code{.sut_data} is returned.
}
\examples{
library(dplyr)
library(matsbyname)
library(tidyr)
mats_GBR <- UKEnergy2000mats \%>\%
  tidyr::pivot_wider(names_from = matrix.name, values_from = matrix)
# Add other countries, by duplicating and renaming GBR
mats <- dplyr::bind_rows(mats_GBR,
                         mats_GBR \%>\% dplyr::mutate(Country = "USA"),
                         mats_GBR \%>\% dplyr::mutate(Country = "FRA"))
# Establish the aggregation map.
agg_df <- list(EUR = c("GBR", "FRA"), AMR = "USA") \%>\%
  matsbyname::agg_map_to_agg_table(few_colname = "Continent", many_colname = "Country")
# Aggregate into continents
dplyr::left_join(mats, agg_df, by = "Country") \%>\%
  region_aggregates(many_colname = "Country", few_colname = "Continent")
}

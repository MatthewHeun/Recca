% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregates.R
\name{region_aggregates}
\alias{region_aggregates}
\title{Aggregate into regions}
\usage{
region_aggregates(
  .sut_data,
  many_colname = IEATools::iea_cols$country,
  few_colname = Recca::aggregate_cols$region,
  drop_na_few = FALSE,
  year = IEATools::iea_cols$year,
  method = IEATools::iea_cols$method,
  energy_type = IEATools::iea_cols$energy_type,
  last_stage = IEATools::iea_cols$last_stage,
  matrix_cols = c(R = Recca::psut_cols$R, U = Recca::psut_cols$U, U_feed =
    Recca::psut_cols$U_feed, U_eiou = Recca::psut_cols$U_eiou, r_eiou =
    Recca::psut_cols$r_eiou, V = Recca::psut_cols$V, Y = Recca::psut_cols$Y, S_units =
    Recca::psut_cols$S_units),
  matrix_names = Recca::psut_cols$matnames,
  matrix_values = Recca::psut_cols$matvals
)
}
\arguments{
\item{.sut_data}{A wide-by-matrices \code{matsindf}-style data frame of PSUT matrices.}

\item{many_colname}{The name of the column in \code{.sut_data} that contains the "many" descriptions,
for example countries that need to be aggregated to continents.
Default is \code{IEATools::iea_cols$country}.}

\item{few_colname}{The of the column in \code{.sut_data} that contains the "few" descriptions,
for example continents into which countries are to be aggregated.
Default is \code{Recca::aggregate_cols$region}.}

\item{drop_na_few}{A boolean that tells whether to ignore (not aggregate) rows with  \code{NA} values in \code{few_colname}.
See details.
Default is \code{FALSE}.}

\item{year, method, energy_type, last_stage}{See \code{IEATools::iea_cols}.}

\item{matrix_cols}{Names of columns in .sut_data containing matrices.
Default is a vector of names from \code{Recca::psut_cols}:
R, U, U_feed, U_eiou, r_eiou, V, Y, and S_units.}

\item{matrix_names, matrix_values}{Internal column names. See \code{Recca::psut_cols}.}
}
\value{
An aggregated version of \code{.sut_data} wherein the \code{many_colname} column is replaced
by \code{few_colname} as specified by \code{aggregation_map}.
}
\description{
Aggregates a data frame according to the regions given in a column of the data frame.
The data frame (\code{.sut_data}) should contain metadata columns (including \code{many_colname} and \code{few_colname})
and be wide-by-matrices.
}
\details{
The argument \code{drop_na_few} controls what happens when an item \code{many_colname}
does not have a corresonding value in \code{few_colname}.
This condition can occur when, say, "WRLD" is a country.
"WRLD" (as a country in \code{many_colname})
should not be aggregated to "World" (as a region in the \code{few_colname}).
In those circumstances,
a well-formed \code{aggregation_map} will leave \code{NA} in \code{few_colname}.
Setting \code{drop_na_few} will eliminate rows with \code{NA} in \code{few_colname}
before doing the aggregation so those \code{NA} rows do not end up as
\code{NA} in the outgoing data frame.

The default value for \code{drop_na_few} is \code{FALSE},
because setting to \code{TRUE} will result in data loss.
You need to opt in to this behavior when you know it's what you want.
}
\examples{
library(dplyr)
library(matsbyname)
library(tidyr)
mats_GBR <- UKEnergy2000mats \%>\%
  tidyr::pivot_wider(names_from = matrix.name, values_from = matrix)
# Add other countries, by duplicating and renaming GBR
mats <- dplyr::bind_rows(mats_GBR,
                         mats_GBR \%>\% dplyr::mutate(Country = "USA"),
                         mats_GBR \%>\% dplyr::mutate(Country = "FRA"))
# Establish the aggregation map.
agg_df <- list(EUR = c("GBR", "FRA"), AMR = "USA") \%>\%
  matsbyname::agg_map_to_agg_table(few_colname = "Continent", many_colname = "Country")
# Aggregate into continents
dplyr::left_join(mats, agg_df, by = "Country") \%>\%
  region_aggregates(mats, many_colname = "Country", few_colname = "Continent")
}

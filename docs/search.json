[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 Recca authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/Aggregation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Aggregation","text":"Recca (R Energy Conversion Chain Analysis) contains many functions useful aggregating industries products energy conversion chains. types aggregation shown following table. vignette describes functions demonstrates use.","code":""},{"path":"/articles/Aggregation.html","id":"primary_aggregates","dir":"Articles","previous_headings":"","what":"primary_aggregates()","title":"Aggregation","text":"primary_aggregates() creates column primary energy sums coming industries specified p_industries (primary industries) argument. primary industries often found R, V, Y matrices PSUT framework. Typical p_industries Resources, Imports, Exports. examples , primary aggregates calculated four rows UKEnergy2000mats data frame. first example, one aggregate column created (“EX.p”), difference net gross aggregation primary energy. Net gross primary aggregates identical. next example, net gross aggregation columns created (“EX.p_net” “EX.p_gross”), compatibility finaldemand_aggregates() function discussed .","code":"library(matsbyname) p_industries <- c(\"Resources [of Crude]\", \"Resources [of NG]\") # Calculate primary total aggregates ECCs <- UKEnergy2000mats %>%   tidyr::pivot_wider(names_from = \"matrix.name\", values_from = \"matrix\") ECCs #> # A tibble: 4 × 12 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 4 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list> res <- ECCs %>%   Recca::primary_aggregates(p_industries = p_industries, by = \"Total\") tibble::as_tibble(res) #> # A tibble: 4 × 13 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 5 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   EX.p <dbl> res[[Recca::aggregate_cols$aggregate_primary]] #> [1] 93000 93000 93000 98220 res2 <- ECCs %>%   Recca::primary_aggregates(p_industries = p_industries,                             add_net_gross_cols = TRUE,                             by = \"Total\") tibble::as_tibble(res2) #> # A tibble: 4 × 14 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 6 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   EX.p_net <dbl>, EX.p_gross <dbl> res2[[Recca::aggregate_cols$net_aggregate_primary]] #> [1] 93000 93000 93000 98220 res2[[Recca::aggregate_cols$gross_aggregate_primary]] #> [1] 93000 93000 93000 98220"},{"path":"/articles/Aggregation.html","id":"finaldemand_aggregates","dir":"Articles","previous_headings":"","what":"finaldemand_aggregates()","title":"Aggregation","text":"finaldemand_aggregates() similar primary_aggregates(), except aggregates energy final demand stage Y matrix. net gross aggregate final demand calculated. Gross final demand includes energy industry use (EIOU). Net final demand .","code":"fd_sectors <- c(\"Residential\", \"Transport\") res <- ECCs %>%   Recca::finaldemand_aggregates(fd_sectors = fd_sectors, by = \"Sector\") tibble::as_tibble(res) #> # A tibble: 4 × 14 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 6 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   EX.fd_net <list>, EX.fd_gross <list> res[[Recca::aggregate_cols$net_aggregate_demand]] #> [[1]] #>             Product #> Residential   31000 #> Transport     40750 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" #>  #> [[2]] #>                  Product #> Residential 5.000750e+14 #> Transport   6.429166e+11 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" #>  #> [[3]] #>              Product #> Residential  4200.40 #> Transport   21714.98 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" #>  #> [[4]] #>                  Product #> Residential 5.000750e+14 #> Transport   6.429166e+11 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" res[[Recca::aggregate_cols$gross_aggregate_demand]] #> [[1]] #>             Product #> Residential   31000 #> Transport     40750 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" #>  #> [[2]] #>                  Product #> Residential 5.000750e+14 #> Transport   6.429166e+11 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" #>  #> [[3]] #>              Product #> Residential  4200.40 #> Transport   21714.98 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" #>  #> [[4]] #>                  Product #> Residential 5.000750e+14 #> Transport   6.429166e+11 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\""},{"path":"/articles/Aggregation.html","id":"region_aggregates","dir":"Articles","previous_headings":"","what":"region_aggregates()","title":"Aggregation","text":"region_aggregates() sums regions according many_colname few_colname. demonstrate function, need modify example data frame slightly. contains one country (“GBR”), contain different countries “” column. Furthermore, last stage energy type columns aggregation required. following code produces modification pretend rows data frame apply different countries. Given modification, aggregate continents following code. default, many_colname replaced common values few_colname. simple rename can override default behaviour.","code":"ECCs_for_region_agg <- ECCs |>    dplyr::mutate(     Country = c(\"USA\", \"GBR\", \"CAN\", \"FRA\"),      Continent = c(\"NoAmr\", \"Europe\", \"NoAmr\", \"Europe\"),      Energy.type = \"E\",      Last.stage = c(\"Final\", \"Services\", \"Final\", \"Services\")   ) ECCs_for_region_agg |>    dplyr::select(Country, Continent, Energy.type, Last.stage) #> # A tibble: 4 × 4 #>   Country Continent Energy.type Last.stage #>   <chr>   <chr>     <chr>       <chr>      #> 1 USA     NoAmr     E           Final      #> 2 GBR     Europe    E           Services   #> 3 CAN     NoAmr     E           Final      #> 4 FRA     Europe    E           Services continent_aggregations <- ECCs_for_region_agg |>    Recca::region_aggregates(many_colname = \"Country\", few_colname = \"Continent\") continent_aggregations #> # A tibble: 2 × 12 #>    Year Energy.type Last.stage Country R             S_units  U_EIOU   U_feed   #>   <dbl> <chr>       <chr>      <chr>   <list>        <list>   <list>   <list>   #> 1  2000 E           Final      NoAmr   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2  2000 E           Services   Europe  <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 4 more variables: V <list>, Y <list>, U <list>, r_EIOU <list> continent_aggregations |>    dplyr::rename(     Continent = Country   ) #> # A tibble: 2 × 12 #>    Year Energy.type Last.stage Continent R        S_units  U_EIOU   U_feed   #>   <dbl> <chr>       <chr>      <chr>     <list>   <list>   <list>   <list>   #> 1  2000 E           Final      NoAmr     <dbl[…]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2  2000 E           Services   Europe    <dbl[…]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 4 more variables: V <list>, Y <list>, U <list>, r_EIOU <list>"},{"path":"/articles/Aggregation.html","id":"despecified_aggregates","dir":"Articles","previous_headings":"","what":"despecified_aggregates()","title":"Aggregation","text":"row column names PSUT matrices “specified,” look like “Resources [Crude]” “NG [Wells]”. Many labels can “noun [preposition object]” structure, call “specified.” despecified_aggregates() eliminates specification row /column names, keeping desired piece (default “noun”), aggregates (sums) rows columns resulting identical names. See comments examples . last example (final demand matrix, Y) shows, aggregating despecified row column names can lead information loss. Thus, despecified_aggregates() normally called last step calculation chain.","code":"despecified_aggs <- ECCs |>    # Accept the default \"noun\" aggregation   # and the default \"_aggregated\" suffix for    # aggregated columns.   despecified_aggregates()  # This is the original R matrix. # Its row names are specified. ECCs$R[[1]] #>                      Crude    NG #> Resources [of Crude] 50000     0 #> Resources [of NG]        0 43000 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\"  # This is the despecified R matrix. # Note the single Resources row. despecified_aggs$R_aggregated[[1]] #>           Crude    NG #> Resources 50000 43000 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\"  # Here is an original use matrix. # Many rows are specified. ECCs$U[[2]] #>                         Car engines   Cars Crude dist. Diesel dist. Elect. grid #> Crude                             0    0.0           0     0.00e+00           0 #> Crude [from Dist.]                0    0.0           0     0.00e+00           0 #> Crude [from Fields]               0    0.0       47500     0.00e+00           0 #> Diesel                            0    0.0           0     1.55e+04           0 #> Diesel [from Dist.]               0    0.0           0     0.00e+00           0 #> Elect                             0    0.0           0     0.00e+00        6400 #> Elect [from Grid]                 0    0.0          25     0.00e+00           0 #> Freight [tonne-km/year]           0    0.0  1666685185     1.50e+09           0 #> Light                             0    0.0           0     0.00e+00           0 #> LTH                               0    0.0           0     0.00e+00           0 #> MD [from Car engines]             0 3000.4           0     0.00e+00           0 #> MD [from Truck engines]           0    0.0           0     0.00e+00           0 #> NG                                0    0.0           0     0.00e+00           0 #> NG [from Dist.]                   0    0.0           0     0.00e+00           0 #> NG [from Wells]                   0    0.0           0     0.00e+00           0 #> Petrol                            0    0.0           0     0.00e+00           0 #> Petrol [from Dist.]           26000    0.0           0     0.00e+00           0 #>                         Furnaces Gas wells & proc. Homes Light fixtures #> Crude                          0                 0     0              0 #> Crude [from Dist.]             0                 0     0              0 #> Crude [from Fields]            0                 0     0              0 #> Diesel                         0                 0     0              0 #> Diesel [from Dist.]            0                50     0              0 #> Elect                          0                 0     0              0 #> Elect [from Grid]              0                25     0           6000 #> Freight [tonne-km/year]        0                 0     0              0 #> Light                          0                 0     0              0 #> LTH                            0                 0 20000              0 #> MD [from Car engines]          0                 0     0              0 #> MD [from Truck engines]        0                 0     0              0 #> NG                             0             43000     0              0 #> NG [from Dist.]            25000                 0     0              0 #> NG [from Wells]                0                 0     0              0 #> Petrol                         0                 0     0              0 #> Petrol [from Dist.]            0                 0     0              0 #>                           NG dist. Oil fields Oil refineries Petrol dist. #> Crude                            0      50000              0     0.00e+00 #> Crude [from Dist.]               0          0          47000     0.00e+00 #> Crude [from Fields]              0          0              0     0.00e+00 #> Diesel                           0          0              0     0.00e+00 #> Diesel [from Dist.]              0         50              0     0.00e+00 #> Elect                            0          0              0     0.00e+00 #> Elect [from Grid]               25         25             75     0.00e+00 #> Freight [tonne-km/year] 1666685185          0              0     2.25e+09 #> Light                            0          0              0     0.00e+00 #> LTH                              0          0              0     0.00e+00 #> MD [from Car engines]            0          0              0     0.00e+00 #> MD [from Truck engines]          0          0              0     0.00e+00 #> NG                               0          0              0     0.00e+00 #> NG [from Dist.]                  0          0              0     0.00e+00 #> NG [from Wells]              41000          0              0     0.00e+00 #> Petrol                           0          0              0     2.65e+04 #> Petrol [from Dist.]              0          0              0     0.00e+00 #>                         Power plants Rooms Truck engines  Trucks #> Crude                              0     0             0    0.00 #> Crude [from Dist.]                 0     0             0    0.00 #> Crude [from Fields]                0     0             0    0.00 #> Diesel                             0     0             0    0.00 #> Diesel [from Dist.]                0     0         15050    0.00 #> Elect                              0     0             0    0.00 #> Elect [from Grid]                100     0             0    0.00 #> Freight [tonne-km/year]            0     0             0    0.00 #> Light                              0  1200             0    0.00 #> LTH                                0     0             0    0.00 #> MD [from Car engines]              0     0             0    0.00 #> MD [from Truck engines]            0     0             0 1799.98 #> NG                                 0     0             0    0.00 #> NG [from Dist.]                16000     0             0    0.00 #> NG [from Wells]                    0     0             0    0.00 #> Petrol                             0     0             0    0.00 #> Petrol [from Dist.]                0     0             0    0.00 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\"  # Here is the corresponding despecified use matrix.  # None of the rows are specified. despecified_aggs$U_aggregated[[2]] #>         Car engines   Cars Crude dist Diesel dist Elect Furnaces #> Crude             0    0.0      47500    0.00e+00     0        0 #> Diesel            0    0.0          0    1.55e+04     0        0 #> Elect             0    0.0         25    0.00e+00  6400        0 #> Freight           0    0.0 1666685185    1.50e+09     0        0 #> Light             0    0.0          0    0.00e+00     0        0 #> LTH               0    0.0          0    0.00e+00     0        0 #> MD                0 3000.4          0    0.00e+00     0        0 #> NG                0    0.0          0    0.00e+00     0    25000 #> Petrol        26000    0.0          0    0.00e+00     0        0 #>         Gas wells & proc Homes Light fixtures    NG dist Oil fields #> Crude                  0     0              0          0      50000 #> Diesel                50     0              0          0         50 #> Elect                 25     0           6000         25         25 #> Freight                0     0              0 1666685185          0 #> Light                  0     0              0          0          0 #> LTH                    0 20000              0          0          0 #> MD                     0     0              0          0          0 #> NG                 43000     0              0      41000          0 #> Petrol                 0     0              0          0          0 #>         Oil refineries Petrol dist Power plants Rooms Truck engines  Trucks #> Crude            47000    0.00e+00            0     0             0    0.00 #> Diesel               0    0.00e+00            0     0         15050    0.00 #> Elect               75    0.00e+00          100     0             0    0.00 #> Freight              0    2.25e+09            0     0             0    0.00 #> Light                0    0.00e+00            0  1200             0    0.00 #> LTH                  0    0.00e+00            0     0             0    0.00 #> MD                   0    0.00e+00            0     0             0 1799.98 #> NG                   0    0.00e+00        16000     0             0    0.00 #> Petrol               0    2.65e+04            0     0             0    0.00 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\"  # Here is an original make matrix # with many specified columns. ECCs$V[[3]] #>                   Crude [from Dist.] Crude [from Fields] Diesel #> Car engines                        0                   0      0 #> Crude dist.                    47000                   0      0 #> Diesel dist.                       0                   0      0 #> Elect. grid                        0                   0      0 #> Furnaces                           0                   0      0 #> Gas wells & proc.                  0                   0      0 #> Light fixtures                     0                   0      0 #> NG dist.                           0                   0      0 #> Oil fields                         0               47500      0 #> Oil refineries                     0                   0  15500 #> Petrol dist.                       0                   0      0 #> Power plants                       0                   0      0 #> Truck engines                      0                   0      0 #>                   Diesel [from Dist.] Elect Elect [from Grid] Light   LTH #> Car engines                         0     0                 0     0     0 #> Crude dist.                         0     0                 0     0     0 #> Diesel dist.                    15150     0                 0     0     0 #> Elect. grid                         0     0              6275     0     0 #> Furnaces                            0     0                 0     0 20000 #> Gas wells & proc.                   0     0                 0     0     0 #> Light fixtures                      0     0                 0  1200     0 #> NG dist.                            0     0                 0     0     0 #> Oil fields                          0     0                 0     0     0 #> Oil refineries                      0     0                 0     0     0 #> Petrol dist.                        0     0                 0     0     0 #> Power plants                        0  6400                 0     0     0 #> Truck engines                       0     0                 0     0     0 #>                   MD [from Car engines] MD [from Truck engines] NG [from Dist.] #> Car engines                      3000.4                    0.00               0 #> Crude dist.                         0.0                    0.00               0 #> Diesel dist.                        0.0                    0.00               0 #> Elect. grid                         0.0                    0.00               0 #> Furnaces                            0.0                    0.00               0 #> Gas wells & proc.                   0.0                    0.00               0 #> Light fixtures                      0.0                    0.00               0 #> NG dist.                            0.0                    0.00           41000 #> Oil fields                          0.0                    0.00               0 #> Oil refineries                      0.0                    0.00               0 #> Petrol dist.                        0.0                    0.00               0 #> Power plants                        0.0                    0.00               0 #> Truck engines                       0.0                 1799.98               0 #>                   NG [from Wells] Petrol Petrol [from Dist.] #> Car engines                     0      0                   0 #> Crude dist.                     0      0                   0 #> Diesel dist.                    0      0                   0 #> Elect. grid                     0      0                   0 #> Furnaces                        0      0                   0 #> Gas wells & proc.           41000      0                   0 #> Light fixtures                  0      0                   0 #> NG dist.                        0      0                   0 #> Oil fields                      0      0                   0 #> Oil refineries                  0  26500                   0 #> Petrol dist.                    0      0               26000 #> Power plants                    0      0                   0 #> Truck engines                   0      0                   0 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\"  # None of the columns are specified # in the despecified version. despecified_aggs$V_aggregated[[3]] #>                  Crude Diesel Elect Light   LTH      MD    NG Petrol #> Car engines          0      0     0     0     0 3000.40     0      0 #> Crude dist       47000      0     0     0     0    0.00     0      0 #> Diesel dist          0  15150     0     0     0    0.00     0      0 #> Elect                0      0  6275     0     0    0.00     0      0 #> Furnaces             0      0     0     0 20000    0.00     0      0 #> Gas wells & proc     0      0     0     0     0    0.00 41000      0 #> Light fixtures       0      0     0  1200     0    0.00     0      0 #> NG dist              0      0     0     0     0    0.00 41000      0 #> Oil fields       47500      0     0     0     0    0.00     0      0 #> Oil refineries       0  15500     0     0     0    0.00     0  26500 #> Petrol dist          0      0     0     0     0    0.00     0  26000 #> Power plants         0      0  6400     0     0    0.00     0      0 #> Truck engines        0      0     0     0     0 1799.98     0      0 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\"  # This original final demand matrix # has specified rownames # that provide units. ECCs$Y[[4]] #>                             Residential    Transport #> Freight [tonne-km/year]         0.0e+00 142916629629 #> Illumination [lumen-hrs/yr]     5.0e+14            0 #> Passenger [passenger-km/yr]     0.0e+00 500000000000 #> Space heating [m3-K]            7.5e+10            0 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\"  # Despecifying this matrix eliminates the units, # resulting in information loss. despecified_aggs$Y_aggregated[[4]] #>               Residential    Transport #> Freight           0.0e+00 142916629629 #> Illumination      5.0e+14            0 #> Passenger         0.0e+00 500000000000 #> Space heating     7.5e+10            0 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\""},{"path":"/articles/Aggregation.html","id":"grouped_aggregates","dir":"Articles","previous_headings":"","what":"grouped_aggregates()","title":"Aggregation","text":"Grouping provides capability aggregate specific energy products classes energy groupings processing stages final demand categories. example, Anthracite Brown coal can grouped Coal coal products. aggregation map required. demonstrate grouped aggregation, first establish aggregation map. aggregation map named list list members aggregated member names. aggregation map can used grouped_aggregates() desired aggregation. Aggregation columns added right .sut_data data frame.","code":"agg_map <- list(`Crude oil` = c(\"Crude\", \"Crude [from Dist.]\", \"Crude [from Fields]\"),                  `Oil and oil products` = c(\"Diesel\", \"Diesel [from Dist.]\",                                             \"Petrol\", \"Petrol [from Dist.]\"),                  NG = c(\"NG\", \"NG [from Dist.]\", \"NG [from Wells]\"),                 Electricity = c(\"Elect\", \"Elect [from Grid]\")) # Here is an original use matrix. ECCs$U[[1]] #>                     Crude dist. Diesel dist. Elect. grid Gas wells & proc. #> Crude                         0            0           0                 0 #> Crude [from Dist.]          500            0           0                 0 #> Crude [from Fields]       47500            0           0                 0 #> Diesel                        0        15500           0                 0 #> Diesel [from Dist.]          25          350           0                50 #> Elect                         0            0        6400                 0 #> Elect [from Grid]            25            0           0                25 #> NG                            0            0           0             43000 #> NG [from Dist.]               0            0           0                 0 #> NG [from Wells]               0            0           0              2000 #> Petrol                        0            0           0                 0 #> Petrol [from Dist.]           0            0           0                 0 #>                     NG dist. Oil fields Oil refineries Petrol dist. #> Crude                      0      50000              0            0 #> Crude [from Dist.]         0          0          47000            0 #> Crude [from Fields]        0       2500              0            0 #> Diesel                     0          0           5000            0 #> Diesel [from Dist.]       25         50              0          250 #> Elect                      0          0              0            0 #> Elect [from Grid]         25         25             75            0 #> NG                         0          0              0            0 #> NG [from Dist.]            0          0              0            0 #> NG [from Wells]        41000          0              0            0 #> Petrol                     0          0              0        26500 #> Petrol [from Dist.]        0          0              0          500 #>                     Power plants #> Crude                          0 #> Crude [from Dist.]             0 #> Crude [from Fields]            0 #> Diesel                         0 #> Diesel [from Dist.]            0 #> Elect                          0 #> Elect [from Grid]            100 #> NG                             0 #> NG [from Dist.]            16000 #> NG [from Wells]                0 #> Petrol                         0 #> Petrol [from Dist.]            0 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\"  # Aggregate to the desired groups. ECCs_grouped_aggs <- ECCs |>    grouped_aggregates(aggregation_map = agg_map)  # Here is the aggregated use matrix. # Note that the rows are summed # and named according to the agg_map. ECCs_grouped_aggs$U_aggregated[[1]] #>                      Crude dist. Diesel dist. Elect. grid Gas wells & proc. #> Crude oil                  48000            0           0                 0 #> Electricity                   25            0        6400                25 #> NG                             0            0           0             45000 #> Oil and oil products          25        15850           0                50 #>                      NG dist. Oil fields Oil refineries Petrol dist. #> Crude oil                   0      52500          47000            0 #> Electricity                25         25             75            0 #> NG                      41000          0              0            0 #> Oil and oil products       25         50           5000        27250 #>                      Power plants #> Crude oil                       0 #> Electricity                   100 #> NG                          16000 #> Oil and oil products            0 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\""},{"path":"/articles/Aggregation.html","id":"pfu_aggregates","dir":"Articles","previous_headings":"","what":"pfu_aggregates()","title":"Aggregation","text":"Aggregating primary, final, useful stages energy conversion chain (ECC) can accomplished pfu_aggregates(). Aggregates added columns right .sutdata data frame. Primary industries final demand sectors specified character vectors p_industries fd_sectors arguments.","code":"# Get the defaul separator for column names sep <- Recca::all_stages$last_stage_sep # Set primary industry names and final demand sector names p_industries <- c(\"Resources [of Crude]\", \"Resources [of NG]\") fd_sectors <- c(\"Residential\", \"Transport\", \"Oil fields\") # Calculate TOTAL aggregates pfu_aggs_total <- UKEnergy2000mats |>   tidyr::pivot_wider(names_from = matrix.name, values_from = matrix) |>   pfu_aggregates(p_industries = p_industries, fd_sectors = fd_sectors,                  by = \"Total\") # Look at the column names. # The naming scheme is  # EX.stage.gn___lsStage # EX = energy or exergy aggregate (depending on the value in the Energy.type column) # stage = the stage at which the aggregation is computed # gn = whether the aggregate is \"gross\" or \"net\" # ____ls = the separator (Recca::all_stages$last_stage_sep) # Stage = The last stage in the ECC for this column. names(pfu_aggs_total) #>  [1] \"Country\"                 \"Year\"                    #>  [3] \"Energy.type\"             \"R___lsFinal\"             #>  [5] \"U___lsFinal\"             \"U_feed___lsFinal\"        #>  [7] \"U_EIOU___lsFinal\"        \"r_EIOU___lsFinal\"        #>  [9] \"V___lsFinal\"             \"Y___lsFinal\"             #> [11] \"S_units___lsFinal\"       \"R___lsUseful\"            #> [13] \"U___lsUseful\"            \"U_feed___lsUseful\"       #> [15] \"U_EIOU___lsUseful\"       \"r_EIOU___lsUseful\"       #> [17] \"V___lsUseful\"            \"Y___lsUseful\"            #> [19] \"S_units___lsUseful\"      \"R___lsServices\"          #> [21] \"U___lsServices\"          \"U_feed___lsServices\"     #> [23] \"U_EIOU___lsServices\"     \"r_EIOU___lsServices\"     #> [25] \"V___lsServices\"          \"Y___lsServices\"          #> [27] \"S_units___lsServices\"    \"EX.p_net___lsFinal\"      #> [29] \"EX.p_gross___lsFinal\"    \"EX.p_net___lsUseful\"     #> [31] \"EX.p_gross___lsUseful\"   \"EX.p_net___lsServices\"   #> [33] \"EX.p_gross___lsServices\" \"EX.f_net___lsFinal\"      #> [35] \"EX.f_gross___lsFinal\"    \"EX.f_net___lsUseful\"     #> [37] \"EX.f_gross___lsUseful\"   \"EX.f_net___lsServices\"   #> [39] \"EX.f_gross___lsServices\" \"EX.u_net___lsFinal\"      #> [41] \"EX.u_gross___lsFinal\"    \"EX.u_net___lsUseful\"     #> [43] \"EX.u_gross___lsUseful\"   \"EX.u_net___lsServices\"   #> [45] \"EX.u_gross___lsServices\" \"EX.s_net___lsFinal\"      #> [47] \"EX.s_gross___lsFinal\"    \"EX.s_net___lsUseful\"     #> [49] \"EX.s_gross___lsUseful\"   \"EX.s_net___lsServices\"   #> [51] \"EX.s_gross___lsServices\" # Check some aggregation values. # Note that not all aggregations are available,  # based on the structure of the ECC.  # Net primary energy aggregation when last stage is Final pfu_aggs_total |>   dplyr::filter(Energy.type == \"E\") |>   magrittr::extract2(\"EX.p_net___lsFinal\") |>   magrittr::extract2(1) #> [1] 93000 # Net primary exergy aggregation when last stage is Services pfu_aggs_total |>   dplyr::filter(Energy.type == \"X\") |>   magrittr::extract2(\"EX.p_net___lsServices\") |>   magrittr::extract2(1) #> [1] 98220 # Gross final energy aggregation when last stage is Useful pfu_aggs_total |>   dplyr::filter(Energy.type == \"E\") |>   magrittr::extract2(\"EX.f_gross___lsFinal\") |>   magrittr::extract2(1) #> [1] 74325 # Gross useful energy aggregation when last stage is Useful pfu_aggs_total |>   dplyr::filter(Energy.type == \"E\") |>   magrittr::extract2(\"EX.u_gross___lsUseful\") |>   magrittr::extract2(1) #> [1] 25990.38 # Net useful energy aggregation when last stage is Useful pfu_aggs_total |>   dplyr::filter(Energy.type == \"E\") |>   magrittr::extract2(\"EX.u_net___lsUseful\") |>   magrittr::extract2(1) #> [1] 25915.38 # Calculate PRODUCT aggregates pfu_aggs_product <- UKEnergy2000mats |>   tidyr::pivot_wider(names_from = matrix.name, values_from = matrix) |>   pfu_aggregates(p_industries = p_industries, fd_sectors = fd_sectors,                  by = \"Product\") # Net primary energy aggregation when last stage is Final # Note that all results are now vectors which  # show aggregation by product pfu_aggs_product |>   dplyr::filter(Energy.type == \"E\") |>   magrittr::extract2(\"EX.p_net___lsFinal\") |>   magrittr::extract2(1) #>       Industry #> Crude    50000 #> NG       43000 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" pfu_aggs_product |>   dplyr::filter(Energy.type == \"E\") |>   magrittr::extract2(\"EX.u_net___lsUseful\") |>   magrittr::extract2(1) #>                         Industry #> Light                    1200.00 #> LTH                     20000.00 #> MD [from Car engines]    3000.40 #> MD [from Truck engines]  1714.98 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" # Calculate INDUSTRY aggregates # Note that all results are now vectors which  # show aggregation by industry pfu_aggs_industry <- UKEnergy2000mats |>   tidyr::pivot_wider(names_from = matrix.name, values_from = matrix) |>   pfu_aggregates(p_industries = p_industries, fd_sectors = fd_sectors,                  by = \"Industry\") pfu_aggs_industry |>   dplyr::filter(Energy.type == \"E\") |>   magrittr::extract2(\"EX.p_net___lsFinal\") |>   magrittr::extract2(1) #>         Resources [of Crude] Resources [of NG] #> Product                50000             43000 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" pfu_aggs_industry |>   dplyr::filter(Energy.type == \"E\") |>   magrittr::extract2(\"EX.u_net___lsUseful\") |>   magrittr::extract2(1) #>         Residential Transport #> Product      4200.4  21714.98 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\""},{"path":"/articles/Aggregation.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Aggregation","text":"Several functions Recca package assist aggregations energy conversion chains. primary_aggregates(), finaldemand_aggregates(), region_aggregates(), despecified_aggregates(), grouped_aggregates(), pfu_aggregates() assist different types aggregations. Please see help functions details.","code":""},{"path":"/articles/Recca.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Recca","text":"Recca (R Energy Conversion Chain Analysis) R package enables energy exergy analysis energy conversion chains. Recca makes extensive use matrix-based Physical Supply Use Table (PSUT) analysis technique first appeared Heun et al. [-@Heun:2018]. vignette walks many calculations Heun et al. [-@Heun:2018], guided section numbers paper. begin discussing design philosophy Recca package, followed discussion PSUT matrices comprise energy conversion chain (ECC). Thereafter, calculation input-output structure ECC demonstrated. Finally, advanced calculations shown, including changes final demand, net energy analysis, industry efficiencies, energy footprints.","code":""},{"path":"/articles/Recca.html","id":"design-philosophy","dir":"Articles","previous_headings":"","what":"Design philosophy","title":"Recca","text":"functions Recca flexibly designed useful many situations. Recca’s flexibility stems extensive use matsbyname matsindf packages hood. Inputs Recca functions can one : matrices (individual matrices arguments Recca functions), list first argument (names list indicating argument names), data frame (names data frame columns, strings, arguments Recca functions). Outputs either named matrices list (1 2 ) named columns appended input data frame (3 ). Argument names matrices follow standard nomenclature. recommended default matrix names used whenever possible, thereby allowing cleaner code.","code":""},{"path":"/articles/Recca.html","id":"psut-matrices","dir":"Articles","previous_headings":"","what":"PSUT matrices","title":"Recca","text":"(Reference Heun et al. [-@Heun:2018], Section 2.2.2.) examples follow, ’ll use UKEnergy2000tidy data frame. row UKEnergy2000tidy data frame represents another datum portion ECC UK 2000. UKEnergy2000tidy format similar data IEA organizations. data format UKEnergy2000tidy, can create S_units matrices grouping using S_units_from_tidy() function. can identify entries belong resource (\\(\\mathbf{R}\\)), make (\\(\\mathbf{V}\\)), use (\\(\\mathbf{U}\\)), final demand (\\(\\mathbf{Y}\\)) matrices IEATools::add_psut_matnames() IEATools::add_row_col_meta() functions. identifying matrices, rownames, colnames, rowtypes, coltypes, can collapse data matrices add unit summation matrix (S_units). AsMats data frame essentially Recca::UKEnergy2000mats data frame. remainder vignette uses UKEnergy2000mats data frame.","code":"library(tibble) S_units <- UKEnergy2000tidy %>%   dplyr::group_by(Country, Year, Energy.type, Last.stage) %>%   S_units_from_tidy() tibble::glimpse(S_units) #> Rows: 4 #> Columns: 5 #> $ Country     <chr> \"GBR\", \"GBR\", \"GBR\", \"GBR\" #> $ Year        <dbl> 2000, 2000, 2000, 2000 #> $ Energy.type <chr> \"E\", \"E\", \"E\", \"X\" #> $ Last.stage  <chr> \"Final\", \"Services\", \"Useful\", \"Services\" #> $ S_units     <list> <<matrix[12 x 1]>>, <<matrix[20 x 5]>>, <<matrix[16 x 1]>>… WithNames <- UKEnergy2000tidy %>%   # Add a column indicating the matrix in which this entry belongs (U, V, or Y).   IEATools::add_psut_matnames() %>%   # Add metadata columns for row names, column names, row types, and column types.   IEATools::add_row_col_meta() %>%    # Eliminate columns we no longer need   dplyr::select(-Ledger.side, -Flow.aggregation.point, -Flow, -Product) %>%   dplyr::mutate(     # Ensure that all energy values are positive, as required for analysis.     E.dot = abs(E.dot)   ) head(WithNames) #>   Country Year Energy.type Last.stage E.dot Unit matnames             rownames #> 1     GBR 2000           E      Final 50000 ktoe        R Resources [of Crude] #> 2     GBR 2000           E      Final 43000 ktoe        R    Resources [of NG] #> 3     GBR 2000           E      Final 43000 ktoe        V    Gas wells & proc. #> 4     GBR 2000           E      Final 50000 ktoe        V           Oil fields #> 5     GBR 2000           E      Final 47500 ktoe        V          Crude dist. #> 6     GBR 2000           E      Final 41000 ktoe        V             NG dist. #>              colnames rowtypes coltypes #> 1               Crude Industry  Product #> 2                  NG Industry  Product #> 3     NG [from Wells] Industry  Product #> 4 Crude [from Fields] Industry  Product #> 5  Crude [from Dist.] Industry  Product #> 6     NG [from Dist.] Industry  Product AsMats <- WithNames %>%   # Collapse to matrices using functions in the matsindf package   dplyr::group_by(Country, Year, Energy.type, Last.stage, matnames) %>%   matsindf::collapse_to_matrices(matnames = \"matnames\", matvals = \"E.dot\",                        rownames = \"rownames\", colnames = \"colnames\",                        rowtypes = \"rowtypes\", coltypes = \"coltypes\") %>%   dplyr::rename(matrix.name = matnames, matrix = E.dot) %>%   tidyr::spread(key = matrix.name, value = matrix) %>%    # Do a little more cleanup   dplyr::mutate(     # Create full U matrix     U = matsbyname::sum_byname(U_feed, U_EIOU),     # Create r_EIOU, a matrix that identifies the ratio of EIOU to other energy consumed.     r_EIOU = matsbyname::quotient_byname(U_EIOU, U),     r_EIOU = matsbyname::replaceNaN_byname(r_EIOU, val = 0)   ) %>%    dplyr::select(-U_EIOU, -U_feed) %>%   # Add S_units matrices   dplyr::left_join(S_units, by = c(\"Country\", \"Year\", \"Energy.type\", \"Last.stage\")) %>%   tidyr::gather(key = matrix.name, value = matrix, R, U, V, Y, r_EIOU, S_units) tibble::glimpse(AsMats) #> Rows: 24 #> Columns: 6 #> $ Country     <chr> \"GBR\", \"GBR\", \"GBR\", \"GBR\", \"GBR\", \"GBR\", \"GBR\", \"GBR\", \"G… #> $ Year        <dbl> 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000… #> $ Energy.type <chr> \"E\", \"E\", \"E\", \"X\", \"E\", \"E\", \"E\", \"X\", \"E\", \"E\", \"E\", \"X\"… #> $ Last.stage  <chr> \"Final\", \"Services\", \"Useful\", \"Services\", \"Final\", \"Servi… #> $ matrix.name <chr> \"R\", \"R\", \"R\", \"R\", \"U\", \"U\", \"U\", \"U\", \"V\", \"V\", \"V\", \"V\"… #> $ matrix      <list> <<matrix[2 x 2]>>, <<matrix[2 x 2]>>, <<matrix[2 x 2]>>, …"},{"path":"/articles/Recca.html","id":"i-o-structure","dir":"Articles","previous_headings":"","what":"I-O structure","title":"Recca","text":"(Reference Heun et al. [-@Heun:2018], Section 2.2.4.)","code":""},{"path":"/articles/Recca.html","id":"with-individual-matrices","dir":"Articles","previous_headings":"I-O structure","what":"With individual matrices","title":"Recca","text":"determine -O structure ECC, use calc_io_mats() function. Recca functions return list called individual matrices arguments. calc_io_mats() function gives several -O matrices returned list. calculations can performed supplying named list Recca functions. approach, original data returned list. case, matrices \\(\\mathbf{U}\\), \\(\\mathbf{V}\\), \\(\\mathbf{Y}\\), \\(\\mathbf{S_{units}}\\) also returned calc_io_mats() function. list supplied Recca function .sutmats argument, input arguments must strings identify names appropriate entries .sutmats list containing named vectors matrices. Helpfully, default values input arguments conform standard nomenclature. using standard nomenclature, Recca functions can use default arguments input output items list.","code":"library(tidyr) mats <- UKEnergy2000mats %>%    tidyr::spread(key = matrix.name, value = matrix) %>%    # Put rows in a natural order   dplyr::mutate(     Last.stage = factor(Last.stage, levels = c(\"Final\", \"Useful\", \"Services\")),     Energy.type = factor(Energy.type, levels = c(\"E\", \"X\"))   ) %>%    dplyr::arrange(Last.stage, Energy.type) # Use the calc_io_mats function with individual matrices,  # each taken from the first row of the UKEnergy2000mats data frame. R <- mats$R[[1]] U <- mats$U[[1]] U_feed = mats$U_feed[[1]] V <- mats$V[[1]] Y <- mats$Y[[1]] S_units <- mats$S_units[[1]] IO_list <- calc_io_mats(R = R, U = U, U_feed = U_feed, V = V, Y = Y, S_units = S_units) class(IO_list) #> [1] \"list\" names(IO_list) #>  [1] \"y\"          \"q\"          \"f\"          \"g\"          \"h\"          #>  [6] \"r\"          \"W\"          \"Z\"          \"K\"          \"C\"          #> [11] \"D\"          \"A\"          \"O\"          \"L_pxp\"      \"L_ixp\"      #> [16] \"Z_feed\"     \"K_feed\"     \"A_feed\"     \"L_pxp_feed\" \"L_ixp_feed\" IO_list[[\"y\"]] #>                     Industry #> Diesel [from Dist.]    14750 #> Elect [from Grid]       6000 #> NG [from Dist.]        25000 #> Petrol [from Dist.]    26000 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" IO_from_list <- calc_io_mats(list(R = R, U = U, U_feed = U_feed, V = V, Y = Y, S_units = S_units)) class(IO_from_list) #> [1] \"list\" names(IO_from_list) #>  [1] \"R\"          \"U\"          \"U_feed\"     \"V\"          \"Y\"          #>  [6] \"S_units\"    \"y\"          \"q\"          \"f\"          \"g\"          #> [11] \"h\"          \"r\"          \"W\"          \"Z\"          \"K\"          #> [16] \"C\"          \"D\"          \"A\"          \"O\"          \"L_pxp\"      #> [21] \"L_ixp\"      \"Z_feed\"     \"K_feed\"     \"A_feed\"     \"L_pxp_feed\" #> [26] \"L_ixp_feed\" IO_from_list[[\"y\"]] #>                     Industry #> Diesel [from Dist.]    14750 #> Elect [from Grid]       6000 #> NG [from Dist.]        25000 #> Petrol [from Dist.]    26000 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\""},{"path":"/articles/Recca.html","id":"from-a-matsindf-style-data-frame","dir":"Articles","previous_headings":"I-O structure","what":"From a matsindf-style data frame","title":"Recca","text":"Recca functions can also operate matsindf-style data frame. (matsindf-style data frame matrices cells data frame. See matsindf package additional information.) data frame supplied Recca function .sutmats argument, input arguments must strings identify names appropriate columns .sutmats containing named vectors matrices. Helpfully, default values input arguments conform standard nomenclature. using standard nomenclature, Recca functions can use default arguments input output columns. approach yields clean piped code, shown . illustrate features Recca functions, ’ll apply calc_io_mats function entire UKEnergy2000mats data frame, calculating appropriate -O matrices row. Used way, Recca functions act like specialized dplyr::mutate() functions, new columns added right side data frame supplied .sutmats argument. inspecting IO_df, can see, example, one \\(\\mathbf{y}\\) vector calculated four rows mats. true -O matrices calculated calc_io_mats. remainder vignette, operations performed entire UKEnergy2000mats data frame. readers remember functions can called named lists individual matrices, well.","code":"IO_df <- mats %>% calc_io_mats() class(IO_df) #> [1] \"tbl_df\"     \"tbl\"        \"data.frame\" names(IO_df) #>  [1] \"Country\"     \"Year\"        \"Energy.type\" \"Last.stage\"  \"R\"           #>  [6] \"r_EIOU\"      \"S_units\"     \"U\"           \"U_EIOU\"      \"U_feed\"      #> [11] \"V\"           \"Y\"           \"y\"           \"q\"           \"f\"           #> [16] \"g\"           \"h\"           \"r\"           \"W\"           \"Z\"           #> [21] \"K\"           \"C\"           \"D\"           \"A\"           \"O\"           #> [26] \"L_pxp\"       \"L_ixp\"       \"Z_feed\"      \"K_feed\"      \"A_feed\"      #> [31] \"L_pxp_feed\"  \"L_ixp_feed\" glimpse(IO_df) #> Rows: 4 #> Columns: 32 #> $ Country     <chr> \"GBR\", \"GBR\", \"GBR\", \"GBR\" #> $ Year        <dbl> 2000, 2000, 2000, 2000 #> $ Energy.type <fct> E, E, E, X #> $ Last.stage  <fct> Final, Useful, Services, Services #> $ R           <list> <<matrix[2 x 2]>>, <<matrix[2 x 2]>>, <<matrix[2 x 2]>>, <… #> $ r_EIOU      <list> <<matrix[12 x 9]>>, <<matrix[13 x 13]>>, <<matrix[17 x 17]… #> $ S_units     <list> <<matrix[12 x 1]>>, <<matrix[16 x 1]>>, <<matrix[20 x 5]>>… #> $ U           <list> <<matrix[12 x 9]>>, <<matrix[13 x 13]>>, <<matrix[17 x 17]… #> $ U_EIOU      <list> <<matrix[7 x 8]>>, <<matrix[3 x 8]>>, <<matrix[3 x 8]>>, … #> $ U_feed      <list> <<matrix[9 x 9]>>, <<matrix[12 x 13]>>, <<matrix[16 x 17]… #> $ V           <list> <<matrix[9 x 10]>>, <<matrix[13 x 14]>>, <<matrix[17 x 18… #> $ Y           <list> <<matrix[4 x 2]>>, <<matrix[4 x 2]>>, <<matrix[4 x 2]>>, … #> $ y           <list> <<matrix[4 x 1]>>, <<matrix[4 x 1]>>, <<matrix[4 x 1]>>, … #> $ q           <list> <<matrix[12 x 1]>>, <<matrix[16 x 1]>>, <<matrix[20 x 1]>… #> $ f           <list> <<matrix[9 x 1]>>, <<matrix[13 x 1]>>, <<matrix[17 x 1]>>… #> $ g           <list> <<matrix[9 x 1]>>, <<matrix[13 x 1]>>, <<matrix[17 x 1]>>… #> $ h           <list> <<matrix[2 x 1]>>, <<matrix[2 x 1]>>, <<matrix[2 x 1]>>, … #> $ r           <list> <<matrix[2 x 1]>>, <<matrix[2 x 1]>>, <<matrix[2 x 1]>>, … #> $ W           <list> <<matrix[12 x 9]>>, <<matrix[16 x 13]>>, <<matrix[20 x 17… #> $ Z           <list> <<matrix[12 x 9]>>, <<matrix[13 x 13]>>, <<matrix[17 x 17… #> $ K           <list> <<matrix[12 x 9]>>, <<matrix[13 x 13]>>, NA, NA #> $ C           <list> <<matrix[10 x 9]>>, <<matrix[14 x 13]>>, <<matrix[18 x 17… #> $ D           <list> <<matrix[9 x 12]>>, <<matrix[13 x 16]>>, <<matrix[17 x 20… #> $ A           <list> <<matrix[12 x 12]>>, <<matrix[13 x 16]>>, <<matrix[17 x 2… #> $ O           <list> <<matrix[2 x 2]>>, <<matrix[2 x 2]>>, <<matrix[2 x 2]>>, … #> $ L_pxp       <list> <<matrix[12 x 12]>>, <<matrix[16 x 16]>>, <<matrix[20 x 2… #> $ L_ixp       <list> <<matrix[9 x 12]>>, <<matrix[13 x 16]>>, <<matrix[17 x 20… #> $ Z_feed      <list> <<matrix[9 x 9]>>, <<matrix[12 x 13]>>, <<matrix[16 x 17]… #> $ K_feed      <list> <<matrix[9 x 9]>>, <<matrix[12 x 13]>>, NA, NA #> $ A_feed      <list> <<matrix[9 x 12]>>, <<matrix[12 x 16]>>, <<matrix[16 x 20… #> $ L_pxp_feed  <list> <<matrix[12 x 12]>>, <<matrix[16 x 16]>>, <<matrix[20 x 2… #> $ L_ixp_feed  <list> <<matrix[9 x 12]>>, <<matrix[13 x 16]>>, <<matrix[17 x 20… IO_df[[\"y\"]][[1]] #>                     Industry #> Diesel [from Dist.]    14750 #> Elect [from Grid]       6000 #> NG [from Dist.]        25000 #> Petrol [from Dist.]    26000 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" IO_df[[\"y\"]][[4]] #>                                 Industry #> Freight [tonne-km/year]     1.429166e+11 #> Illumination [lumen-hrs/yr] 5.000000e+14 #> Passenger [passenger-km/yr] 5.000000e+11 #> Space heating [m3-K]        7.500000e+10 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\""},{"path":"/articles/Recca.html","id":"changes-in-final-demand","dir":"Articles","previous_headings":"","what":"Changes in final demand","title":"Recca","text":"(Reference Heun et al. [-@Heun:2018], Section 2.2.5.) One first applications input-output analysis estimating changes industry outputs required meet new final demand. Recca allows similar calculations energy conversion chains function new_Y(). Arguments new_Y() include matrices describe input-output structure ECC Y_prime, new final demand matrix. new_Y() calculates U_prime V_prime matrices represent ECC required meet new final demand represented Y_prime. See vignette new_*() functions details.","code":"Double_demand <- IO_df %>%    dplyr::mutate(     Y_prime = matsbyname::hadamardproduct_byname(2, Y)   ) %>%    new_Y() names(Double_demand) #>  [1] \"Country\"      \"Year\"         \"Energy.type\"  \"Last.stage\"   \"R\"            #>  [6] \"r_EIOU\"       \"S_units\"      \"U\"            \"U_EIOU\"       \"U_feed\"       #> [11] \"V\"            \"Y\"            \"y\"            \"q\"            \"f\"            #> [16] \"g\"            \"h\"            \"r\"            \"W\"            \"Z\"            #> [21] \"K\"            \"C\"            \"D\"            \"A\"            \"O\"            #> [26] \"L_pxp\"        \"L_ixp\"        \"Z_feed\"       \"K_feed\"       \"A_feed\"       #> [31] \"L_pxp_feed\"   \"L_ixp_feed\"   \"Y_prime\"      \"R_prime\"      \"U_prime\"      #> [36] \"U_feed_prime\" \"U_EIOU_prime\" \"r_EIOU_prime\" \"V_prime\" IO_df[[\"Y\"]][[1]][ , c(1,2)] #>                     Residential Transport #> Diesel [from Dist.]           0     14750 #> Elect [from Grid]          6000         0 #> NG [from Dist.]           25000         0 #> Petrol [from Dist.]           0     26000 Double_demand[[\"Y_prime\"]][[1]] #>                     Residential Transport #> Diesel [from Dist.]           0     29500 #> Elect [from Grid]         12000         0 #> NG [from Dist.]           50000         0 #> Petrol [from Dist.]           0     52000 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" IO_df[[\"U\"]][[1]][ , c(\"Crude dist.\", \"Diesel dist.\")] #>                     Crude dist. Diesel dist. #> Crude                         0            0 #> Crude [from Dist.]          500            0 #> Crude [from Fields]       47500            0 #> Diesel                        0        15500 #> Diesel [from Dist.]          25          350 #> Elect                         0            0 #> Elect [from Grid]            25            0 #> NG                            0            0 #> NG [from Dist.]               0            0 #> NG [from Wells]               0            0 #> Petrol                        0            0 #> Petrol [from Dist.]           0            0 Double_demand[[\"U_prime\"]][[1]][ , c(\"Crude dist.\", \"Diesel dist.\")] #>                     Crude dist. Diesel dist. #> Crude                         0            0 #> Crude [from Dist.]         1000            0 #> Crude [from Fields]       95000            0 #> Diesel                        0        31000 #> Diesel [from Dist.]          50          700 #> Elect                         0            0 #> Elect [from Grid]            50            0 #> NG                            0            0 #> NG [from Dist.]               0            0 #> NG [from Wells]               0            0 #> Petrol                        0            0 #> Petrol [from Dist.]           0            0"},{"path":"/articles/Recca.html","id":"net-energy-analysis","dir":"Articles","previous_headings":"","what":"Net energy analysis","title":"Recca","text":"(Reference Heun et al. [-@Heun:2018], Section 3.1.) energy production system consumes energy, important metrics energy conversion chain industries energy return ratios (ERRs). Recca provides function calculate three ERRs, gross energy ratio (GER), net energy ratio (NER), ratio NER GER. GER commonly called energy return investment (EROI). (See Brandt & Dale [-@Brandt:2011].) ERRs can calculated variety system boundaries. ERRs \\(\\gamma\\) system boundary can calculated readily using calc_ERRs_gamma() function. three ERRs calculated time. ERRs NA industries inputs outputs unit-inhomogeneous. ERRs Inf industries make energy product without consuming energy another processing chain (Elect. grid). results identical Fig. 6 Heun et al. [-@Heun:2018].","code":"ERRs <- IO_df %>%    calc_ERRs_gamma() ERRs$ger_gamma[[1]] #>                    ger_gamma #> Crude dist.        86.363636 #> Diesel dist.       44.285714 #> Elect. grid              Inf #> Gas wells & proc.  20.722892 #> NG dist.          820.000000 #> Oil fields         19.417476 #> Oil refineries      9.261084 #> Petrol dist.       35.333333 #> Power plants       64.000000 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" ERRs$ner_gamma[[1]] #>                    ner_gamma #> Crude dist.        85.363636 #> Diesel dist.       43.285714 #> Elect. grid              Inf #> Gas wells & proc.  19.722892 #> NG dist.          819.000000 #> Oil fields         18.417476 #> Oil refineries      8.261084 #> Petrol dist.       34.333333 #> Power plants       63.000000 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" ERRs$r_gamma[[1]] #>                     r_gamma #> Crude dist.       0.9884211 #> Diesel dist.      0.9774194 #> Elect. grid             NaN #> Gas wells & proc. 0.9517442 #> NG dist.          0.9987805 #> Oil fields        0.9485000 #> Oil refineries    0.8920213 #> Petrol dist.      0.9716981 #> Power plants      0.9843750 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\""},{"path":"/articles/Recca.html","id":"efficiencies","dir":"Articles","previous_headings":"","what":"Efficiencies","title":"Recca","text":"(Reference Heun et al. [-@Heun:2018], Section 3.2.) efficiency every industry ECC can calculated quickly calc_eta_i() function, creates column named eta_i (default) right data frame. particular ECC industries whose inputs outputs unit inhomogeneous, eta_i vector NA values appropriate places. results identical Fig. 9 Heun et al. [-@Heun:2018].","code":"etas <- IO_df %>%    calc_eta_i() names(etas) #>  [1] \"Country\"     \"Year\"        \"Energy.type\" \"Last.stage\"  \"R\"           #>  [6] \"r_EIOU\"      \"S_units\"     \"U\"           \"U_EIOU\"      \"U_feed\"      #> [11] \"V\"           \"Y\"           \"y\"           \"q\"           \"f\"           #> [16] \"g\"           \"h\"           \"r\"           \"W\"           \"Z\"           #> [21] \"K\"           \"C\"           \"D\"           \"A\"           \"O\"           #> [26] \"L_pxp\"       \"L_ixp\"       \"Z_feed\"      \"K_feed\"      \"A_feed\"      #> [31] \"L_pxp_feed\"  \"L_ixp_feed\"  \"eta_i\" etas[[\"eta_i\"]][[1]] #>                       eta_i #> Crude dist.       0.9885536 #> Diesel dist.      0.9779180 #> Elect. grid       0.9804688 #> Gas wells & proc. 0.9539656 #> NG dist.          0.9987820 #> Oil fields        0.9510223 #> Oil refineries    0.9025444 #> Petrol dist.      0.9724771 #> Power plants      0.3975155 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" etas[[\"eta_i\"]][[3]] # NAs indicate inhomogeneous units on inputs or outputs. #>                       eta_i #> Car engines       0.1154000 #> Cars                     NA #> Crude dist.              NA #> Diesel dist.             NA #> Elect. grid       0.9804688 #> Furnaces          0.8000000 #> Gas wells & proc. 0.9518282 #> Homes                    NA #> Light fixtures    0.2000000 #> NG dist.                 NA #> Oil fields        0.9485771 #> Oil refineries    0.8921933 #> Petrol dist.             NA #> Power plants      0.3975155 #> Rooms                    NA #> Truck engines     0.1196000 #> Trucks                   NA #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\""},{"path":"/articles/Recca.html","id":"energy-footprints","dir":"Articles","previous_headings":"","what":"Energy footprints","title":"Recca","text":"(Reference Heun et al. [-@Heun:2018], Section 3.3.) Final demand energy contains embodied primary energy, sum primary energy consumed wasted throughout ECC process satisfying final demand. Recca provides two functions calculate embodied primary energy important ratios, namely calc_embodied_mats() calc_embodied_etas(). function calc_embodied_mats() calculates embodied energy final demand products (\\(p\\)) final demand sectors (\\(s\\)). Outputs calc_embodied_mats() include following matrices: calc_embodied_mats() also calculates \\(\\mathbf{F}_{footprint}\\) \\(\\mathbf{F}_{ef\\!fects}\\) matrices, answer questions (respectively) “fractional composition embodied energy final demand energy type?” “fractional destination given upstream energy product?” calculations can performed final demand product final demand sector. following table describes matrices. Finally, embodied energy efficiencies can calculated final demand energy divided embodied energy. , efficiencies can calculated final demand product final demand sector. calc_embodied_etas() function computation. Note: \\(\\mathbf{s}_r\\) selection vector resource industries. Figure 15 Heun et al. [-@Heun:2018] shows primary--services energetic efficiencies ECC 3rd row IO_df. following code extracts results. Rows vector give final demand services units. column gives efficiencies units service per ktoe energy.","code":"primary_machine_names <- c(\"Resources - Crude\", \"Resources - NG\")  embodied_mats <- IO_df %>%    dplyr::mutate(     U_EIOU = matsbyname::hadamardproduct_byname(r_EIOU, U)   ) %>%   calc_embodied_mats() %>%   calc_embodied_etas(primary_machine_names = primary_machine_names) names(embodied_mats) #>  [1] \"Country\"       \"Year\"          \"Energy.type\"   \"Last.stage\"    #>  [5] \"R\"             \"r_EIOU\"        \"S_units\"       \"U\"             #>  [9] \"U_EIOU\"        \"U_feed\"        \"V\"             \"Y\"             #> [13] \"y\"             \"q\"             \"f\"             \"g\"             #> [17] \"h\"             \"r\"             \"W\"             \"Z\"             #> [21] \"K\"             \"C\"             \"D\"             \"A\"             #> [25] \"O\"             \"L_pxp\"         \"L_ixp\"         \"Z_feed\"        #> [29] \"K_feed\"        \"A_feed\"        \"L_pxp_feed\"    \"L_ixp_feed\"    #> [33] \"G_V\"           \"G_R\"           \"G\"             \"H_V\"           #> [37] \"H_R\"           \"H\"             \"E\"             \"M_p\"           #> [41] \"M_s\"           \"F_footprint_p\" \"F_effects_p\"   \"F_footprint_s\" #> [45] \"F_effects_s\"   \"eta_p\"         \"eta_s\" embodied_mats$eta_p[[3]] #>                             Industry #> Freight [tonne-km/year]          Inf #> Illumination [lumen-hrs/yr]      Inf #> Passenger [passenger-km/yr]      Inf #> Space heating [m3-K]             Inf #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\""},{"path":"/articles/Recca.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Recca","text":"vignette demonstrated use Recca package. Recca provides many useful functions analyzing energy conversion chains within PSUT framework first described Heun et al. [-@Heun:2018].","code":""},{"path":[]},{"path":"/articles/new-function-interaction.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"new_* function interactions","text":"Recca package provides several new_* functions allow user estimate new version energy conversion chain (ECC) based localized changed one portion ECC. functions can interesting interactions, particularly called sequentially. vignette show understand deal interactions. functions new_k_ps() new_Y() used purpose.","code":""},{"path":"/articles/new-function-interaction.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"new_* function interactions","text":"investigate interactions, first make simplest possible ECC retains features tested, minimum working example (MWE). example two resource industries (R1 R2), one intermediate industry (), two final demand sectors (Y1 Y2). R1 industry makes product R1p. R2 industry makes product R2p. Industry makes product Ip. Product Ip consumed final demand sectors Y1 Y2. resources (\\(\\mathbf{R}\\)), use (\\(\\mathbf{U}\\)), make (\\(\\mathbf{V}\\)), final demand (\\(\\mathbf{Y}\\)), unit summation (\\(\\mathbf{S}_{units}\\)) matrices given . ’ll use Sankey diagrams visualize several ECCs. make_sankey() function creates diagrams. Sankey diagram shows base energy conversion chain shown . make_sankey() returns list named item “Sankey” must extract insert diagram vignette.","code":"library(magrittr) library(matsbyname) library(Recca) U <- matrix(c(0, 0, 10,               0, 0, 10,               0, 0,  0),             byrow = TRUE, nrow = 3, ncol = 3,             dimnames = list(c(\"R1p\", \"R2p\", \"Ip\"), c(\"R1\", \"R2\", \"I\"))) %>%    setrowtype(\"Products\") %>% setcoltype(\"Industries\")  # There is no EIOU, so U_feed and U are the same. U_feed <- U  R_plus_V <- matrix(c(10,  0, 0,                      0, 10, 0,                       0,  0, 4),                     byrow = TRUE, nrow = 3, ncol = 3,                     dimnames = list(c(\"R1\", \"R2\", \"I\"),                                     c(\"R1p\", \"R2p\", \"Ip\"))) %>%    setrowtype(\"Industries\") %>% setcoltype(\"Products\")  RV_mats <- separate_RV(U = U, R_plus_V = R_plus_V) R <- RV_mats$R V <- RV_mats$V  Y <- matrix(c(0, 0,               0, 0,                2, 2),             byrow = TRUE, nrow = 3, ncol = 2,             dimnames = list(c(\"R1p\", \"R2p\", \"Ip\"), c(\"Y1\", \"Y2\"))) %>%    setrowtype(\"Products\") %>% setcoltype(\"Industries\")  S_units <- matrix(c(1,                      1,                      1),                    byrow = TRUE, nrow = 3, ncol = 1,                   dimnames = list(c(\"R1p\", \"R2p\", \"Ip\"), c(\"quad\"))) %>%    setrowtype(\"Products\") %>% setcoltype(\"Units\") make_sankey(R = R, U = U, V = V, Y = Y) %>%    extract2(\"Sankey\")"},{"path":"/articles/new-function-interaction.html","id":"adjust-inputs-to-industry-i","dir":"Articles","previous_headings":"","what":"Adjust inputs to industry I","title":"new_* function interactions","text":"can change proportion inputs industry using new_k_ps(). , must first calculate input-output structure ECC using calc_io_mats() function. , call new_k_ps() function new k vector indicates industry now uses 20 quads R1 instead 50/50 split R1 R2.","code":"library(Recca) iomats <- calc_io_mats(R = R, U = U, U_feed = U_feed, V = V, Y = Y, S_units = S_units) k_prime <- matrix(c(1,                     0),                    byrow = TRUE, nrow = 2, ncol = 1,                   dimnames = list(c(\"R1p\", \"R2p\"), c(\"I\"))) %>%    setrowtype(\"Products\") %>% setcoltype(\"Industries\") change_input_proportions <- new_k_ps(c(iomats,                                         list(R = R, U = U, V = V, Y = Y,                                             S_units = S_units,                                              k_prime = k_prime))) # There is no EIOU, so U and U_feed are same. change_input_proportions[[\"U_feed_prime\"]] <- change_input_proportions[[\"U_prime\"]] make_sankey(R = change_input_proportions$R_prime,              U = change_input_proportions$U_prime,              V = change_input_proportions$V_prime,              Y = Y) %>%    extract2(\"Sankey\")"},{"path":"/articles/new-function-interaction.html","id":"change-final-demand","dir":"Articles","previous_headings":"","what":"Change final demand","title":"new_* function interactions","text":"can calculate ECC required meet new level final demand new_Y() function. new_k_ps() new_Y() functions interact ways might surprising user, depending whether input-output structure ECC re-calculated sequential function calls.","code":""},{"path":"/articles/new-function-interaction.html","id":"without-recalculating-the-structure-of-the-ecc","dir":"Articles","previous_headings":"Change final demand","what":"Without recalculating the structure of the ECC","title":"new_* function interactions","text":"Now let’s change final demand, saying consumption Y1 doubles. ’ll call new_Y() without recalculating structure ECC calc_io_mats() function. Industry back using R1p R2p 50/50 split make output. R1p R2p now supply 15 quads account increased final demand. new_Y() function performing exactly expected, given iomats supplied new_Y(). iomats contains information ECC industry ’s inputs split 50/50 R1p R2p. new_Y() calculates new ECC, assumes industry ’s needs 50/50 split R1p R2p. fact, mistake think new_Y() give anything 50/50 split R1p R2p using iomats description ECC.","code":"Y_prime <- matrix(c(0, 0,                     0, 0,                      4, 2),                   byrow = TRUE, nrow = 3, ncol = 2,                   dimnames = list(c(\"R1p\", \"R2p\", \"Ip\"), c(\"Y1\", \"Y2\"))) %>%    setrowtype(\"Products\") %>% setcoltype(\"Industries\") change_final_demand <- new_Y(c(iomats, list(Y_prime = Y_prime))) make_sankey(R = change_final_demand$R_prime,              U = change_final_demand$U_prime,              V = change_final_demand$V_prime,              Y = change_final_demand$Y_prime) %>%    extract2(\"Sankey\")"},{"path":"/articles/new-function-interaction.html","id":"after-recalculating-the-structure-of-the-ecc","dir":"Articles","previous_headings":"Change final demand","what":"After recalculating the structure of the ECC","title":"new_* function interactions","text":"want new_Y() start Sankey energy supplied industry comes R1p, need first recalculate input-output structure ECC based ECC industry uses R1p. .e., need re-calculate iomats object calling new_k_ps() calling new_Y(). , must submit updated description input-output structure ECC new_Y(). following code demonstrates approach. Sankey diagram shows successfully increased demand Y1 ensuring inputs industry come R1p. “trick” recalculate input-output structure ECC two steps.","code":"iomats2 <- calc_io_mats(R = change_input_proportions$R_prime,                          U = change_input_proportions$U_prime,                          U_feed = change_input_proportions$U_feed_prime,                         V = change_input_proportions$V_prime,                          Y = Y, S_units = S_units) change_final_demand2 <- new_Y(c(iomats2, list(Y_prime = Y_prime))) make_sankey(R = change_final_demand2$R_prime,              U = change_final_demand2$U_prime,              V = change_final_demand2$V_prime,              Y = change_final_demand2$Y_prime) %>%    extract2(\"Sankey\")"},{"path":"/articles/new-function-interaction.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"new_* function interactions","text":"new_* function Recca package can called sequentially. interactions among new_* functions can surprising behavior fully understood. vignette provides detailed example using new_k_ps() new_Y() functions. called sequentially without first recalculating input-output structure ECC, call new_Y() based original input-output structure ECC (new_k_ps() called). calc_io_mats() called sequential calls new_k_ps() new_Y() results fed new_Y(), input-output structure ECC calling new_k_ps() used calculations new_Y().","code":""},{"path":"/articles/new-functions.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"new_* functions","text":"Recca R package builds upon input-output (-O) analysis, developed originally analyze money flow economies, analyze energy conversion chains (ECCs). Historically, input-output (-O) analysis used analyze “-” scenarios involving changes production structure economy. common scenario asks “structure intermediate industries (represented \\(\\mathbf{U}\\) \\(\\mathbf{V}\\) matrices) change final demand (represented \\(\\mathbf{Y}\\) matrix) changes?” economic arena, Leontief’s early work answered question via matrix inversion now bears name, “Leontief inverse (\\(\\mathbf{L}\\))” (Leontief 1941). Analysts -O background know famous equation \\(\\mathbf{L} = (\\mathbf{} - \\mathbf{})^{-1}\\). Recca package provides functions perform several “” analyses analyst. function name new_*, * indicates changed matrix portion ECC. functions suffix _ps indicate functions assume perfect substitution (ps) industry inputs throughout ECC. new_* functions return resource (\\(\\mathbf{R}\\)), use (\\(\\mathbf{U}\\)), make (\\(\\mathbf{V}\\)), final demand (\\(\\mathbf{Y}\\)) matrices present conditions given arguments new_* functions. Arguments new changed versions vectors matrices given suffix _prime new_* functions. example, changed version use matrix (\\(\\mathbf{U}\\)) called U_prime. examples follow, ’ll use one ECC UKEnergy2000mats data frame represents portion primary final energy flows UK year 2000. short discussion inputs new_* functions, type analysis described turn.","code":"library(dplyr) library(magrittr) library(matsbyname) library(matsindf) library(Recca) library(tidyr) OurECC <- UKEnergy2000mats %>%    dplyr::filter(Last.stage == \"Final\") %>%    tidyr::spread(key = \"matrix.name\", value = \"matrix\") dplyr::glimpse(OurECC) #> Rows: 1 #> Columns: 12 #> $ Country     <chr> \"GBR\" #> $ Year        <dbl> 2000 #> $ Energy.type <chr> \"E\" #> $ Last.stage  <chr> \"Final\" #> $ R           <list> <<matrix[2 x 2]>> #> $ r_EIOU      <list> <<matrix[12 x 9]>> #> $ S_units     <list> <<matrix[12 x 1]>> #> $ U           <list> <<matrix[12 x 9]>> #> $ U_EIOU      <list> <<matrix[7 x 8]>> #> $ U_feed      <list> <<matrix[9 x 9]>> #> $ V           <list> <<matrix[9 x 10]>> #> $ Y           <list> <<matrix[4 x 2]>>"},{"path":"/articles/new-functions.html","id":"inputs-to-new_-functions","dir":"Articles","previous_headings":"","what":"Inputs to new_* functions","title":"new_* functions","text":"Inputs new_* functions include matrices describe ECC matrices describe input-output structure ECC.","code":""},{"path":"/articles/new-functions.html","id":"matrices-that-describe-the-ecc","dir":"Articles","previous_headings":"Inputs to new_* functions","what":"Matrices that describe the ECC","title":"new_* functions","text":"new_* functions take inputs resource (\\(\\mathbf{R}\\)), use (\\(\\mathbf{U}\\)), make (\\(\\mathbf{V}\\)), final demand (\\(\\mathbf{Y}\\)) matrices describe ECC. look ECC, can draw Sankey diagram. Sankey diagram first row UKEnergyMatsWithR data frame given .","code":"make_sankey(OurECC) %>%    magrittr::extract2(\"Sankey\") %>% # Extracts the \"Sankey\" column   magrittr::extract2(1) # Extracts the first row of the \"Sankey\" column"},{"path":"/articles/new-functions.html","id":"matrices-that-describe-the-input-output-structure-of-the-ecc","dir":"Articles","previous_headings":"Inputs to new_* functions","what":"Matrices that describe the input-output structure of the ECC","title":"new_* functions","text":"new_* function requires basic knowledge -O structure ECCs form named vectors matrices. Thus, first step “-” analysis calculate input-output structure energy conversion chain. calc_io_mats() function simplest way obtain necessary -O structure, appears additional columns appended right OurECC data frame example. (names additional columns given arguments calc_io_mats() function.) -O structure ECC determined (represented \\(\\mathbf{q}\\), \\(\\mathbf{f}\\), \\(\\mathbf{h}\\), \\(\\mathbf{r}\\) \\(\\mathbf{g}\\) vectors \\(\\mathbf{W}\\), \\(\\mathbf{Z}\\), \\(\\mathbf{K}\\), \\(\\mathbf{C}\\), \\(\\mathbf{D}\\), , \\(\\mathbf{}\\), \\(\\mathbf{L_{pxp}}\\), \\(\\mathbf{L_{ixp}}\\) matrices), can use new_* functions ask “” questions.","code":"IO_mats <- OurECC %>%    # Obtain the I-O structure of the ECCs   calc_io_mats() # Note additional columns appended to the data frame. dplyr::glimpse(IO_mats) #> Rows: 1 #> Columns: 32 #> $ Country     <chr> \"GBR\" #> $ Year        <dbl> 2000 #> $ Energy.type <chr> \"E\" #> $ Last.stage  <chr> \"Final\" #> $ R           <list> <<matrix[2 x 2]>> #> $ r_EIOU      <list> <<matrix[12 x 9]>> #> $ S_units     <list> <<matrix[12 x 1]>> #> $ U           <list> <<matrix[12 x 9]>> #> $ U_EIOU      <list> <<matrix[7 x 8]>> #> $ U_feed      <list> <<matrix[9 x 9]>> #> $ V           <list> <<matrix[9 x 10]>> #> $ Y           <list> <<matrix[4 x 2]>> #> $ y           <list> <<matrix[4 x 1]>> #> $ q           <list> <<matrix[12 x 1]>> #> $ f           <list> <<matrix[9 x 1]>> #> $ g           <list> <<matrix[9 x 1]>> #> $ h           <list> <<matrix[2 x 1]>> #> $ r           <list> <<matrix[2 x 1]>> #> $ W           <list> <<matrix[12 x 9]>> #> $ Z           <list> <<matrix[12 x 9]>> #> $ K           <list> <<matrix[12 x 9]>> #> $ C           <list> <<matrix[10 x 9]>> #> $ D           <list> <<matrix[9 x 12]>> #> $ A           <list> <<matrix[12 x 12]>> #> $ O           <list> <<matrix[2 x 2]>> #> $ L_pxp       <list> <<matrix[12 x 12]>> #> $ L_ixp       <list> <<matrix[9 x 12]>> #> $ Z_feed      <list> <<matrix[9 x 9]>> #> $ K_feed      <list> <<matrix[9 x 9]>> #> $ A_feed      <list> <<matrix[9 x 12]>> #> $ L_pxp_feed  <list> <<matrix[12 x 12]>> #> $ L_ixp_feed  <list> <<matrix[9 x 12]>>"},{"path":"/articles/new-functions.html","id":"what-if-final-demand-changes-function-new_y","dir":"Articles","previous_headings":"","what":"What if final demand changes? Function new_Y()","title":"new_* functions","text":"classic -O question “final demand (\\(\\mathbf{Y}\\)) changes?” Recca function : new_Y(). new_Y() function looks upstream ECC determine effects change final demand. demonstrate, ’ll double Residential final demand electricity grid (Elect - Grid) ECC. Now can use new_Y() function estimate ECC larger final demand residential electricity. original Sankey diagram : new Sankey diagram : Output electricity grid clearly larger now . Also, upstream demand natural gas now larger upstream demand crude, whereas original Sankey diagram, demand crude larger demand natural gas.","code":"double <- function(x) {   2*x }  DoubleRes <- IO_mats %>%    mutate(     Y_prime = matsbyname::elementapply_byname(double, a = Y, row = \"Elect [from Grid]\", col = \"Residential\")   ) DoubleRes$Y[[1]] #>                     Residential Transport #> Diesel [from Dist.]           0     14750 #> Elect [from Grid]          6000         0 #> NG [from Dist.]           25000         0 #> Petrol [from Dist.]           0     26000 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" DoubleRes$Y_prime[[1]] #>                     Residential Transport #> Diesel [from Dist.]           0     14750 #> Elect [from Grid]         12000         0 #> NG [from Dist.]           25000         0 #> Petrol [from Dist.]           0     26000 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" make_sankey(OurECC) %>%    extract2(\"Sankey\") %>% # Extracts the \"Sankey\" column   extract2(1)            # Extracts the first row of the \"Sankey\" column DoubleRes <- DoubleRes %>%    new_Y() make_sankey(DoubleRes, R = \"R_prime\", U = \"U_prime\", V = \"V_prime\", Y = \"Y_prime\") %>%    extract2(\"Sankey\") %>%    extract2(1)"},{"path":"/articles/new-functions.html","id":"what-if-resources-change-function-new_r_ps","dir":"Articles","previous_headings":"","what":"What if resources change? Function new_R_ps()","title":"new_* functions","text":"new_Y() estimates upstream effects change final demand. want understand downstream effects change resource availability? function new_R_ps() supplies answer. new_R_ps() takes input input-output structure ECC efficiency every intermediate industry. discussing resource matrix resource vectors, new_R_ps() function demonstrated.","code":""},{"path":"/articles/new-functions.html","id":"resource-matrices-and-vectors","dir":"Articles","previous_headings":"What if resources change? Function new_R_ps()","what":"Resource matrices and vectors","title":"new_* functions","text":"rate resource extraction given \\(\\mathbf{R}\\) matrix \\(\\mathbf{r}\\) vector. resource matrix (\\(\\mathbf{R}\\)) Industry\\(\\times\\)Product. industries usually named Resources - <Product>, <Product> name Product produced industry. (clean_byname() removes 0 rows columns clarity.) resource vector (\\(\\mathbf{r}\\)) Product column vector containing Products resources.","code":"OurECC$R[[1]] %>%    clean_byname() #>                      Crude    NG #> Resources [of Crude] 50000     0 #> Resources [of NG]        0 43000 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" rvecs <- OurECC %>%    transmute(     r = clean_byname(R) %>%        colsums_byname() %>%        transpose_byname()   ) rvecs$r[[1]] #>       Industry #> Crude    50000 #> NG       43000 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\""},{"path":"/articles/new-functions.html","id":"industry-efficiencies-and-a-new-resource-matrix","dir":"Articles","previous_headings":"What if resources change? Function new_R_ps()","what":"Industry efficiencies and a new resource matrix","title":"new_* functions","text":"baseline \\(\\mathbf{R}\\) matrix shown . Let’s say want estimate effect 50 % reduction production rate crude oil. , cut Resources - Crude half. execute reduction, ’ll use matsbyname::elementapply_byname() function. Now use new_R() function estimate changes ECC. first, need calculate efficiency sectors ECC using calc_eta_i() function. re-calculating HalfCrude ECC (specifically, calculating U_prime, V_prime, Y_prime), can visualize effect lower crude oil availability modified Sankey diagram. First, original Sankey diagram. modified Sankey diagram showing much smaller Resources - Crude extraction rate. Sankey diagrams clearly show reducing availability crude oil (Resources - crude) means less Transport final demand can satisfied. Note ECCs complete energy balance.","code":"half <- function(x){   x/2 } HalfCrude <- OurECC %>%    # Obtain the I-O structure of the ECCs   calc_io_mats(direction = \"downstream\") %>%    mutate(     R_prime = elementapply_byname(half, a = R, row = \"Resources [of Crude]\", col = \"Crude\")   ) HalfCrude$R_prime[[1]] %>% clean_byname() #>                      Crude    NG #> Resources [of Crude] 25000     0 #> Resources [of NG]        0 43000 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" HalfCrude <- HalfCrude %>%    calc_eta_i() %>%    new_R_ps() glimpse(HalfCrude) #> Rows: 1 #> Columns: 35 #> $ Country      <chr> \"GBR\" #> $ Year         <dbl> 2000 #> $ Energy.type  <chr> \"E\" #> $ Last.stage   <chr> \"Final\" #> $ R            <list> <<matrix[2 x 2]>> #> $ r_EIOU       <list> <<matrix[12 x 9]>> #> $ S_units      <list> <<matrix[12 x 1]>> #> $ U            <list> <<matrix[12 x 9]>> #> $ U_EIOU       <list> <<matrix[7 x 8]>> #> $ U_feed       <list> <<matrix[9 x 9]>> #> $ V            <list> <<matrix[9 x 10]>> #> $ Y            <list> <<matrix[4 x 2]>> #> $ y            <list> <<matrix[4 x 1]>> #> $ q            <list> <<matrix[12 x 1]>> #> $ f            <list> <<matrix[9 x 1]>> #> $ g            <list> <<matrix[9 x 1]>> #> $ h            <list> <<matrix[2 x 1]>> #> $ r            <list> <<matrix[2 x 1]>> #> $ W            <list> <<matrix[12 x 9]>> #> $ Z_s          <list> <<matrix[10 x 9]>> #> $ C_s          <list> <<matrix[12 x 9]>> #> $ D_s          <list> <<matrix[9 x 12]>> #> $ D_feed_s     <list> <<matrix[9 x 12]>> #> $ O_s          <list> <<matrix[12 x 2]>> #> $ B            <list> <<matrix[10 x 12]>> #> $ G_pxp        <list> <<matrix[12 x 12]>> #> $ G_ixp        <list> <<matrix[9 x 12]>> #> $ R_prime      <list> <<matrix[2 x 2]>> #> $ eta_i        <list> <<matrix[9 x 1]>> #> $ U_prime      <list> <<matrix[12 x 9]>> #> $ U_feed_prime <list> <<matrix[12 x 9]>> #> $ U_EIOU_prime <list> <<matrix[12 x 9]>> #> $ r_EIOU_prime <list> <<matrix[12 x 9]>> #> $ V_prime      <list> <<matrix[9 x 10]>> #> $ Y_prime      <list> <<matrix[12 x 2]>> make_sankey(OurECC) %>%    extract2(\"Sankey\") %>% # Extracts the \"Sankey\" column   extract2(1) # Extracts the first row of the \"Sankey\" column make_sankey(HalfCrude, R = \"R_prime\", U = \"U_prime\", V = \"V_prime\", Y = \"Y_prime\") %>%    extract2(\"Sankey\") %>% # Extracts the \"Sankey\" column   extract2(1) # Extracts the first row of the \"Sankey\" column OurECC %>%    verify_SUT_energy_balance_with_units() %>%    select(Country, Year, Energy.type, Last.stage,           .SUT_prod_energy_balance, .SUT_ind_energy_balance) %>%    glimpse() #> Rows: 1 #> Columns: 6 #> $ Country                  <chr> \"GBR\" #> $ Year                     <dbl> 2000 #> $ Energy.type              <chr> \"E\" #> $ Last.stage               <chr> \"Final\" #> $ .SUT_prod_energy_balance <lgl> TRUE #> $ .SUT_ind_energy_balance  <lgl> TRUE HalfCrude %>%    mutate(     R_plus_V_prime = sum_byname(R_prime, V_prime)   ) %>%    verify_SUT_energy_balance(R = \"R_prime\", U = \"U_prime\", V = \"V_prime\",                              Y = \"Y_prime\") %>%    select(Country, Year, Energy.type, Last.stage,          .SUT_energy_balance) %>%    glimpse() #> Rows: 1 #> Columns: 5 #> $ Country             <chr> \"GBR\" #> $ Year                <dbl> 2000 #> $ Energy.type         <chr> \"E\" #> $ Last.stage          <chr> \"Final\" #> $ .SUT_energy_balance <lgl> TRUE"},{"path":"/articles/new-functions.html","id":"what-if-perfectly-substitutable-inputs-to-an-intermediate-industry-change-function-new_k_ps","dir":"Articles","previous_headings":"","what":"What if perfectly-substitutable inputs to an intermediate industry change? Function new_k_ps()","title":"new_* functions","text":"new_Y() estimates upstream effects change final demand. new_R_ps() estimates downstream effects change resource availability. want estimate effects change inputs intermediate industry? inputs perfectly substitutable, new_k_ps() function provides answer. demonstrate new_k_ps(), need ECC least two reasonably-sized inputs. Unfortunately, OurECC doesn’t necessary characteristics, create new ECC . ECC two resource industries (R1 R2), one intermediate industry (), two final demand sectors (Y1 Y2). R1 industry makes product R1p. R2 industry makes product R2p. Industry makes product Ip. Product Ip consumed final demand sectors Y1 Y2. use (\\(\\mathbf{U}\\)), make (\\(\\mathbf{V}\\)), final demand (\\(\\mathbf{Y}\\)), unit summation (\\(\\mathbf{S}_{units}\\)) matrices given . Sankey diagram simple ECC given . can change proportion inputs industry using new_k_ps(). , must first calculate input-output structure ECC using calc_io_mats() function. , call new_k_ps() function new k vector indicates industry now uses 75/25 mixture R1 R2 instead 50/50 split R1 R2. response different demands industry , rate resource extraction R1 need grow, rate resource extraction supply R2 need shrink. additional upstream industries, also change response new ratio inputs industry .","code":"U <- matrix(c(0, 0, 10,               0, 0, 10,               0, 0,  0),             byrow = TRUE, nrow = 3, ncol = 3,             dimnames = list(c(\"R1p\", \"R2p\", \"Ip\"), c(\"R1\", \"R2\", \"I\"))) %>%    setrowtype(\"Products\") %>% setcoltype(\"Industries\")  # There is no EIOU, so U_feed is the same as U U_feed <- U  R_plus_V <- matrix(c(10,  0, 0,                0, 10, 0,                 0,  0, 4),              byrow = TRUE, nrow = 3, ncol = 3,              dimnames = list(c(\"R1\", \"R2\", \"I\"), c(\"R1p\", \"R2p\", \"Ip\"))) %>%    setrowtype(\"Industries\") %>% setcoltype(\"Products\")  Y <- matrix(c(0, 0,               0, 0,                2, 2),             byrow = TRUE, nrow = 3, ncol = 2,             dimnames = list(c(\"R1p\", \"R2p\", \"Ip\"), c(\"Y1\", \"Y2\"))) %>%    setrowtype(\"Products\") %>% setcoltype(\"Industries\")  RV <- separate_RV(U = U, R_plus_V = R_plus_V) R <- RV$R V <- RV$V  S_units <- matrix(c(1,                      1,                      1),                    byrow = TRUE, nrow = 3, ncol = 1,                   dimnames = list(c(\"R1p\", \"R2p\", \"Ip\"), c(\"quad\"))) %>%    setrowtype(\"Products\") %>% setcoltype(\"Units\") make_sankey(R = R, U = U, V = V, Y = Y) %>%    extract2(\"Sankey\") simple_iomats <- calc_io_mats(R = R, U = U, U_feed = U_feed, V = V, Y = Y, S_units = S_units) k_prime <- matrix(c(0.75,                     0.25),                    byrow = TRUE, nrow = 2, ncol = 1,                   dimnames = list(c(\"R1p\", \"R2p\"), c(\"I\"))) %>%    setrowtype(\"Products\") %>% setcoltype(\"Industries\") change_input_proportions <- new_k_ps(c(simple_iomats,                                         list(R = R, U = U, V = V, Y = Y,                                              S_units = S_units,                                              k_prime = k_prime))) make_sankey(R = change_input_proportions$R_prime,              U = change_input_proportions$U_prime,              V = change_input_proportions$V_prime,              Y = Y) %>%    extract2(\"Sankey\")"},{"path":"/articles/new-functions.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"new_* functions","text":"Recca three functions allow analyst estimate effect changes ECC. new_Y() estimates changes upstream final demand. new_R_ps() estimates changes downstream resource extraction. new_k_ps() estimates changes upstream inputs intermediate industry. first functions (new_Y()) demonstrated Heun et al. [-@Heun:2018]. second third functions (new_R_ps() new_k_ps()) shown first time.","code":""},{"path":[]},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Matthew Heun. Author, maintainer. Emmanuel Aramendia. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Matthew Kuperus Heun, Emmanuel Aramendia (2023). Recca: R Energy Conversion Chain Analysis. R package version 0.1.51. https://doi.org/10.5281/zenodo.5226085","code":"@Manual{,   title = {Recca: R Energy Conversion Chain Analysis},   author = {Matthew Kuperus Heun and Emmanuel Aramendia},   year = {2023},   note = {R package version 0.1.51},   url = {https://doi.org/10.5281/zenodo.5226085}, }"},{"path":"/index.html","id":"recca","dir":"","previous_headings":"","what":"R Energy Conversion Chain Analysis","title":"R Energy Conversion Chain Analysis","text":"R package Recca provides R Energy Conversion Chain Analysis.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"R Energy Conversion Chain Analysis","text":"can install Recca github :","code":"# install devtools if not already installed # install.packages(\"devtools\") devtools::install_github(\"MatthewHeun/Recca\") # To build vignettes locally, use devtools::install_github(\"MatthewHeun/Recca\", build_vignettes = TRUE)"},{"path":"/index.html","id":"history","dir":"","previous_headings":"","what":"History","title":"R Energy Conversion Chain Analysis","text":"functions package used paper Heun et al. (2018).","code":""},{"path":"/index.html","id":"more-information","dir":"","previous_headings":"","what":"More Information","title":"R Energy Conversion Chain Analysis","text":"Find information, including vignettes function documentation, https://MatthewHeun.github.io/Recca/.","code":""},{"path":[]},{"path":"/reference/PerfectSubmats.html","id":null,"dir":"Reference","previous_headings":"","what":"Example energy conversion chain to demonstrate perfect substitution — PerfectSubmats","title":"Example energy conversion chain to demonstrate perfect substitution — PerfectSubmats","text":"dataset containing example energy conversion chain purpose demonstrating changes industry inputs inputs perfect substitutes.","code":""},{"path":"/reference/PerfectSubmats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example energy conversion chain to demonstrate perfect substitution — PerfectSubmats","text":"","code":"PerfectSubmats"},{"path":"/reference/PerfectSubmats.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example energy conversion chain to demonstrate perfect substitution — PerfectSubmats","text":"data frame 20 rows 10 variables: Country country, (Example, one country) Year year, 2000 (one year example) Energy.type E.ktoe (energy) X.ktoe (exergy) Last.stage tells final stage energy conversion chain: services entry matrix.name gives name matrix matrix gives use (U), make (V), final demand (Y), r_EIOU, S_units matrices","code":""},{"path":"/reference/PerfectSubmats.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example energy conversion chain to demonstrate perfect substitution — PerfectSubmats","text":"PerfectSubmats gives use (U), make (V), final demand (Y) matrices single column data frame. data matsindf format.","code":""},{"path":"/reference/PerfectSubtidy.html","id":null,"dir":"Reference","previous_headings":"","what":"Example energy conversion chain to demonstrate perfect substitution — PerfectSubtidy","title":"Example energy conversion chain to demonstrate perfect substitution — PerfectSubtidy","text":"dataset containing example energy conversion chain purpose demonstrating changes industry inputs inputs perfect substitutes.","code":""},{"path":"/reference/PerfectSubtidy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example energy conversion chain to demonstrate perfect substitution — PerfectSubtidy","text":"","code":"PerfectSubtidy"},{"path":"/reference/PerfectSubtidy.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example energy conversion chain to demonstrate perfect substitution — PerfectSubtidy","text":"data frame 20 rows 10 variables: Country country, (Example, one country) Year year, 2000 (one year example) Ledger.side Supply Consumption Flow.aggregation.point tells row aggregated Energy.type E.ktoe (energy) X.ktoe (exergy) Last.stage tells final stage energy conversion chain: services entry Flow Industry Sector involved flow Product energy product involved flow E.dot value energy, exergy, service flow ktoe Unit unit quantity expressed","code":""},{"path":"/reference/PerfectSubtidy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example energy conversion chain to demonstrate perfect substitution — PerfectSubtidy","text":"PerfectSubtidy gives non-zero entry PerfectSubmats single column data frame. data tidy format.","code":""},{"path":"/reference/S_units_from_tidy.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract an S_units matrix from a tidy data frame — S_units_from_tidy","title":"Extract an S_units matrix from a tidy data frame — S_units_from_tidy","text":".tidydf grouped needed.","code":""},{"path":"/reference/S_units_from_tidy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract an S_units matrix from a tidy data frame — S_units_from_tidy","text":"","code":"S_units_from_tidy(   .tidydf,   Product = \"Product\",   Unit = \"Unit\",   S_units = \"S_units\" )"},{"path":"/reference/S_units_from_tidy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract an S_units matrix from a tidy data frame — S_units_from_tidy","text":".tidydf data frame S_units matrix formed Product name Product column .tidydf. Default \"Product\". Unit name Unit column .tidydf. Default \"Unit\". S_units name S_units column added .tidydf. Default \"S_unit\".","code":""},{"path":"/reference/S_units_from_tidy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract an S_units matrix from a tidy data frame — S_units_from_tidy","text":"data frame containing grouping variables new S_unit column","code":""},{"path":"/reference/S_units_from_tidy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract an S_units matrix from a tidy data frame — S_units_from_tidy","text":"","code":"library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following object is masked from ‘package:testthat’: #>  #>     matches #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(matsindf) library(Recca) UKEnergy2000tidy %>%   group_by(\"Country\", \"Year\", \"Energy.type\", \"Last.stage\") %>%   S_units_from_tidy() #>   \"Country\" \"Year\" \"Energy.type\" \"Last.stage\" #> 1   Country   Year   Energy.type   Last.stage #>                                                                                                                                                                                                                                                                                                      S_units #> 1 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0"},{"path":"/reference/UKEnergy2000mats.html","id":null,"dir":"Reference","previous_headings":"","what":"Energy consumption in the UK in 2000 — UKEnergy2000mats","title":"Energy consumption in the UK in 2000 — UKEnergy2000mats","text":"dataset containing approximations energy flows UK year 2000. data first appeared example Figures 3, 4, 6, 7, 10, 11, B.1, B.2 M.K. Heun, . Owen, P. E. Brockway. physical supply-use table framework energy analysis energy conversion chain. Applied Energy, 226:1134–1162, Sep 2018.","code":""},{"path":"/reference/UKEnergy2000mats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Energy consumption in the UK in 2000 — UKEnergy2000mats","text":"","code":"UKEnergy2000mats"},{"path":"/reference/UKEnergy2000mats.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Energy consumption in the UK in 2000 — UKEnergy2000mats","text":"data frame 12 rows 6 variables: Country country, GB (Great Britain, one country) Year year, 2000 (one year) Energy.type E.ktoe (energy) X.ktoe (exergy) Last.stage tells final stage energy conversion chain: final, useful, services matrix.name gives name matrix matrix gives use (U), make (V), final demand (Y), r_EIOU, S_units matrices","code":""},{"path":"/reference/UKEnergy2000mats.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Energy consumption in the UK in 2000 — UKEnergy2000mats","text":"doi:10.1016/j.apenergy.2018.05.109","code":""},{"path":"/reference/UKEnergy2000mats.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Energy consumption in the UK in 2000 — UKEnergy2000mats","text":"UKEnergy2000mats gives use (U), make (V), final demand (Y) matrices associated UKEnergy2000tidy. data matsindf format.","code":""},{"path":"/reference/UKEnergy2000tidy.html","id":null,"dir":"Reference","previous_headings":"","what":"Energy consumption in the UK in 2000 — UKEnergy2000tidy","title":"Energy consumption in the UK in 2000 — UKEnergy2000tidy","text":"dataset containing approximations energy flows UK year 2000. data first appeared example Figures 3, 4, 6, 7, 10, 11, B.1, B.2 M.K. Heun, . Owen, P. E. Brockway. physical supply-use table framework energy analysis energy conversion chain. Applied Energy, 226:1134–1162, Sep 2018.","code":""},{"path":"/reference/UKEnergy2000tidy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Energy consumption in the UK in 2000 — UKEnergy2000tidy","text":"","code":"UKEnergy2000tidy"},{"path":"/reference/UKEnergy2000tidy.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Energy consumption in the UK in 2000 — UKEnergy2000tidy","text":"data frame 186 rows 9 variables: Country country, GB (Great Britain, one country) Year year, 2000 (one year) Ledger.side Supply Consumption Flow.aggregation.point tells row aggregated Energy.type E.ktoe (energy) X.ktoe (exergy) Last.stage tells final stage energy conversion chain: final, useful, services Flow Industry Sector involved flow Product energy product involved flow E.dot value energy, exergy, service flow ktoe Unit unit quantity expressed","code":""},{"path":"/reference/UKEnergy2000tidy.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Energy consumption in the UK in 2000 — UKEnergy2000tidy","text":"doi:10.1016/j.apenergy.2018.05.109","code":""},{"path":"/reference/UKEnergy2000tidy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Energy consumption in the UK in 2000 — UKEnergy2000tidy","text":"UKEnergy2000tidy gives non-zero entry UKEnergy2000mats single column data frame. data tidy format.","code":""},{"path":"/reference/add_edge_ids.html","id":null,"dir":"Reference","previous_headings":"","what":"Add edge ID numbers to an edge list — add_edge_ids","title":"Add edge ID numbers to an edge list — add_edge_ids","text":"edges edge list can ID numbers. functions adds column edge ID numbers.","code":""},{"path":"/reference/add_edge_ids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add edge ID numbers to an edge list — add_edge_ids","text":"","code":"add_edge_ids(edge_list, edge_id = \"edge_id\")"},{"path":"/reference/add_edge_ids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add edge ID numbers to an edge list — add_edge_ids","text":"edge_list edge list edge ID numbers added edge_id name edge ID column outgoing edge list. (Default \"edge_id\".)","code":""},{"path":"/reference/add_edge_ids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add edge ID numbers to an edge list — add_edge_ids","text":"edge_list added column containing edge ID numbers.","code":""},{"path":"/reference/add_edge_ids.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add edge ID numbers to an edge list — add_edge_ids","text":"","code":"library(tidyr) #>  #> Attaching package: ‘tidyr’ #> The following object is masked from ‘package:testthat’: #>  #>     matches library(matsbyname) sutmats <- UKEnergy2000mats %>% spread(key = matrix.name, value = matrix) # Suppress adding edge IDs elDF <- edge_list(sutmats, edge_id = NULL)$`Edge list`[[1]] add_node_ids(elDF) #>                    From                To Value             Product #> 1  Resources [of Crude]        Oil fields 50000               Crude #> 2           Crude dist.       Crude dist.   500  Crude [from Dist.] #> 3           Crude dist.    Oil refineries 47000  Crude [from Dist.] #> 4            Oil fields       Crude dist. 47500 Crude [from Fields] #> 5            Oil fields        Oil fields  2500 Crude [from Fields] #> 6        Oil refineries      Diesel dist. 15500              Diesel #> 7        Oil refineries    Oil refineries  5000              Diesel #> 8          Diesel dist.       Crude dist.    25 Diesel [from Dist.] #> 9          Diesel dist.      Diesel dist.   350 Diesel [from Dist.] #> 10         Diesel dist. Gas wells & proc.    50 Diesel [from Dist.] #> 11         Diesel dist.          NG dist.    25 Diesel [from Dist.] #> 12         Diesel dist.        Oil fields    50 Diesel [from Dist.] #> 13         Diesel dist.      Petrol dist.   250 Diesel [from Dist.] #> 14         Diesel dist.         Transport 14750 Diesel [from Dist.] #> 15         Power plants       Elect. grid  6400               Elect #> 16          Elect. grid       Crude dist.    25   Elect [from Grid] #> 17          Elect. grid Gas wells & proc.    25   Elect [from Grid] #> 18          Elect. grid          NG dist.    25   Elect [from Grid] #> 19          Elect. grid        Oil fields    25   Elect [from Grid] #> 20          Elect. grid    Oil refineries    75   Elect [from Grid] #> 21          Elect. grid      Power plants   100   Elect [from Grid] #> 22          Elect. grid       Residential  6000   Elect [from Grid] #> 23    Resources [of NG] Gas wells & proc. 43000                  NG #> 24             NG dist.      Power plants 16000     NG [from Dist.] #> 25             NG dist.       Residential 25000     NG [from Dist.] #> 26    Gas wells & proc. Gas wells & proc.  2000     NG [from Wells] #> 27    Gas wells & proc.          NG dist. 41000     NG [from Wells] #> 28       Oil refineries      Petrol dist. 26500              Petrol #> 29         Petrol dist.      Petrol dist.   500 Petrol [from Dist.] #> 30         Petrol dist.         Transport 26000 Petrol [from Dist.] #> 31          Crude dist.             Waste   550               Waste #> 32         Diesel dist.             Waste   350               Waste #> 33          Elect. grid             Waste   125               Waste #> 34    Gas wells & proc.             Waste  2075               Waste #> 35             NG dist.             Waste    50               Waste #> 36           Oil fields             Waste  2575               Waste #> 37       Oil refineries             Waste  5075               Waste #> 38         Petrol dist.             Waste   750               Waste #> 39         Power plants             Waste  9700               Waste #>    From_node_id.x To_node_id.x From_node_id.y To_node_id.y #> 1               0            2              0            2 #> 2               1            1              1            1 #> 3               1            3              1            3 #> 4               2            1              2            1 #> 5               2            2              2            2 #> 6               3            4              3            4 #> 7               3            3              3            3 #> 8               4            1              4            1 #> 9               4            4              4            4 #> 10              4            9              4            9 #> 11              4            8              4            8 #> 12              4            2              4            2 #> 13              4           10              4           10 #> 14              4           11              4           11 #> 15              5            6              5            6 #> 16              6            1              6            1 #> 17              6            9              6            9 #> 18              6            8              6            8 #> 19              6            2              6            2 #> 20              6            3              6            3 #> 21              6            5              6            5 #> 22              6           12              6           12 #> 23              7            9              7            9 #> 24              8            5              8            5 #> 25              8           12              8           12 #> 26              9            9              9            9 #> 27              9            8              9            8 #> 28              3           10              3           10 #> 29             10           10             10           10 #> 30             10           11             10           11 #> 31              1           13              1           13 #> 32              4           13              4           13 #> 33              6           13              6           13 #> 34              9           13              9           13 #> 35              8           13              8           13 #> 36              2           13              2           13 #> 37              3           13              3           13 #> 38             10           13             10           13 #> 39              5           13              5           13"},{"path":"/reference/add_node_ids.html","id":null,"dir":"Reference","previous_headings":"","what":"Add node ID numbers to an edge list — add_node_ids","title":"Add node ID numbers to an edge list — add_node_ids","text":"Edge lists can contain identification numbers (integers) node. row edge list data frame contains \"\" node \"\" node, two columns node IDs added, one \"\" one \"\".","code":""},{"path":"/reference/add_node_ids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add node ID numbers to an edge list — add_node_ids","text":"","code":"add_node_ids(   edge_list,   from = \"From\",   to = \"To\",   node_id = \"node_id\",   first_node = 0 )"},{"path":"/reference/add_node_ids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add node ID numbers to an edge list — add_node_ids","text":"edge_list edge list node ID numbers added name column containing source nodes. (Default \"\".) name column containing destination nodes. (Default \"\".) node_id root column name node IDs. (Default \"node_ID\".)  See details. first_node ID number first node. (Default 0.)","code":""},{"path":"/reference/add_node_ids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add node ID numbers to an edge list — add_node_ids","text":"edge_list two additional columns containing node ID numbers.","code":""},{"path":"/reference/add_node_ids.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add node ID numbers to an edge list — add_node_ids","text":"column names \"\" \"\" nodes created paste-ing value arguments value node_id argument.","code":""},{"path":"/reference/add_node_ids.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add node ID numbers to an edge list — add_node_ids","text":"","code":"library(matsbyname) library(tidyr) sutmats <- UKEnergy2000mats %>% spread(key = matrix.name, value = matrix) # Suppress adding node IDs elDF <- edge_list(sutmats, node_id = NULL)$`Edge list`[[1]] add_node_ids(elDF) #>                    From                To Value             Product edge_id #> 1  Resources [of Crude]        Oil fields 50000               Crude       1 #> 2           Crude dist.       Crude dist.   500  Crude [from Dist.]       2 #> 3           Crude dist.    Oil refineries 47000  Crude [from Dist.]       3 #> 4            Oil fields       Crude dist. 47500 Crude [from Fields]       4 #> 5            Oil fields        Oil fields  2500 Crude [from Fields]       5 #> 6        Oil refineries      Diesel dist. 15500              Diesel       6 #> 7        Oil refineries    Oil refineries  5000              Diesel       7 #> 8          Diesel dist.       Crude dist.    25 Diesel [from Dist.]       8 #> 9          Diesel dist.      Diesel dist.   350 Diesel [from Dist.]       9 #> 10         Diesel dist. Gas wells & proc.    50 Diesel [from Dist.]      10 #> 11         Diesel dist.          NG dist.    25 Diesel [from Dist.]      11 #> 12         Diesel dist.        Oil fields    50 Diesel [from Dist.]      12 #> 13         Diesel dist.      Petrol dist.   250 Diesel [from Dist.]      13 #> 14         Diesel dist.         Transport 14750 Diesel [from Dist.]      14 #> 15         Power plants       Elect. grid  6400               Elect      15 #> 16          Elect. grid       Crude dist.    25   Elect [from Grid]      16 #> 17          Elect. grid Gas wells & proc.    25   Elect [from Grid]      17 #> 18          Elect. grid          NG dist.    25   Elect [from Grid]      18 #> 19          Elect. grid        Oil fields    25   Elect [from Grid]      19 #> 20          Elect. grid    Oil refineries    75   Elect [from Grid]      20 #> 21          Elect. grid      Power plants   100   Elect [from Grid]      21 #> 22          Elect. grid       Residential  6000   Elect [from Grid]      22 #> 23    Resources [of NG] Gas wells & proc. 43000                  NG      23 #> 24             NG dist.      Power plants 16000     NG [from Dist.]      24 #> 25             NG dist.       Residential 25000     NG [from Dist.]      25 #> 26    Gas wells & proc. Gas wells & proc.  2000     NG [from Wells]      26 #> 27    Gas wells & proc.          NG dist. 41000     NG [from Wells]      27 #> 28       Oil refineries      Petrol dist. 26500              Petrol      28 #> 29         Petrol dist.      Petrol dist.   500 Petrol [from Dist.]      29 #> 30         Petrol dist.         Transport 26000 Petrol [from Dist.]      30 #> 31          Crude dist.             Waste   550               Waste      31 #> 32         Diesel dist.             Waste   350               Waste      32 #> 33          Elect. grid             Waste   125               Waste      33 #> 34    Gas wells & proc.             Waste  2075               Waste      34 #> 35             NG dist.             Waste    50               Waste      35 #> 36           Oil fields             Waste  2575               Waste      36 #> 37       Oil refineries             Waste  5075               Waste      37 #> 38         Petrol dist.             Waste   750               Waste      38 #> 39         Power plants             Waste  9700               Waste      39 #>    From_node_id To_node_id #> 1             0          2 #> 2             1          1 #> 3             1          3 #> 4             2          1 #> 5             2          2 #> 6             3          4 #> 7             3          3 #> 8             4          1 #> 9             4          4 #> 10            4          9 #> 11            4          8 #> 12            4          2 #> 13            4         10 #> 14            4         11 #> 15            5          6 #> 16            6          1 #> 17            6          9 #> 18            6          8 #> 19            6          2 #> 20            6          3 #> 21            6          5 #> 22            6         12 #> 23            7          9 #> 24            8          5 #> 25            8         12 #> 26            9          9 #> 27            9          8 #> 28            3         10 #> 29           10         10 #> 30           10         11 #> 31            1         13 #> 32            4         13 #> 33            6         13 #> 34            9         13 #> 35            8         13 #> 36            2         13 #> 37            3         13 #> 38           10         13 #> 39            5         13"},{"path":"/reference/aggregate_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate data frame column names — aggregate_cols","title":"Aggregate data frame column names — aggregate_cols","text":"string list containing named names columns aggregate data frames. Items list provide default values column name function arguments aggregation functions throughout Recca package.","code":""},{"path":"/reference/aggregate_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate data frame column names — aggregate_cols","text":"","code":"aggregate_cols"},{"path":"/reference/aggregate_cols.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Aggregate data frame column names — aggregate_cols","text":"string list 19 entries. aggregate_primary name column wide--matrices data frame containing aggregates primary energy. net_aggregate_primary name column wide--matrices data frame containing aggregates net primary energy. Net gross aggregates identical primary stage. gross_aggregate_primary name column wide--matrices data frame containing aggregates gross primary energy. Net gross aggregates identical primary stage. aggregate_final name column wide--matrices data frame containing aggregates final energy. net_aggregate_final name column wide--matrices data frame containing aggregates net final energy, including energy industry use. gross_aggregate_final name column wide--matrices data frame containing aggregates gross final energy, including energy industry use. aggregate_useful name column wide--matrices data frame containing aggregates useful energy. net_aggregate_useful name column wide--matrices data frame containing aggregates net useful energy, including energy industry use. gross_aggregate_useful name column wide--matrices data frame containing aggregates gross useful energy, including energy industry use. aggregate_services name column wide--matrices data frame containing aggregates energy services. net_aggregate_services name column wide--matrices data frame containing aggregates net energy services, including energy industry use. gross_aggregate_services name column wide--matrices data frame containing aggregates gross energy services, including energy industry use. aggregate_demand name column wide--matrices data frame containing aggregates final demand energy (including energy industry use), regardless whether last stage final, useful, services. net_aggregate_demand name column wide--matrices data frame containing aggregates net final demand energy (excluding energy industry use), regardless whether last stage final, useful, services. gross_aggregate_demand name column wide--matrices data frame containing aggregates gross final demand energy (including energy industry use), regardless whether last stage final, useful, services. region name column wide--matrices data frame containing regions. aggregated_suffix suffix column names containing aggregated matrices. product_sector name column containing names products, industries, sectors. Default \"Product.Industry.Sector\". chop_df name column containing nested data frame chopped energy conversion chains. Default \"Chopped.ECCs\".","code":""},{"path":"/reference/aggregate_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate data frame column names — aggregate_cols","text":"","code":"aggregate_cols #> $aggregate_primary #> [1] \"EX.p\" #>  #> $net_aggregate_primary #> [1] \"EX.p_net\" #>  #> $gross_aggregate_primary #> [1] \"EX.p_gross\" #>  #> $aggregate_final #> [1] \"EX.f\" #>  #> $net_aggregate_final #> [1] \"EX.f_net\" #>  #> $gross_aggregate_final #> [1] \"EX.f_gross\" #>  #> $aggregate_useful #> [1] \"EX.u\" #>  #> $net_aggregate_useful #> [1] \"EX.u_net\" #>  #> $gross_aggregate_useful #> [1] \"EX.u_gross\" #>  #> $aggregate_services #> [1] \"EX.s\" #>  #> $net_aggregate_services #> [1] \"EX.s_net\" #>  #> $gross_aggregate_services #> [1] \"EX.s_gross\" #>  #> $aggregate_demand #> [1] \"EX.fd\" #>  #> $net_aggregate_demand #> [1] \"EX.fd_net\" #>  #> $gross_aggregate_demand #> [1] \"EX.fd_gross\" #>  #> $region #> [1] \"Region\" #>  #> $aggregated_suffix #> [1] \"_aggregated\" #>  #> $product_sector #> [1] \"Product.Industry.Sector\" #>  #> $chop_df #> [1] \"Chopped.ECCs\" #>"},{"path":"/reference/all_stages.html","id":null,"dir":"Reference","previous_headings":"","what":"All energy conversion chain stages — all_stages","title":"All energy conversion chain stages — all_stages","text":"string list containing options stages energy conversion chain analysis.","code":""},{"path":"/reference/all_stages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"All energy conversion chain stages — all_stages","text":"","code":"all_stages"},{"path":"/reference/all_stages.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"All energy conversion chain stages — all_stages","text":"string list 5 primary string identifier Primary stage energy conversion chain. final string identifier Final stage energy conversion chain. useful string identifier Useful stage energy conversion chain. services string identifier Services stage energy conversion chain. last_stage_sep string separates last-stage identifiers variable names.","code":""},{"path":"/reference/all_stages.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"All energy conversion chain stages — all_stages","text":"","code":"all_stages #> $primary #> [1] \"Primary\" #>  #> $final #> [1] \"Final\" #>  #> $useful #> [1] \"Useful\" #>  #> $services #> [1] \"Services\" #>  #> $last_stage_sep #> [1] \"___ls\" #>"},{"path":"/reference/alloc_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Columns in a data frame that contains final-to-useful allocations — alloc_cols","title":"Columns in a data frame that contains final-to-useful allocations — alloc_cols","text":"string list containing named names columns PSUT data frames. Items list provide default values column name function arguments throughout Recca package.","code":""},{"path":"/reference/alloc_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Columns in a data frame that contains final-to-useful allocations — alloc_cols","text":"","code":"alloc_cols"},{"path":"/reference/alloc_cols.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Columns in a data frame that contains final-to-useful allocations — alloc_cols","text":"string list 2 entries. C_Y name column wide--matrices data frame containing allocations final--useful machines used final demand. \"C_Y\" C_eiou name column wide--matrices data frame containing allocations final--useful machines used final demand. \"C_EIOU\"","code":""},{"path":"/reference/alloc_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Columns in a data frame that contains final-to-useful allocations — alloc_cols","text":"","code":"alloc_cols #> $C_Y #> [1] \"C_Y\" #>  #> $C_eiou #> [1] \"C_EIOU\" #>"},{"path":"/reference/any_start_with.html","id":null,"dir":"Reference","previous_headings":"","what":"Tell if any of a vector of strings starts with another string — any_start_with","title":"Tell if any of a vector of strings starts with another string — any_start_with","text":"function returns TRUE strings x starts string target FALSE otherwise.","code":""},{"path":"/reference/any_start_with.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tell if any of a vector of strings starts with another string — any_start_with","text":"","code":"any_start_with(x, target)"},{"path":"/reference/any_start_with.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tell if any of a vector of strings starts with another string — any_start_with","text":"x vector list strings target string (vector list strings)","code":""},{"path":"/reference/any_start_with.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tell if any of a vector of strings starts with another string — any_start_with","text":"TRUE x starts target, FALSE otherwise. target vector list, return value length target contains result applying test item target.","code":""},{"path":"/reference/any_start_with.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tell if any of a vector of strings starts with another string — any_start_with","text":"function vectorized. target vector list strings, return value length target contains result applying test (x start target?) item target.","code":""},{"path":"/reference/any_start_with.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tell if any of a vector of strings starts with another string — any_start_with","text":"","code":"# TRUE, because one of the x string (\"bd\") starts with \"b\" any_start_with(x = c(\"ad\", \"bd\", \"cd\"), target = \"b\") #> [1] TRUE # TRUE, because two of the x strings starts with \"Production\" any_start_with(x = c(\"Production - Crude\", \"Production - NG\", \"Bogus\"), target = \"Production\") #> [1] TRUE # FALSE, because none of the x strings starts with \"Offshore\" any_start_with(x = c(\"Production - Crude\", \"Production - NG\", \"Bogus\"), target = \"Offshore\") #> [1] FALSE # TRUE FALSE, because the x strings start with \"Production\" but not \"Offshore\" any_start_with(x = c(\"Production - Crude\", \"Production - NG\", \"Bogus\"),                target = c(\"Production\", \"Offshore\")) #> [1]  TRUE FALSE"},{"path":"/reference/calc_A.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Z, K, C, D, A, B, and O matrices — calc_A","title":"Calculate Z, K, C, D, A, B, and O matrices — calc_A","text":"matrices define IO structure energy conversion chain.","code":""},{"path":"/reference/calc_A.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Z, K, C, D, A, B, and O matrices — calc_A","text":"","code":"calc_A(   .sutdata = NULL,   direction = c(\"upstream\", \"demand\", \"Leontief\", \"downstream\", \"supply\", \"Ghosh\"),   R = \"R\",   U = \"U\",   U_feed = \"U_feed\",   V = \"V\",   Y = \"Y\",   q = \"q\",   f = \"f\",   g = \"g\",   r = \"r\",   h = \"h\",   Z = \"Z\",   K = \"K\",   C = \"C\",   D = \"D\",   A = \"A\",   O = \"O\",   Z_s = \"Z_s\",   C_s = \"C_s\",   D_s = \"D_s\",   D_feed_s = \"D_feed_s\",   B = \"B\",   O_s = \"O_s\" )"},{"path":"/reference/calc_A.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Z, K, C, D, A, B, and O matrices — calc_A","text":".sutdata data frame supply-use table matrices matrices arranged columns. direction string identifies directionality IO matrices. See details. Default \"upstream\". R resources (R) matrix name column .sutmats contains . Default \"R\". R optional argument. R added V, argument can left unspecified. U Use (U) matrix name column .sutmats contains . Default \"U\". U_feed Feed portion use matrix (U_feed) name column .sutmats contains . Default \"U_feed\". V Make (V) matrix name column .sutmatsthat contains . Default \"V\". Y Final demand (Y) matrix name column .sutmatsthat contains . Default \"Y\". q q vector name column .sutmats contains . Default \"q\". f f vector name column .sutmats contains . Default \"r\". g g vector name column .sutmats contains . Default \"g\". r r vector name column .sutmats contains . Default \"r\". h h vector name column .sutmats contains . Default \"h\". Z name Z matrix output. Default \"Z\". Z calculated U * g_hat_inv. K name K matrix output. Default \"K\". K calculated U * f_hat_inv. C name C matrix output. Default \"C\". C calculated transpose(V) * g_hat_inv. D name D matrix output. Default \"D\". D calculated V * q_hat_inv. name matrix output. Default \"\". calculated Z * D. O name O matrix output. Default \"O\". O calculated r_hat_inv * R. Z_s name Z_s matrix output. Default \"Z_s\". Z_s calculated transpose(V) * f_hat_inv. C_s name C_s matrix output. Default \"C_s\". C_s calculated U * f_hat_inv. D_s name D_s matrix output. Default \"D_s\". D_s calculated transpose(U) * q_hat_inv. D_feed_s name D_feed_s matrix output. Default \"D_feed_s\". D_s calculated transpose(U_feed) * q_hat_inv. B name B matrix output. Default \"B\". B calculated Z_s * D_s. O_s name O_s matrix output. Default \"O_s\". O calculated q_hat_inv * Y.","code":""},{"path":"/reference/calc_A.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Z, K, C, D, A, B, and O matrices — calc_A","text":"list data frame containing Z, K, C, D, , O matrices Z_s, C_s, D_s, D_feed_s, B, O_s matrices, depending value direction.","code":""},{"path":"/reference/calc_A.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Z, K, C, D, A, B, and O matrices — calc_A","text":"Input-output matrices can calculated either upstream swim (demand-sided Leontief) downstream swim (supply-sided Ghosh). direction argument defines direction. Different IO matrices calculated based direction. default \"upstream\", meaning upstream swim desired. Note \"upstream\", \"demand\", \"Leontief\" synonyms. \"downstream\", \"supply\", \"Ghosh\" synonyms. direction = \"upstream\", Z, K, C, D, , O matrices calculated. direction = \"downstream\", Z_s, C_s, D_s, D_feed_s, B, O_s matrices calculated.","code":""},{"path":"/reference/calc_E.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the E matrix for embodied energy calculations — calc_E","title":"Calculate the E matrix for embodied energy calculations — calc_E","text":"Calculate E matrix embodied energy calculations","code":""},{"path":"/reference/calc_E.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the E matrix for embodied energy calculations — calc_E","text":"","code":"calc_E(   .iomats = NULL,   R = \"R\",   V = \"V\",   U_feed = \"U_feed\",   g = \"g\",   r = \"r\",   E = \"E\" )"},{"path":"/reference/calc_E.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the E matrix for embodied energy calculations — calc_E","text":".iomats data frame containing matrices describe Input-Output structure Energy Conversion Chain. .iomats likely obtained calc_io_mats function. R resources (R) matrix name column .iomats containing . Default \"R\". V make (V) matrix name column .iomats containing . Default \"V\". U_feed feedstock use (U_feed) matrix name column .iomats containing . Default \"U_feed\". g g vector name column .iomats containing . Default \"g\". r r vector name column .iomats containing . Default \"r\". E name E matrix output. E calculated W %*% g_hat_inv. Default \"E\".","code":""},{"path":"/reference/calc_E.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the E matrix for embodied energy calculations — calc_E","text":"list data frame containing E matrices.","code":""},{"path":"/reference/calc_ERRs_gamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate energy return ratios for the gamma system boundary. — calc_ERRs_gamma","title":"Calculate energy return ratios for the gamma system boundary. — calc_ERRs_gamma","text":"Calculates energy return ratios gamma system boundary. Calculations performed shown Equations 8, 9, 10 Heun, Owen, Brockway. 2018. physical supply-use table framework energy analysis energy conversion chain. Applied Energy, vol 226, pp. 1134-1162.","code":""},{"path":"/reference/calc_ERRs_gamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate energy return ratios for the gamma system boundary. — calc_ERRs_gamma","text":"","code":"calc_ERRs_gamma(   .sutmats,   U = \"U\",   r_EIOU = \"r_EIOU\",   V = \"V\",   g = \"g\",   S_units = \"S_units\",   ger_gamma = \"ger_gamma\",   ner_gamma = \"ner_gamma\",   r_gamma = \"r_gamma\" )"},{"path":"/reference/calc_ERRs_gamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate energy return ratios for the gamma system boundary. — calc_ERRs_gamma","text":".sutmats data frame containing columns U r_EIOU matrices g vector. U string name column U matrices .sutmats. (Default \"U\".) r_EIOU string name column r_EIOU matrices .sutmats. (Default \"r_EIOU\".) V string name column V matrices .sutmats. (Default \"V\".) g string name column g vector .sutmats. (Default \"g\".) S_units string name column S_units matrices .sutmats. (Default \"S_units\".) ger_gamma name gross energy ratio column output. (Default \"ger_gamma\", ner_gamma name net energy ratio column output. (Default \"ner_gamma\",) r_gamma name ratio energy ratios output. (Default \"r_gamma\",","code":""},{"path":"/reference/calc_ERRs_gamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate energy return ratios for the gamma system boundary. — calc_ERRs_gamma","text":".sutmats additional columns \"ner_gamma\", \"ger_gamma\", \"r_gamma\".","code":""},{"path":"/reference/calc_ERRs_gamma.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate energy return ratios for the gamma system boundary. — calc_ERRs_gamma","text":"energy return ratios given industry calculated iff units inputs outputs industry unit-homogeneous. units inputs outputs heterogeneous industry, NA result.","code":""},{"path":"/reference/calc_ERRs_gamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate energy return ratios for the gamma system boundary. — calc_ERRs_gamma","text":"","code":"library(tidyr) library(Recca) UKEnergy2000mats %>%   spread(key = \"matrix.name\", value = \"matrix\") %>%   calc_io_mats() %>%   calc_ERRs_gamma() #> # A tibble: 4 × 35 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 27 more variables: U_feed <list>, V <list>, Y <list>, r_EIOU <list>, #> #   y <list>, q <list>, f <list>, g <list>, h <list>, r <list>, W <list>, #> #   Z <list>, K <list>, C <list>, D <list>, A <list>, O <list>, L_pxp <list>, #> #   L_ixp <list>, Z_feed <list>, K_feed <list>, A_feed <list>, #> #   L_pxp_feed <list>, L_ixp_feed <list>, ger_gamma <list>, ner_gamma <list>, #> #   r_gamma <list>"},{"path":"/reference/calc_E_EIOU.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate embodied EIOU per industry output — calc_E_EIOU","title":"Calculate embodied EIOU per industry output — calc_E_EIOU","text":"function calculates EIOU per industry output given .iomats data frame input-output matrices energy conversion chain. returned E_EIOU matrix contains -product EIOU used unit industry output, e_EIOU vector contains total EIOU unit industry output.","code":""},{"path":"/reference/calc_E_EIOU.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate embodied EIOU per industry output — calc_E_EIOU","text":"","code":"calc_E_EIOU(   .iomats = NULL,   g = \"g\",   U_EIOU = \"U_EIOU\",   E_EIOU = \"E_EIOU\",   e_EIOU = \"e_EIOU\" )"},{"path":"/reference/calc_E_EIOU.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate embodied EIOU per industry output — calc_E_EIOU","text":".iomats data frame containing matrices describe Input-Output structure Energy Conversion Chain. .iomats likely obtained calc_io_mats() function. g name g vector output. Default \"g\". U_EIOU name U_EIOU matrices output. Default \"U_EIOU\". E_EIOU name E_EIOU matrix output. Default \"E_EIOU\". e_EIOU name e_EIOU vector output. Default \"e_EIOU\".","code":""},{"path":"/reference/calc_E_EIOU.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate embodied EIOU per industry output — calc_E_EIOU","text":"List data frame containing E_EIOU matrix e_EIOU vector.","code":""},{"path":"/reference/calc_E_EIOU.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate embodied EIOU per industry output — calc_E_EIOU","text":"output E_EIOU matrix calculated U_EIOU %*% g_hat_inv. output e_EIOU vector sum E_EIOU columns: transpose() %*% E_EIOU.","code":""},{"path":"/reference/calc_E_EIOU.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate embodied EIOU per industry output — calc_E_EIOU","text":"","code":"library(IEATools) #>  #> Attaching package: ‘IEATools’ #> The following objects are masked from ‘package:Recca’: #>  #>     aggregate_cols, all_stages, energy_types, finaldemand_aggregates, #>     primary_aggregates, psut_cols, row_col_types UKEnergy2000mats %>%    dplyr::filter(Last.stage == \"Final\", Energy.type == \"E\") %>%    tidyr::pivot_wider(names_from = \"matrix.name\", values_from = \"matrix\") %>%    calc_io_mats() %>%    calc_E_EIOU() #> # A tibble: 1 × 34 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 26 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   y <list>, q <list>, f <list>, g <list>, h <list>, r <list>, W <list>, #> #   Z <list>, K <list>, C <list>, D <list>, A <list>, O <list>, L_pxp <list>, #> #   L_ixp <list>, Z_feed <list>, K_feed <list>, A_feed <list>, #> #   L_pxp_feed <list>, L_ixp_feed <list>, E_EIOU <list>, e_EIOU <list>"},{"path":"/reference/calc_F_footprint_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Upstream footprint and downstream effects matrices — calc_F_footprint_effects","title":"Upstream footprint and downstream effects matrices — calc_F_footprint_effects","text":"Calculates upstream footprint matrices (F_footprint_p F_footprint_s) downstream effects matrices (F_effects_p F_effects_s) given embodied matrices M_p M_s. Column sums F_footprint 1. Row sums F_effects 1.","code":""},{"path":"/reference/calc_F_footprint_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Upstream footprint and downstream effects matrices — calc_F_footprint_effects","text":"","code":"calc_F_footprint_effects(   .Mmats = NULL,   M_p = \"M_p\",   M_s = \"M_s\",   F_footprint_p = \"F_footprint_p\",   F_effects_p = \"F_effects_p\",   F_footprint_s = \"F_footprint_s\",   F_effects_s = \"F_effects_s\" )"},{"path":"/reference/calc_F_footprint_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Upstream footprint and downstream effects matrices — calc_F_footprint_effects","text":".Mmats data frame containing column embodied matrices. M_p embodied product matrix name column .Mmats containing . Default \"M_p\". M_s embodied sector matrix name column .Mmats containing . Default \"M_s\". F_footprint_p name F_footprint_p matrices output. Default \"F_footprint_p\". F_effects_p name F_effects_p matrices output. Default \"F_effects_p\". F_footprint_s name F_footprint_s matrices output. Default \"F_footprint_s\". F_effects_s name F_effects_s matrices output. Default \"F_effects_s\".","code":""},{"path":"/reference/calc_F_footprint_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Upstream footprint and downstream effects matrices — calc_F_footprint_effects","text":"list data frame containing F_footprint_p, F_effects_p, F_footprint_s, F_effects_s matrices.","code":""},{"path":"/reference/calc_GH.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the G and H matrices for embodied energy calculations — calc_GH","title":"Calculate the G and H matrices for embodied energy calculations — calc_GH","text":"Calculate G H matrices embodied energy calculations","code":""},{"path":"/reference/calc_GH.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the G and H matrices for embodied energy calculations — calc_GH","text":"","code":"calc_GH(   .iomats = NULL,   Y = \"Y\",   L_ixp = \"L_ixp\",   R = \"R\",   A = \"A\",   q = \"q\",   G_V = \"G_V\",   G_R = \"G_R\",   G = \"G\",   H_V = \"H_V\",   H_R = \"H_R\",   H = \"H\" )"},{"path":"/reference/calc_GH.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the G and H matrices for embodied energy calculations — calc_GH","text":".iomats data frame containing matrices describe Input-Output structure Energy Conversion Chain. .iomats likely obtained calc_io_mats function. Y final demand (Y) matrix name column .iodata containing . Default \"Y\". L_ixp industry--product Leontief (L_ixp) matrix name column .iodata containing . Default \"L_ixp\". R Resources (R) matrix name column .iodata containing . Default \"R\". name matrix column .iomats data frame. Default \"\". q name q vector .iomats data frame. Default \"q\". G_V name G_V matrix output. Default \"G_V\". G_V calculated L_ixp * y_hat. G_R name G_R matrix output. Default \"G_R\". G_R calculated R * q_hat_inv * L_pxp * y_hat. G name G matrix output. Default \"G\". G calculated G_R + G_V. H_V name H_V matrix output. Default \"H_V\". H_V calculated L_ixp * Y. H_R name H_R matrix output. Default \"H_R\". H_R calculated R * q_hat_inv * L_pxp * Y. H name H matrix output. Default \"H\". H calculated H_V + H_R.","code":""},{"path":"/reference/calc_GH.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the G and H matrices for embodied energy calculations — calc_GH","text":"list data frame containing G H matrices.","code":""},{"path":"/reference/calc_L.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates total requirements matrices (L_pxp and L_ixp or G_pxp and G_ixp) — calc_L","title":"Calculates total requirements matrices (L_pxp and L_ixp or G_pxp and G_ixp) — calc_L","text":"L_pxp tells much product (row) required make another product (column). L_ixp tells much industry's output (row) required make another product (column). G_pxp G_ixp Ghosh (downstream, supply-sided) equivalents.","code":""},{"path":"/reference/calc_L.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates total requirements matrices (L_pxp and L_ixp or G_pxp and G_ixp) — calc_L","text":"","code":"calc_L(   .sutdata = NULL,   direction = c(\"upstream\", \"demand\", \"Leontief\", \"downstream\", \"supply\", \"Ghosh\"),   method = c(\"solve\", \"QR\", \"SVD\"),   tol = .Machine$double.eps,   D = \"D\",   A = \"A\",   D_s = \"D_s\",   B = \"B\",   L_pxp = \"L_pxp\",   L_ixp = \"L_ixp\",   G_pxp = \"G_pxp\",   G_ixp = \"G_ixp\" )  calc_G(   .sutdata = NULL,   direction = c(\"upstream\", \"demand\", \"Leontief\", \"downstream\", \"supply\", \"Ghosh\"),   method = c(\"solve\", \"QR\", \"SVD\"),   tol = .Machine$double.eps,   D = \"D\",   A = \"A\",   D_s = \"D_s\",   B = \"B\",   L_pxp = \"L_pxp\",   L_ixp = \"L_ixp\",   G_pxp = \"G_pxp\",   G_ixp = \"G_ixp\" )"},{"path":"/reference/calc_L.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates total requirements matrices (L_pxp and L_ixp or G_pxp and G_ixp) — calc_L","text":".sutdata data frame supply-use table matrices matrices arranged columns. Default NULL, meaning matrices taken D arguments. Set list data frame pull matrices store. direction string identifies directionality IO matrices. See details. Default \"upstream\". method One \"solve\", \"QR\", \"SVD\". Default \"solve\". See details. tol tolerance detecting linear dependencies matrix inversion. Default .Machine$double.eps. D D matrix name column .sutmats contains . D required direction = \"upstream\". Default \"D\". matrix name column .sutmats contains . D required direction = \"upstream\". Default \"\". D_s D_s matrix name column .sutmats contains . D_s required direction = \"downstream\". Default \"D_s\". B B matrix name column .sutmats contains . B required direction = \"downstream\". Default \"B\". L_pxp name L_pxp matrix output. Default \"L_pxp\". L_pxp calculated inverse(- ). L_ixp name L_ixp matrix output. Default \"L_ixp\". L_ixp calculated D * L_pxp. G_pxp name G_pxp matrix output. Default \"G_pxp\". G_pxp calculated inverse(- A_s). G_ixp name G_ixp matrix output. Default \"G_ixp\". G_ixp calculated D_s * G_pxp.","code":""},{"path":"/reference/calc_L.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates total requirements matrices (L_pxp and L_ixp or G_pxp and G_ixp) — calc_L","text":"list data frame containing L_pxp L_ixp G_pxp G_ixp matrices.","code":""},{"path":"/reference/calc_L.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates total requirements matrices (L_pxp and L_ixp or G_pxp and G_ixp) — calc_L","text":"Calculating matrices requires matrix inversion operation. method argument specifies method used calculating inverse. See matsbyname::invert_byname(). tol method single values apply matrices inverted. Input-output matrices can calculated either upstream swim (demand-sided Leontief) downstream swim (supply-sided Ghosh). direction argument defines direction. Different IO matrices calculated based direction. default \"upstream\", meaning upstream swim desired. Note \"upstream\", \"demand\", \"Leontief\" synonyms. \"downstream\", \"supply\", \"Ghosh\" synonyms. Upstream swim matrices named Leontief called L_pxp L_ixp. Downstream swim matrices named Ghosh called G_pxp G_ixp. matrices returned (L G) depends value direction argument. \"upstream\", \"demand\", \"Leontief\" generates L matrices. \"downstream\", \"supply, \"Ghosh\" generates G matrices. Note historical reasons, calc_L() calc_G() synonyms. calculate L matrices G matrices, depending value direction argument. good practice call calc_L() upstream swim calc_G() downstream swim. clearly signals intent.","code":""},{"path":"/reference/calc_M.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate embodied energy matrices — calc_M","title":"Calculate embodied energy matrices — calc_M","text":"M calculated e_hat * G, e_hat contains lists matrices, M also contain lists matrices. list, one M matrix Product Energy conversion chain.","code":""},{"path":"/reference/calc_M.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate embodied energy matrices — calc_M","text":"","code":"calc_M(   .YqGHEdata = NULL,   Y = \"Y\",   q = \"q\",   G = \"G\",   E = \"E\",   tol = 1e-04,   M_p = \"M_p\",   M_s = \"M_s\" )"},{"path":"/reference/calc_M.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate embodied energy matrices — calc_M","text":".YqGHEdata data frame containing columns q vectors Y, G, H, E matrices. .YqGEdata likely obtained calc_GH() calc_E() functions. Y final demand (Y) matrix name column .YqHGEdata containing . Default \"Y\". q q column vector name column .YqHGEdata containing . Default \"q\". G G matrix name column .YqHGEdata containing . Default \"G\". E E matrix name column .YqHGEdata containing . Default \"E\". tol allowable energy balance error. M_p name matrices embodied energy products output. Default \"M_p\". matrices contain embodied products rows embodying products columns. M_s name matrices embodied energy consumed final demand sectors. Default \"M_s\". matrices contain embodied products rows consuming final demand sectors columns.","code":""},{"path":"/reference/calc_M.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate embodied energy matrices — calc_M","text":"list data frame embodied energy matrices.","code":""},{"path":"/reference/calc_agg_eta_pfus.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate aggregations and efficiencies — calc_agg_eta_pfus","title":"Calculate aggregations and efficiencies — calc_agg_eta_pfus","text":"Given matsindf-style data frame energy conversion chains (ECCs), function calculates primary, final, useful, services (available) aggregates associated efficiencies. Columns containing PSUT matrices returned output.","code":""},{"path":"/reference/calc_agg_eta_pfus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate aggregations and efficiencies — calc_agg_eta_pfus","text":"","code":"calc_agg_eta_pfus(   .psut_df,   p_industries,   fd_sectors,   remove_psut_cols = TRUE,   piece = \"noun\",   notation = list(RCLabels::bracket_notation, RCLabels::arrow_notation),   pattern_type = \"exact\",   prepositions = RCLabels::prepositions_list,   R = Recca::psut_cols$R,   U = Recca::psut_cols$U,   U_feed = Recca::psut_cols$U_feed,   U_eiou = Recca::psut_cols$U_eiou,   r_eiou = Recca::psut_cols$r_eiou,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   S_units = Recca::psut_cols$S_units,   gross = Recca::efficiency_cols$gross,   net = Recca::efficiency_cols$net,   gross_net = Recca::efficiency_cols$gross_net,   last_stage = Recca::psut_cols$last_stage,   primary = Recca::all_stages$primary,   final = Recca::all_stages$final,   useful = Recca::all_stages$useful,   services = Recca::all_stages$services,   ex_p = Recca::aggregate_cols$aggregate_primary,   ex_f = Recca::aggregate_cols$aggregate_final,   ex_u = Recca::aggregate_cols$aggregate_useful,   ex_s = Recca::aggregate_cols$aggregate_services,   ex_fd_gross = Recca::aggregate_cols$gross_aggregate_demand,   ex_fd_net = Recca::aggregate_cols$net_aggregate_demand,   ex_fd = Recca::aggregate_cols$aggregate_demand,   eta_pf = Recca::efficiency_cols$eta_pf,   eta_fu = Recca::efficiency_cols$eta_fu,   eta_us = Recca::efficiency_cols$eta_us,   eta_pu = Recca::efficiency_cols$eta_pu,   eta_ps = Recca::efficiency_cols$eta_ps,   eta_fs = Recca::efficiency_cols$eta_fs )"},{"path":"/reference/calc_agg_eta_pfus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate aggregations and efficiencies — calc_agg_eta_pfus","text":".psut_df data frame energy conversion chain data PSUT format. p_industries string vector primary industries. fd_sectors string vector final demand sectors. remove_psut_cols boolean telling whether delete columns containing PSUT matrices. Default TRUE. piece piece labels used matching. Default \"noun\". notation notation used row column labels. Default list(RCLabels::bracket_notation, RCLabels::arrow_notation). pattern_type pattern type used row column matching. Default \"exact\". prepositions list prepositions row column labels. Default RCLabels::prepositions_list. R, U, V, Y, r_eiou, U_eiou, U_feed, S_units, last_stage String names matrix columns .psut_df. See Recca::psut_cols. gross, net, gross_net See Recca::efficiency_cols. primary, final, useful, services See IEATools::all_stages. ex_p, ex_fd_gross, ex_fd_net, ex_fd Names aggregate columns. See Recca::aggregate_cols. ex_f, ex_u, ex_s See IEATools::aggregate_cols. eta_pf, eta_fu, eta_us, eta_pu, eta_ps, eta_fs See Recca::efficiency_cols.","code":""},{"path":"/reference/calc_agg_eta_pfus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate aggregations and efficiencies — calc_agg_eta_pfus","text":"data frame metadata columns; primary, final, useful, services aggregations; efficiencies.","code":""},{"path":"/reference/calc_agg_eta_pfus.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate aggregations and efficiencies — calc_agg_eta_pfus","text":"Final, useful, services data assumed contained final demand matrix (Y) various rows .psut_df, identified last_stage column .psut_df. function still work, even primary energy different last stage. Internally, primary aggregates calculated using primary_aggregates(), final demand aggregates calculated using finaldemand_aggregates(). meaning final demand aggregates row .psut_df determined corresponding value last_stage column. Note ECC stage present, aggregation efficiency columns removed output. services stage present, efficiencies mixed units might meaningless. Proceed caution.","code":""},{"path":"/reference/calc_agg_eta_pfus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate aggregations and efficiencies — calc_agg_eta_pfus","text":"","code":"p_industries <- \"Resources\" fd_sectors <- c(\"Residential\", \"Transport\", \"Oil fields\") UKEnergy2000mats |>   tidyr::pivot_wider(names_from = matrix.name, values_from = matrix) |>   calc_agg_eta_pfus(p_industries = p_industries, fd_sectors = fd_sectors) #> # A tibble: 8 × 15 #>   Country  Year Energy.type Last.stage GrossNet  EX.p  EX.f    EX.s   EX.u #>   <chr>   <dbl> <chr>       <chr>      <chr>    <dbl> <dbl>   <dbl>  <dbl> #> 1 GBR      2000 E           Final      Gross    93000 74325 5.01e14 25990. #> 2 GBR      2000 E           Final      Net      93000 71750 5.01e14 25915. #> 3 GBR      2000 E           Services   Gross    93000 74325 5.01e14 25990. #> 4 GBR      2000 E           Services   Net      93000 71750 5.01e14 25915. #> 5 GBR      2000 E           Useful     Gross    93000 74325 5.01e14 25990. #> 6 GBR      2000 E           Useful     Net      93000 71750 5.01e14 25915. #> 7 GBR      2000 X           Services   Gross    98220    NA 5.01e14    NA  #> 8 GBR      2000 X           Services   Net      98220    NA 5.01e14    NA  #> # ℹ 6 more variables: eta_pf <dbl>, eta_fu <dbl>, eta_pu <dbl>, eta_ps <dbl>, #> #   eta_fs <dbl>, eta_us <dbl>"},{"path":"/reference/calc_aggregates_from_ecc_prime.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate aggregates from list of reconstructed ECCs — calc_aggregates_from_ecc_prime","title":"Calculate aggregates from list of reconstructed ECCs — calc_aggregates_from_ecc_prime","text":"helper function footprint_aggregates() effects_aggregates(). calculates primary final demand aggregates list reconstructed energy conversion chains (ECCs) ecc_prime.","code":""},{"path":"/reference/calc_aggregates_from_ecc_prime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate aggregates from list of reconstructed ECCs — calc_aggregates_from_ecc_prime","text":"","code":"calc_aggregates_from_ecc_prime(   ecc_prime,   calc_pfd_aggs,   p_industries,   fd_sectors,   piece = \"all\",   notation = RCLabels::notations_list,   pattern_type = c(\"exact\", \"leading\", \"trailing\", \"anywhere\", \"literal\"),   prepositions = RCLabels::prepositions_list,   product_sector,   chop_df,   aggregate_primary,   gross_aggregate_demand,   net_aggregate_demand,   R_prime_colname,   U_prime_colname,   U_feed_prime_colname,   U_eiou_prime_colname,   r_eiou_prime_colname,   V_prime_colname,   Y_prime_colname,   S_units_prime_colname )"},{"path":"/reference/calc_aggregates_from_ecc_prime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate aggregates from list of reconstructed ECCs — calc_aggregates_from_ecc_prime","text":"ecc_prime list reconstructed energy conversion chains. calc_pfd_aggs Tells whether calculate add primary final demand aggregates nested data frame. p_industries vector names industries aggregated \"primary.\" See footprint_aggregates() details. fd_sectors vector names sectors final demand. See footprint_aggregates() details. piece piece labels matched. Default \"\". See RCLabels package. notation notation type matching. Default RCLabels::notations_list. pattern_type One \"exact\", \"leading\", \"trailing\", \"anywhere\" specifies matches made p_industries. See footprint_aggregates() details. prepositions Prepositions notation matching. Default RCLabels::prepositions_list. product_sector name output column contains product, industry, sector footprint aggregates given. chop_df, aggregate_primary, net_aggregate_demand, gross_aggregate_demand Names output columns. See Recca::aggregate_cols. R_prime_colname, U_prime_colname, U_feed_prime_colname, U_eiou_prime_colname, r_eiou_prime_colname, V_prime_colname, Y_prime_colname, S_units_prime_colname Names output matrices return value. Default values constructed ","code":""},{"path":"/reference/calc_aggregates_from_ecc_prime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate aggregates from list of reconstructed ECCs — calc_aggregates_from_ecc_prime","text":"data frame containing reconstructed (prime) matrices primary final demand aggregates list suitable use matsindf::matsindf_apply().","code":""},{"path":"/reference/calc_aggregates_from_ecc_prime.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate aggregates from list of reconstructed ECCs — calc_aggregates_from_ecc_prime","text":"public function. internal helper function footprint_aggregates() effects_aggregates().","code":""},{"path":"/reference/calc_embodied_EIOU.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate various embodied EIOU matrices — calc_embodied_EIOU","title":"Calculate various embodied EIOU matrices — calc_embodied_EIOU","text":"function calculates different embodied Energy Industry Use (EIOU) matrices (see details) given energy conversion chain final demand, using data frame input-output matrices physical supply-use table (PSUT) format.","code":""},{"path":"/reference/calc_embodied_EIOU.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate various embodied EIOU matrices — calc_embodied_EIOU","text":"","code":"calc_embodied_EIOU(   .iomats = NULL,   e_EIOU = \"e_EIOU\",   Y = \"Y\",   y = \"y\",   L_ixp = \"L_ixp\",   L_ixp_feed = \"L_ixp_feed\",   Q_EIOU_s = \"Q_EIOU_s\",   Q_EIOU_p = \"Q_EIOU_p\",   Q_EIOU_feed_s = \"Q_EIOU_feed_s\",   Q_EIOU_feed_p = \"Q_EIOU_feed_p\" )"},{"path":"/reference/calc_embodied_EIOU.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate various embodied EIOU matrices — calc_embodied_EIOU","text":".iomats wide--matrices data frame containing matrices describe Input-Output structure (using supply-use table format) Energy Conversion Chain. .iomats likely obtained combining calc_io_mats() calc_E_EIOU() functions. See examples. e_EIOU direct energy use extension vector name column .iomats containing . Default \"e_EIOU\". Y final demand matrix (Y) name column .iomats containing . Default \"Y\". y y vector name column .iomats containing . Default \"y\". L_ixp L_ixp matrix name column .iomats containing . Default \"L_ixp\". L_ixp_feed L_ixp_feed matrix name column .iomats containing . Default \"L_ixp_feed\". Q_EIOU_s name output column containing EIOU embodied final demand sectors, including energy use feedstock EIOU production. Default \"Q_EIOU_s\". Q_EIOU_p name output column containing EIOU embodied final demand products, including energy use feedstock EIOU production. Default \"Q_EIOU_p\". Q_EIOU_feed_s name output column containing EIOU embodied final demand sectors, including energy use feedstock production. Default \"Q_EIOU_feed_s\". Q_EIOU_feed_p name output column containing EIOU embodied final demand products, including energy use feedstock production. Default \"Q_EIOU_feed_p\".","code":""},{"path":"/reference/calc_embodied_EIOU.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate various embodied EIOU matrices — calc_embodied_EIOU","text":"data frame contains several embodied EIOU matrices added columns. See description details.","code":""},{"path":"/reference/calc_embodied_EIOU.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate various embodied EIOU matrices — calc_embodied_EIOU","text":"argument .iomats wide--matrices data frame, obtained combining calc_iomats() calc_E_EIOU() functions described example. function adds many additional columns .iomats, one containing particular embodied EIOU matrices. embodied EIOU matrices calculated either: final demand sector (subscript \"_s\" appears name); final demand products (subscript \"_p\" appears name); including EIOU required feedstock inputs production (subscript \"_feed\" appears name); including EIOU required feedstock EIOU inputs production (additional subscript). Note: matrix multiplication (%*%) performed \"name\" using matsbyname::matrixproduct_byname(). Output columns include: Q_EIOU_s: matrix embodied EIOU final demand sectors, including energy use feedstock EIOU production. Q_EIOU_s calculated e_EIOU_hat %*% L_ixp %*% Y. Q_EIOU_p: matrix embodied EIOU final demand products, including energy use feedstock EIOU production. Q_EIOU_p calculated e_EIOU_hat %*% L_ixp %*% y_hat. Q_EIOU_feed_s: matrix embodied EIOU final demand sectors, including energy use feedstock production. Q_EIOU_feed_s calculated e_EIOU_hat %*% L_ixp_feed %*% Y. Q_EIOU_feed_p: matrix embodied EIOU final demand products, including energy use feedstock production. Q_EIOU_feed_p calculated e_EIOU_hat %*% L_ixp_feed %*% y_hat.","code":""},{"path":"/reference/calc_embodied_EIOU.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate various embodied EIOU matrices — calc_embodied_EIOU","text":"","code":"library(IEATools) UKEnergy2000mats %>%   tidyr::pivot_wider(names_from = \"matrix.name\", values_from = \"matrix\") %>%   calc_io_mats() %>%   calc_E_EIOU() %>%   calc_embodied_EIOU() #> # A tibble: 4 × 38 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 30 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   y <list>, q <list>, f <list>, g <list>, h <list>, r <list>, W <list>, #> #   Z <list>, K <list>, C <list>, D <list>, A <list>, O <list>, L_pxp <list>, #> #   L_ixp <list>, Z_feed <list>, K_feed <list>, A_feed <list>, #> #   L_pxp_feed <list>, L_ixp_feed <list>, E_EIOU <list>, e_EIOU <list>, #> #   Q_EIOU_p <list>, Q_EIOU_s <list>, Q_EIOU_feed_p <list>, #> #   Q_EIOU_feed_s <list>"},{"path":"/reference/calc_embodied_etas.html","id":null,"dir":"Reference","previous_headings":"","what":"Embodied energy efficiencies — calc_embodied_etas","title":"Embodied energy efficiencies — calc_embodied_etas","text":"Embodied energy efficiencies based total upstream primary energy demand product produced ECC energy consumed final demand sector ECC. function calculates . eta_s gives sector-based embodied energy efficiency, eta_p gives product-based embodied energy efficiency.","code":""},{"path":"/reference/calc_embodied_etas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Embodied energy efficiencies — calc_embodied_etas","text":"","code":"calc_embodied_etas(   .embodiedmats = NULL,   primary_machine_names,   Y = \"Y\",   G = \"G\",   H = \"H\",   eta_p = \"eta_p\",   eta_s = \"eta_s\" )"},{"path":"/reference/calc_embodied_etas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Embodied energy efficiencies — calc_embodied_etas","text":".embodiedmats data frame containing columns Y, G, H matrices. primary_machine_names list strings representing names Industries whose output counted Total Energy Supply (TPES). Y final demand (Y) matrix name column .embodiedmats containing . Default \"Y\". G G  matrix name column .embodiedmats containing . Default \"G\". H H matrix name column .embodiedmats containing . Default \"H\". eta_p name product-based efficiencies output. Default \"eta_p\". eta_s name final-demand-sector-based efficiencies output. Default \"eta_s\".","code":""},{"path":"/reference/calc_embodied_etas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Embodied energy efficiencies — calc_embodied_etas","text":"list data frame containing embodied energy efficiencies.","code":""},{"path":"/reference/calc_embodied_etas.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Embodied energy efficiencies — calc_embodied_etas","text":"Note efficiencies (eta_s eta_p) different energy conversion industry efficiencies. calculate energy conversion industry efficiencies, use calc_eta_i() function.","code":""},{"path":"/reference/calc_embodied_mats.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate various embodied energy matrices — calc_embodied_mats","title":"Calculate various embodied energy matrices — calc_embodied_mats","text":"Calculate various embodied energy matrices","code":""},{"path":"/reference/calc_embodied_mats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate various embodied energy matrices — calc_embodied_mats","text":"","code":"calc_embodied_mats(   .iomats = NULL,   q = \"q\",   g = \"g\",   r = \"r\",   L_ixp = \"L_ixp\",   A = \"A\",   R = \"R\",   V = \"V\",   U_feed = \"U_feed\",   Y = \"Y\",   G = \"G\",   H = \"H\",   E = \"E\",   M_p = \"M_p\",   M_s = \"M_s\",   F_footprint_p = \"F_footprint_p\",   F_effects_p = \"F_effects_p\",   F_footprint_s = \"F_footprint_s\",   F_effects_s = \"F_effects_s\" )"},{"path":"/reference/calc_embodied_mats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate various embodied energy matrices — calc_embodied_mats","text":".iomats data frame containing matrices describe Input-Output structure (using supply-use table format) Energy Conversion Chain. .iomats likely obtained calc_io_mats() function. q Final demand (q) vector name column .iomats containing . Default \"q\". g g vector name column .iomats containing . Default \"g\". r r vector name column .iomats containing . Default \"r\". L_ixp Industry--product Leontief (L_ixp) matrix name column .iomats containing . Default \"L_ixp\". matrix name column .iomats containing . Default \"\". R resources (R) matrix name column .iomats containing . Default \"R\". V make (V) matrix name column .iomats containing . Default \"V\". U_feed feedstock use (U_feed) matrix name column .iomats containing . Default \"U_feed\". Y final demand (Y) matrix name column .iomats containing . Default \"Y\". G name G matrix output. G calculated L_ixp %*% y_hat. Default \"G\". H name H matrix output. H calculated L_ixp %*% Y. Default \"H\". E name E matrix output. E calculated W %*% g_hat_inv. Default \"E\". M_p name M_p matrix output. M_p formed column sums positive entries various Q_x matrices. Default \"M_p\". M_s name M_s matrix output. M_s calculated M_p %*% q_hat_inv %*% Y. Default \"M_s\". F_footprint_p name F_footprint_p matrix output. F_footprint_p calculated M_p %*% (M_p^T %*% )_hat_inv. Default \"F_footprint_p\". F_effects_p name F_effects_p matrix output. F_effects_p calculated (M_p %*% )_hat_inv %*% M_p. Default \"F_effects_p\". F_footprint_s name F_footprint_s matrix output. F_footprint_s calculated M_s %*% (M_s^T %*% )_hat_inv. Default \"F_footprint_s\". F_effects_s name F_effects_s matrix output. F_effects_s calculated (M_s %*% )_hat_inv %*% M_s. Default \"F_effects_s\".","code":""},{"path":"/reference/calc_embodied_mats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate various embodied energy matrices — calc_embodied_mats","text":"list data frame containing embodied energy matrices.","code":""},{"path":"/reference/calc_erois.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate EROIs — calc_erois","title":"Calculate EROIs — calc_erois","text":"function calculates energy return investment (EROI) values given data frame input-output matrices physical supply-use table (PSUT) format energy conversion chain.","code":""},{"path":"/reference/calc_erois.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate EROIs — calc_erois","text":"","code":"calc_erois(   .iomats = NULL,   e_EIOU = \"e_EIOU\",   L_ixp = \"L_ixp\",   L_ixp_feed = \"L_ixp_feed\",   D = \"D\",   C = \"C\",   eroi_g_p = \"eroi_g_p\",   eroi_g_i = \"eroi_g_i\",   eroi_g_p_feed = \"eroi_g_p_feed\",   eroi_g_i_feed = \"eroi_g_i_feed\" )"},{"path":"/reference/calc_erois.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate EROIs — calc_erois","text":".iomats wide--matrices data frame containing matrices describe Input-Output structure (using supply-use table format) Energy Conversion Chain. .iomats likely obtained combining calc_io_mats() calc_E_EIOU() functions. See example. e_EIOU name column containing e_EIOU vectors .iomats. Default \"e_EIOU\". L_ixp name column containing L_ixp matrices .iomats. Default \"L_ixp\". L_ixp_feed name column containing L_ixp_feed matrix .iomats. Default \"L_ixp_feed\". D name column containing D matrices .iomats. Default \"D\". C name column containing C matrix .iomats. Default \"C\". eroi_g_p name output column containing vectors product-level gross EROIs, including energy use feedstock EIOU production. Default \"eroi_g_p\". eroi_g_i name output column containing vectors industry-level gross EROIs, including energy use feedstock EIOU production. Default \"eroi_g_i\". eroi_g_p_feed name output column containing vectors product-level gross EROIs, including energy use feedstock production. Default \"eroi_g_p_feed\". eroi_g_i_feed name output column containing vectors industry-level gross EROIs, including energy use feedstock production. Default \"eroi_g_i_feed\".","code":""},{"path":"/reference/calc_erois.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate EROIs — calc_erois","text":"data frame includes several additional EROIs vectors added columns. See description details.","code":""},{"path":"/reference/calc_erois.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate EROIs — calc_erois","text":"argument .iomats wide--matrices data frame. input columns named matrices contain. function adds many additional columns .iomats, one containing particular type EROI. default column names use following naming convention: names EROIs calculated products include string \"_p\"; names EROIs calculated industries include string \"_i\"; names gross EROIs include string \"_g\"; names net EROIs include string \"_n\". addition, calculations made based inclusion either EIOU required feedstock inputs production (case \"_feed\" appears name); EIOU required feedstock EIOU inputs production (additional string name). Output columns include: eroi_g_p: vector product-level gross EROIs, including EIOU required feedstock EIOU inputs production. inverse eroi_g_p calculated transpose() %*% e_EIOU_hat %*% L_ixp. eroi_g_i: vector industry-level gross EROIs, including EIOU required feedstock EIOU inputs production. inverse eroi_i_p calculated transpose(C) * eroi_g_p_inv. eroi_g_p_feed: vector product-level gross EROIs, including EIOU required feedstock inputs production. inverse eroi_g_p_feed calculated transpose() %*% e_EIOU_hat %*% L_ixp_feed. eroi_g_i_feed: vector industry-level gross EROIs, including EIOU required feedstock inputs production. inverse eroi_i_p calculated transpose(C) %*% eroi_g_p_feed_inv. Note: matrix multiplication (%*%) performed \"name\" using matsbyname::matrixproduct_byname().","code":""},{"path":"/reference/calc_erois.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate EROIs — calc_erois","text":"","code":"library(IEATools) UKEnergy2000mats %>%   dplyr::filter(Last.stage == \"Final\", Energy.type == \"E\") %>%   tidyr::pivot_wider(names_from = \"matrix.name\", values_from = \"matrix\") %>%   calc_io_mats() %>%   calc_E_EIOU() %>%   calc_erois() #> # A tibble: 1 × 38 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 30 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   y <list>, q <list>, f <list>, g <list>, h <list>, r <list>, W <list>, #> #   Z <list>, K <list>, C <list>, D <list>, A <list>, O <list>, L_pxp <list>, #> #   L_ixp <list>, Z_feed <list>, K_feed <list>, A_feed <list>, #> #   L_pxp_feed <list>, L_ixp_feed <list>, E_EIOU <list>, e_EIOU <list>, #> #   eroi_g_p <list>, eroi_g_i <list>, eroi_g_p_feed <list>, #> #   eroi_g_i_feed <list>"},{"path":"/reference/calc_eta_fu_Y_eiou.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate final-to-useful efficiencies for final demand and EIOU when last stage is final — calc_eta_fu_Y_eiou","title":"Calculate final-to-useful efficiencies for final demand and EIOU when last stage is final — calc_eta_fu_Y_eiou","text":"Final--useful efficiencies energy carriers sectors final demand energy industry use can calculated allocations (C_Y C_eiou), machine efficiencies (eta_i), (exergetic efficiencies) exergy--energy ratios (phi). function performs calculations. default, output contains matrices structure Y U_EIOU last stage final.","code":""},{"path":"/reference/calc_eta_fu_Y_eiou.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate final-to-useful efficiencies for final demand and EIOU when last stage is final — calc_eta_fu_Y_eiou","text":"","code":"calc_eta_fu_Y_eiou(   .c_mats_eta_phi_vecs = NULL,   C_Y = Recca::alloc_cols$C_Y,   C_eiou = Recca::alloc_cols$C_eiou,   eta_i = Recca::efficiency_cols$eta_i,   phi = Recca::psut_cols$phi,   matricize = TRUE,   energy_type = Recca::energy_types$energy_type,   eta_fu = Recca::efficiency_cols$eta_fu,   energy = Recca::energy_types$e,   exergy = Recca::energy_types$x,   eta_fu_Y_e = paste0(eta_fu, \"_Y_\", energy),   eta_fu_Y_x = paste0(eta_fu, \"_Y_\", exergy),   eta_fu_eiou_e = paste0(eta_fu, \"_EIOU_\", energy),   eta_fu_eiou_x = paste0(eta_fu, \"_EIOU_\", exergy),   notation = RCLabels::arrow_notation )"},{"path":"/reference/calc_eta_fu_Y_eiou.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate final-to-useful efficiencies for final demand and EIOU when last stage is final — calc_eta_fu_Y_eiou","text":".c_mats_eta_phi_vecs data frame containing allocation matrices (C_Y C_eiou), vectors machine efficiencies (eta_i), exergy--energy ratio vectors (phi). Default NULL, case individual matrices vectors can passed C_Y, C_eiou, eta_i, phi. C_Y name column .c_mats_eta_phi_vecs containing allocation matrices final demand (Y C_Y). single C_Y matrix. list C_Y matrices. Default Recca::alloc_cols$C_Y. C_eiou name column .c_mats_eta_phi_vecs containing allocation matrices energy industry use (eiou C_eiou). single C_EIOU matrix. list C_EIOU matrices. Default Recca::alloc_cols$C_eiou. eta_i name column .c_mats_eta_phi_vecs containing machine efficiencies. single eta_i vector. list eta_i vectors. Default Recca::efficiency_cols$eta_i. phi name column .c_mats_eta_phi_vecs containing exergy--energy ratios. single phi vector. Default Recca::psut_cols$phi. matricize boolean tells whether return matrices structure Y U_EIOU last stage final. Default TRUE. FALSE returns column vector rows C_Y C_EIOU. energy_type, energy, exergy See Recca::energy_types. eta_fu base name output columns. Default Recca::efficiency_cols$eta_fu. eta_fu_Y_e name energy efficiency output column energy flowing final demand (Y). Default paste0(eta_fu, \"_Y_\", energy). eta_fu_Y_x name exergy efficiency output column energy flowing final demand (Y). Default paste0(eta_fu, \"_Y_\", exergy). eta_fu_eiou_e name energy efficiency output column energy flowing energy industry (U_EIOU). Default paste0(eta_fu, \"_EIOU_\", energy). eta_fu_eiou_x name exergy efficiency output column energy flowing energy industry (U_EIOU). Default paste0(eta_fu, \"_EIOU_\", energy). notation notation row column labels matrices vectors. Default RCLabels::arrow_notation.","code":""},{"path":"/reference/calc_eta_fu_Y_eiou.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate final-to-useful efficiencies for final demand and EIOU when last stage is final — calc_eta_fu_Y_eiou","text":"data frame list containing final--useful efficiencies.","code":""},{"path":"/reference/calc_eta_fu_Y_eiou.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate final-to-useful efficiencies for final demand and EIOU when last stage is final — calc_eta_fu_Y_eiou","text":"matrix formula calculating energy efficiencies eta_fu_E = C * eta_i, C one C_Y C_EIOU. matrix formula calculating exergy efficiencies allocations machine energy efficiencies eta_fu_X = (phi_u_hat_inv * (C * eta_fu_hat)) * phi_u. C_Y matrix assumed rows named prefixes final energy carriers suffixes final demand sector final energy carrier flows. C_EIOU matrix similar, except rows named suffixes energy industry sector final energy carrier flows. columns C_Y C_EIOU matrices named prefixes machine names suffixes useful energy product made machine. See examples. eta_i vector machine efficiencies rows named prefixes C_Y C_EIOU columns. name eta_i column used. See examples. phi vector exergy--energy ratios rows named energy carriers correspond prefixes C_Y C_EIOU rows suffixes C_Y C_EIOU columns. See examples. function uses matsbyname::vec_from_store_byname() construct eta_i phi vectors multiplying, thereby eliminating unnecessary growth output matrices.","code":""},{"path":"/reference/calc_eta_fu_Y_eiou.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate final-to-useful efficiencies for final demand and EIOU when last stage is final — calc_eta_fu_Y_eiou","text":"","code":"C_Y <- matrix(c(0.7, 0.3, 0,   0,   0,                 0,   0,   0.2, 0.5, 0.3), byrow = TRUE, nrow = 2, ncol = 5,               dimnames = list(c(\"Electricity -> Non-ferrous metals\",                                 \"PSB -> Residential\"),                               c(\"Electric arc furnaces -> HTH.600.C\",                                 \"Electric lights -> L\",                                 \"Wood stoves -> LTH.20.C\",                                 \"Wood stoves -> LTH.50.C\",                                 \"Wood stoves -> MTH.100.C\"))) C_Y #>                                   Electric arc furnaces -> HTH.600.C #> Electricity -> Non-ferrous metals                                0.7 #> PSB -> Residential                                               0.0 #>                                   Electric lights -> L Wood stoves -> LTH.20.C #> Electricity -> Non-ferrous metals                  0.3                     0.0 #> PSB -> Residential                                 0.0                     0.2 #>                                   Wood stoves -> LTH.50.C #> Electricity -> Non-ferrous metals                     0.0 #> PSB -> Residential                                    0.5 #>                                   Wood stoves -> MTH.100.C #> Electricity -> Non-ferrous metals                      0.0 #> PSB -> Residential                                     0.3 eta_i <- matrix(c(0.9, 0.2, 0.4, 0.4, 0.3), nrow = 5, ncol = 1,                   dimnames = list(c(\"Electric arc furnaces -> HTH.600.C\",                                     \"Electric lights -> L\",                                     \"Wood stoves -> LTH.20.C\",                                     \"Wood stoves -> LTH.50.C\",                                     \"Wood stoves -> MTH.100.C\"),                                   \"eta_i\")) eta_i #>                                    eta_i #> Electric arc furnaces -> HTH.600.C   0.9 #> Electric lights -> L                 0.2 #> Wood stoves -> LTH.20.C              0.4 #> Wood stoves -> LTH.50.C              0.4 #> Wood stoves -> MTH.100.C             0.3 phi <- matrix(c(1, 1.1, 1 - 298.15/(600+273.15), 0.95,                 1 - (20 + 273.15)/298.15,                 1 - 298.15/(50+273.15),                 1 - 298.15/(100+273.15)),               nrow = 7, ncol = 1,               dimnames = list(c(\"Electricity\", \"PSB\", \"HTH.600.C\", \"L\",                                 \"LTH.20.C\", \"LTH.50.C\", \"MTH.100.C\"),                               \"phi\")) phi #>                    phi #> Electricity 1.00000000 #> PSB         1.10000000 #> HTH.600.C   0.65853519 #> L           0.95000000 #> LTH.20.C    0.01677008 #> LTH.50.C    0.07736345 #> MTH.100.C   0.20099156 res <- calc_eta_fu_Y_eiou(C_Y = C_Y, C_eiou = C_Y, eta_i = eta_i, phi = phi) res$eta_fu_Y_E #>             Non-ferrous metals Residential #> Electricity               0.69        0.00 #> PSB                       0.00        0.37 res$eta_fu_EIOU_E # Same because C_Y and C_EIOU are same #>             Non-ferrous metals Residential #> Electricity               0.69        0.00 #> PSB                       0.00        0.37 res$eta_fu_Y_X #>             Non-ferrous metals Residential #> Electricity          0.4718772  0.00000000 #> PSB                  0.0000000  0.03173049 res$eta_fu_EIOU_X # Same because C_Y and C_EIOU are same #>             Non-ferrous metals Residential #> Electricity          0.4718772  0.00000000 #> PSB                  0.0000000  0.03173049 res2 <- calc_eta_fu_Y_eiou(C_Y = C_Y, C_eiou = C_Y, eta_i = eta_i, phi = phi,                            matricize = FALSE) res2$eta_fu_Y_E #>                                   eta_fu_Y_E #> Electricity -> Non-ferrous metals       0.69 #> PSB -> Residential                      0.37 #> attr(,\"coltype\") #> [1] \"eta_fu_Y_E\" res2$eta_fu_Y_X #>                                   eta_fu_Y_X #> Electricity -> Non-ferrous metals 0.47187717 #> PSB -> Residential                0.03173049 #> attr(,\"coltype\") #> [1] \"eta_fu_Y_X\""},{"path":"/reference/calc_eta_i.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate industry efficiencies — calc_eta_i","title":"Calculate industry efficiencies — calc_eta_i","text":"Calculates industry efficiencies energy conversion industries ECC. Calculations performed shown Equation 11 Heun, Owen, Brockway. 2018. physical supply-use table framework energy analysis energy conversion chain. Applied Energy, vol 226, pp. 1134-1162.","code":""},{"path":"/reference/calc_eta_i.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate industry efficiencies — calc_eta_i","text":"","code":"calc_eta_i(   .sutmats,   U = Recca::psut_cols$U,   V = Recca::psut_cols$V,   S_units = Recca::psut_cols$S_units,   eta_i = Recca::efficiency_cols$eta_i )"},{"path":"/reference/calc_eta_i.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate industry efficiencies — calc_eta_i","text":".sutmats data frame containing columns U, V, S_units matrices. U string name column U matrices .sutmats. Default Recca::psut_cols$U. V string name column V matrices .sutmats. Default Recca::psut_cols$V. S_units string name column S_units matrices .sutmats. Default Recca::psut_cols$S_units.) eta_i name industry efficiency column output. Default Recca::psut_cols$S_units.","code":""},{"path":"/reference/calc_eta_i.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate industry efficiencies — calc_eta_i","text":".sutmats additional column eta_i","code":""},{"path":"/reference/calc_eta_i.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate industry efficiencies — calc_eta_i","text":"efficiency given industry calculated iff units inputs outputs industry unit-homogeneous. units inputs outputs heterogeneous industry, NA result. Note efficiencies (eta) different final demand sector product efficiencies (eta_s eta_p, respectively). final demand sector product efficiencies (eta_s eta_p) based embodied energy, whereas industry efficiencies (eta) based direct inputs consumed outputs produced energy conversion industry. calculate energy conversion final demand sector product efficiencies, use calc_embodied_etas() function.","code":""},{"path":"/reference/calc_eta_i.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate industry efficiencies — calc_eta_i","text":"","code":"library(tidyr) UKEnergy2000mats %>%   tidyr::spread(key = \"matrix.name\", value = \"matrix\") %>%   calc_eta_i() #> # A tibble: 4 × 13 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 5 more variables: U_feed <list>, V <list>, Y <list>, r_EIOU <list>, #> #   eta_i <list>"},{"path":"/reference/calc_eta_pfd.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate aggregate (total) efficiencies — calc_eta_pfd","title":"Calculate aggregate (total) efficiencies — calc_eta_pfd","text":"Calculates aggregate (total) primary--final demand (gross net) efficiencies across energy conversion chain. .aggregate_df probably formed joining results primary_aggregates() finaldemand_aggregates() calling footprint_aggregates(). See examples.","code":""},{"path":"/reference/calc_eta_pfd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate aggregate (total) efficiencies — calc_eta_pfd","text":"","code":"calc_eta_pfd(   .aggregate_df = NULL,   efficiency_name_suffix = Recca::efficiency_cols$efficiency_name_suffix,   aggregate_primary_colname = Recca::aggregate_cols$aggregate_primary,   gross_aggregate_demand_colname = Recca::aggregate_cols$gross_aggregate_demand,   net_aggregate_demand_colname = Recca::aggregate_cols$net_aggregate_demand,   energy_type = Recca::psut_cols$energy_type,   last_stage = Recca::psut_cols$last_stage,   eta_pfd_gross = Recca::efficiency_cols$eta_pfd_gross,   eta_pfd_net = Recca::efficiency_cols$eta_pfd_net,   eta_pfd_gross_colname = paste0(eta_pfd_gross, efficiency_name_suffix),   eta_pfd_net_colname = paste0(eta_pfd_net, efficiency_name_suffix) )"},{"path":"/reference/calc_eta_pfd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate aggregate (total) efficiencies — calc_eta_pfd","text":".aggregate_df data frame list containing columns aggregate_primary_colname, net_aggregate_demand_colname, gross_aggregate_demand_colname, probably result calling footprint_aggregates(). efficiency_name_suffix suffix efficiency names. Default Recca::efficiency_cols$efficiency_name_suffix. aggregate_primary_colname name column p_aggregates contains primary energy exergy aggregates. Default Recca::aggregate_cols$aggregate_primary. gross_aggregate_demand_colname name column finaldemand_aggregates contains gross final demand aggregates. Default Recca::aggregate_cols$gross_aggregate_demand. net_aggregate_demand_colname name column finaldemand_aggregates contains net final demand aggregates. Default Recca::aggregate_cols$net_aggregate_demand. energy_type name energy type column. Default Recca::psut_cols$energy_type. last_stage name last stage column. Default Recca::psut_cols$last_stage. eta_pfd_gross name output column containing efficiencies converting primary energy gross final demand energy. Default Recca::efficiency_cols$eta_pfd_gross. eta_pfd_net name output column containing efficiencies converting primary energy net final demand energy. Default Recca::efficiency_cols$eta_pfd_net. eta_pfd_gross_colname name output column containing names gross efficiency parameters. Default paste0(eta_pfd_gross, efficiency_name_suffix). eta_pfd_net_colname name output column containing names net efficiency parameters. Default paste0(eta_pfd_net, efficiency_name_suffix).","code":""},{"path":"/reference/calc_eta_pfd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate aggregate (total) efficiencies — calc_eta_pfd","text":"data frame aggregate efficiencies.","code":""},{"path":"/reference/calc_eta_pfd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate aggregate (total) efficiencies — calc_eta_pfd","text":"","code":"wide <- primary_total_aggregates_sut <- UKEnergy2000mats %>%   tidyr::pivot_wider(names_from = matrix.name, values_from = matrix) # Define primary industries p_industries <- c(\"Resources - Crude\", \"Resources - NG\") primary_total_aggregates <- wide %>%   Recca::primary_aggregates(p_industries = p_industries, by = \"Total\") %>%   # Don't need the matrices   dplyr::select(IEATools::iea_cols$country,                 IEATools::iea_cols$year,                 IEATools::iea_cols$energy_type,                 IEATools::iea_cols$last_stage,                 Recca::aggregate_cols$aggregate_primary) # Define final demand sectors fd_sectors <- c(\"Residential\", \"Transport\", \"Oil fields\") finaldemand_total_aggregates <- wide %>%   Recca::finaldemand_aggregates(fd_sectors = fd_sectors, by = \"Total\") %>%   # Don't need the matrices   dplyr::select(IEATools::iea_cols$country,                 IEATools::iea_cols$year,                 IEATools::iea_cols$energy_type,                 IEATools::iea_cols$last_stage,                 Recca::aggregate_cols$gross_aggregate_demand,                 Recca::aggregate_cols$net_aggregate_demand) dplyr::full_join(primary_total_aggregates,                  finaldemand_total_aggregates,                  by = c(IEATools::iea_cols$country,                         IEATools::iea_cols$year,                         IEATools::iea_cols$energy_type,                         IEATools::iea_cols$last_stage)) %>%   calc_eta_pfd() #> # A tibble: 4 × 9 #>   Country  Year Energy.type Last.stage  EX.p EX.fd_gross EX.fd_net eta_pfd_gross #>   <chr>   <dbl> <chr>       <chr>      <dbl>       <dbl>     <dbl>         <dbl> #> 1 GBR      2000 E           Final          0     7.43e 4   7.17e 4           Inf #> 2 GBR      2000 E           Services       0     5.01e14   5.01e14           Inf #> 3 GBR      2000 E           Useful         0     2.60e 4   2.59e 4           Inf #> 4 GBR      2000 X           Services       0     5.01e14   5.01e14           Inf #> # ℹ 1 more variable: eta_pfd_net <dbl>"},{"path":"/reference/calc_io_mats.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate several input-output matrices — calc_io_mats","title":"Calculate several input-output matrices — calc_io_mats","text":"function bundles several others calculates matrices describe structure energy conversion chain.","code":""},{"path":"/reference/calc_io_mats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate several input-output matrices — calc_io_mats","text":"","code":"calc_io_mats(   .sutdata = NULL,   direction = c(\"upstream\", \"demand\", \"Leontief\", \"downstream\", \"supply\", \"Ghosh\"),   method = c(\"solve\", \"QR\", \"SVD\"),   tol = .Machine$double.eps,   method_q_calculation = c(\"sum_U_Y_rows\", \"sum_R_V_cols\"),   R = \"R\",   U = \"U\",   U_feed = \"U_feed\",   V = \"V\",   Y = \"Y\",   S_units = \"S_units\",   y = \"y\",   q = \"q\",   f = \"f\",   g = \"g\",   h = \"h\",   r = \"r\",   W = \"W\",   K = \"K\",   Z = \"Z\",   C = \"C\",   D = \"D\",   A = \"A\",   L_ixp = \"L_ixp\",   L_pxp = \"L_pxp\",   O = \"O\",   Z_feed = \"Z_feed\",   K_feed = \"K_feed\",   A_feed = \"A_feed\",   L_ixp_feed = \"L_ixp_feed\",   L_pxp_feed = \"L_pxp_feed\",   Z_s = \"Z_s\",   C_s = \"C_s\",   D_s = \"D_s\",   D_feed_s = \"D_feed_s\",   B = \"B\",   G_ixp = \"G_ixp\",   G_pxp = \"G_pxp\",   O_s = \"O_s\" )"},{"path":"/reference/calc_io_mats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate several input-output matrices — calc_io_mats","text":".sutdata data frame supply-use table matrices matrices arranged columns. direction string identifies directionality IO matrices. See details. Default \"upstream\". method One \"solve\", \"QR\", \"SVD\". Default \"solve\". See details. tol tolerance detecting linear dependencies matrix inversion. Default .Machine$double.eps. method_q_calculation Specifies method q vector calculated. See details. R resources (R) matrix name column .sutmats contains . Default \"R\". U use (U) matrix name column .sutmats contains . Default \"U\". U_feed feed portion use matrix (U_feed) name column .sutmats contains . Default \"U_feed\". V make (V) matrix name column .sutmatsthat contains . Default \"V\". Y final demand (Y) matrix name column .sutmats contains . Default \"Y\". S_units unit summation matrix (S_units) name column .sutmats contains . Default \"S_units\". y name y vector output. Default \"y\". y calculated rowsums(Y). q name q vector output. Default \"q\". q calculated rowsums(U) + y. f name f vector output. Default \"f\". f calculated colsums(U). g name g vector output. Default \"g\". g calculated rowsums(V). h name h vector output. Default \"h\". h calculated colsums(transpose(R)). r name r vector output. Default \"r\". r calculated rowsums(R). W name W matrix output. Default \"W\". W calculated transpose(V) - U. K name K matrix output. Default \"K\". K calculated U * f_hat_inv. Z name fort Z matrix output. Default \"Z\". Z calculated U * g_hat_inv. C name C matrix output. Default \"C\". C calculated transpose(V) * g_hat_inv. D name D matrix output. Default \"D\". D calculated V * q_hat_inv. name matrix output. Default \"\". calculated Z * D. L_ixp name L_ixp matrix output. Default \"L_ixp\". L_ixp calculated D * L_pxp. L_pxp name L_pxp_feed matrix output. Default \"L_pxp_feed\". L_pxp calculated (- Z*D)^-1. O name O matrix output. Default \"O\". O calculated R * h_hat_inv. Z_feed name Z_feed matrix output. Default \"Z_feed\". Z_feed calculated U_feed * g_hat_inv. K_feed name K_feed matrix output. Default \"K_feed\". K_feed calculated U_feed * f_hat_inv. A_feed name A_feed matrix output. Default \"A_feed\". A_feed calculated Z_feed * D_feed. L_ixp_feed name L_ixp_feed matrix output. Default \"L_ixp_feed\". L_ixp_feed calculated D_feed * L_pxp_feed. L_pxp_feed name L_pxp_feed matrix output. Default \"L_pxp_feed\". L_pxp_feed calculated (- Z_feed*D)^-1. Z_s name Z_s matrix output. Default \"Z_s\". Z_s calculated transpose(V) * f_hat_inv. C_s name C_s matrix output. Default \"C_s\". C_s calculated U * f_hat_inv. D_s name D_s matrix output. Default \"D_s\". D_s calculated transpose(U) * q_hat_inv. D_feed_s name D_feed_s matrix output. Default \"D_feed_s\". D_s calculated transpose(U_feed) * q_hat_inv. B name B matrix output. Default \"B\". B calculated Z_s * D_s. G_ixp name G_ixp matrix output. Default \"G_ixp\". G_ixp calculated D_s * G_pxp. G_pxp name G_pxp matrix output. Default \"G_pxp\". G_pxp calculated inverse(- A_s). O_s name O_s matrix output. Default \"O_s\". O calculated q_hat_inv * Y.","code":""},{"path":"/reference/calc_io_mats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate several input-output matrices — calc_io_mats","text":"list data frame containing input-output matrices.","code":""},{"path":"/reference/calc_io_mats.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate several input-output matrices — calc_io_mats","text":"calculations involve matrix inversion step. method argument specifies method used calculating inverse. See matsbyname::invert_byname(). method_q_calculation specifies method q vector calculated. Default \"sum_U_Y_rows\", corresponding demand-sided view q. Alternatively, analyst can choose use \"sum_R_V_cols\" method, corresponding supply-sided view q. case balanced ECC, method matter. Input-output matrices can calculated either upstream swim (demand-sided Leontief) downstream swim (supply-sided Ghosh). direction argument defines direction. Different IO matrices calculated based direction. default \"upstream\", meaning upstream swim desired. Note \"upstream\", \"demand\", \"Leontief\" synonyms. \"downstream\", \"supply\", \"Ghosh\" synonyms.","code":""},{"path":"/reference/calc_io_mats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate several input-output matrices — calc_io_mats","text":"","code":"library(dplyr) library(tidyr) UKEnergy2000mats %>%   spread(key = matrix.name, value = matrix) %>%   select(Country, Year, Energy.type, Last.stage, U, U_feed, V, Y, r_EIOU, S_units) %>%   calc_io_mats() #> # A tibble: 4 × 30 #>   Country  Year Energy.type Last.stage U              U_feed   V        Y        #>   <chr>   <dbl> <chr>       <chr>      <list>         <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [12 × 9]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl[…]>       <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl[…]>       <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl[…]>       <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 22 more variables: r_EIOU <list>, S_units <list>, y <list>, q <list>, #> #   f <list>, g <list>, h <list>, r <list>, W <list>, Z <list>, K <list>, #> #   C <list>, D <list>, A <list>, O <list>, L_pxp <list>, L_ixp <list>, #> #   Z_feed <list>, K_feed <list>, A_feed <list>, L_pxp_feed <list>, #> #   L_ixp_feed <list>"},{"path":"/reference/calc_mats_locations_excel.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the origin and extent for each matrix — calc_mats_locations_excel","title":"Calculate the origin and extent for each matrix — calc_mats_locations_excel","text":"origin defined upper-left corner matrix worksheet. extent defined lower-right corner matrix worksheet.","code":""},{"path":"/reference/calc_mats_locations_excel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the origin and extent for each matrix — calc_mats_locations_excel","text":"","code":"calc_mats_locations_excel(R, U, V, Y, r_eiou, U_eiou, U_feed, S_units, pad = 2)"},{"path":"/reference/calc_mats_locations_excel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the origin and extent for each matrix — calc_mats_locations_excel","text":"R, U, V, Y, r_eiou, U_eiou, U_feed, S_units Matrices arranged Excel worksheet. pad number blank rows columns matrices.","code":""},{"path":"/reference/calc_mats_locations_excel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the origin and extent for each matrix — calc_mats_locations_excel","text":"nested list origins extents.","code":""},{"path":"/reference/calc_mats_locations_excel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the origin and extent for each matrix — calc_mats_locations_excel","text":"outer structure return value matrices, order provided argument list. inner structure return value list \"origin\" \"extent,\" order. helper function, public.","code":""},{"path":"/reference/calc_yqfgW.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate y, f, g, q, h, and r vectors and the W matrix — calc_yqfgW","title":"Calculate y, f, g, q, h, and r vectors and the W matrix — calc_yqfgW","text":"Note necessary condition calculating f, g, r vectors R_bar, U_bar, V_bar matrices one entry per column row, respectively, meaning products entering given industry need unit homogeneous can calculate f vector products given industry measured units can calculate g vector. unit homogeneity assumptions violated, return NA violating industries f g vectors. checks unit homogeneity performed S_units matrix present.","code":""},{"path":"/reference/calc_yqfgW.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate y, f, g, q, h, and r vectors and the W matrix — calc_yqfgW","text":"","code":"calc_yqfgW(   .sutdata = NULL,   method_q_calculation = c(\"sum_U_Y_rows\", \"sum_R_V_cols\"),   R = \"R\",   U = \"U\",   V = \"V\",   Y = \"Y\",   S_units = \"S_units\",   y = \"y\",   q = \"q\",   f = \"f\",   g = \"g\",   h = \"h\",   r = \"r\",   W = \"W\" )"},{"path":"/reference/calc_yqfgW.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate y, f, g, q, h, and r vectors and the W matrix — calc_yqfgW","text":".sutdata data frame supply-use table matrices matrices arranged columns. method_q_calculation Specifies method q vector calculated. See details. R resources (R) matrix name column .sutmats contains . Default \"R\". U use (U) matrix name column .sutmats contains . Default \"U\". V make (V) matrix name column .sutmats contains . Default \"V\". Y final demand (Y) matrix name column `.sutmats`` contains . Default \"Y\". S_units S_units matrix name column .sutmats contains . Default \"S_units\". y name y vector output. Default \"y\". y calculated rowsums(Y). q name q vector output. Default \"q\". q calculated rowsums(U) + y. f name f vector output. Default \"f\". f calculated colsums(U). g name g vector output. Default \"g\". g calculated rowsums(V). h name h vector output. Default \"h\". h calculated colsums(transpose(R)). r name r vector output. Default \"r\". r calculated rowsums(R). W name W matrix output. Default \"W\". W calculated transpose(V) - U.","code":""},{"path":"/reference/calc_yqfgW.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate y, f, g, q, h, and r vectors and the W matrix — calc_yqfgW","text":"list data frame containing y, q, f, g, h, r vectors W matrix.","code":""},{"path":"/reference/calc_yqfgW.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate y, f, g, q, h, and r vectors and the W matrix — calc_yqfgW","text":"method_q_calculation specifies method q vector calculated. Default \"sum_U_Y_rows\", corresponding demand-sided view q. Alternatively, analyst can choose use \"sum_R_V_cols\" method, corresponding supply-sided view q. case balanced ECC, method matter. methods give column vector result.","code":""},{"path":"/reference/chop-doc.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop the R and Y matrices and swim downstream/upstream — chop-doc","title":"Chop the R and Y matrices and swim downstream/upstream — chop-doc","text":"Chopping resource (R) final demand (Y) matrices involves isolating products industries swimming downstream/upstream identify energy conversion chain (ECC) associated resource final demand category. functions perform calculations.","code":""},{"path":"/reference/chop-doc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop the R and Y matrices and swim downstream/upstream — chop-doc","text":"","code":"chop_Y(   .sut_data = NULL,   calc_pfd_aggs = TRUE,   p_industries = NULL,   fd_sectors = NULL,   piece = \"all\",   notation = RCLabels::notations_list,   pattern_type = c(\"exact\", \"leading\", \"trailing\", \"anywhere\", \"literal\"),   prepositions = RCLabels::prepositions_list,   unnest = FALSE,   method = c(\"solve\", \"QR\", \"SVD\"),   tol_invert = .Machine$double.eps,   tol_chop_sum = 1e-04,   R = Recca::psut_cols$R,   U = Recca::psut_cols$U,   U_feed = Recca::psut_cols$U_feed,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   S_units = Recca::psut_cols$S_units,   chop_df = Recca::aggregate_cols$chop_df,   product_sector = Recca::aggregate_cols$product_sector,   aggregate_primary = Recca::aggregate_cols$aggregate_primary,   net_aggregate_demand = Recca::aggregate_cols$net_aggregate_demand,   gross_aggregate_demand = Recca::aggregate_cols$gross_aggregate_demand,   .prime = \"_prime\",   R_colname = Recca::psut_cols$R,   U_colname = Recca::psut_cols$U,   U_feed_colname = Recca::psut_cols$U_feed,   U_eiou_colname = Recca::psut_cols$U_eiou,   r_eiou_colname = Recca::psut_cols$r_eiou,   V_colname = Recca::psut_cols$V,   Y_colname = Recca::psut_cols$Y,   S_units_colname = Recca::psut_cols$S_units,   R_prime_colname = paste0(R_colname, .prime),   U_prime_colname = paste0(U_colname, .prime),   U_feed_prime_colname = paste0(U_feed_colname, .prime),   U_eiou_prime_colname = paste0(U_eiou_colname, .prime),   r_eiou_prime_colname = paste0(r_eiou_colname, .prime),   V_prime_colname = paste0(V_colname, .prime),   Y_prime_colname = paste0(Y_colname, .prime),   S_units_prime_colname = paste0(S_units_colname, .prime) )  chop_R(   .sut_data = NULL,   calc_pfd_aggs = TRUE,   p_industries = NULL,   fd_sectors = NULL,   piece = \"all\",   notation = RCLabels::notations_list,   pattern_type = c(\"exact\", \"leading\", \"trailing\", \"anywhere\", \"literal\"),   prepositions = RCLabels::prepositions_list,   unnest = FALSE,   method = c(\"solve\", \"QR\", \"SVD\"),   tol_invert = .Machine$double.eps,   tol_chop_sum = 1e-04,   R = Recca::psut_cols$R,   U = Recca::psut_cols$U,   U_feed = Recca::psut_cols$U_feed,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   S_units = Recca::psut_cols$S_units,   chop_df = Recca::aggregate_cols$chop_df,   product_sector = Recca::aggregate_cols$product_sector,   aggregate_primary = Recca::aggregate_cols$aggregate_primary,   net_aggregate_demand = Recca::aggregate_cols$net_aggregate_demand,   gross_aggregate_demand = Recca::aggregate_cols$gross_aggregate_demand,   .prime = \"_prime\",   R_colname = Recca::psut_cols$R,   U_colname = Recca::psut_cols$U,   U_feed_colname = Recca::psut_cols$U_feed,   U_eiou_colname = Recca::psut_cols$U_eiou,   r_eiou_colname = Recca::psut_cols$r_eiou,   V_colname = Recca::psut_cols$V,   Y_colname = Recca::psut_cols$Y,   S_units_colname = Recca::psut_cols$S_units,   R_prime_colname = paste0(R_colname, .prime),   U_prime_colname = paste0(U_colname, .prime),   U_feed_prime_colname = paste0(U_feed_colname, .prime),   U_eiou_prime_colname = paste0(U_eiou_colname, .prime),   r_eiou_prime_colname = paste0(r_eiou_colname, .prime),   V_prime_colname = paste0(V_colname, .prime),   Y_prime_colname = paste0(Y_colname, .prime),   S_units_prime_colname = paste0(S_units_colname, .prime) )"},{"path":"/reference/chop-doc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop the R and Y matrices and swim downstream/upstream — chop-doc","text":".sut_data data frame list physical supply-use table matrices. Default NULL. calc_pfd_aggs boolean tells whether (TRUE) (FALSE) include primary final demand aggregates nested data frame. p_industries vector names industries aggregated \"primary\" used aggregations requested. .sut_data data frame, p_industries name column data frame. .sut_data NULL, p_industries can single vector industry names. industries p_industries appear rows resource (R) make (V) matrices columns final demand matrix (Y). Entries Y_p subtracted entries R_p + V_p obtain total primary energy aggregate, *_p primary part matrices. function find_p_industry_names() might helpful find primary industry names can identified prefixes. argument passed primary_aggregates(). Default NULL. fd_sectors vector names sectors final demand used aggregations requested. Names include columns Y U_EIOU matrices cover net (Y) gross (Y U_EIOU) final demand. argument passed finaldemand_aggregates(). Default NULL. piece, notation, pattern_type, prepositions Arguments passed primary_aggregates() finaldemand_aggregates() , ultimately, matsbyname::select_rowcol_piece_byname() purpose selecting rows columns primary final demand aggregations. See matsbyname::select_rowcol_piece_byname() details. unnest boolean tells whether unnest outgoing data. TRUE, creates new column called product_sector columns primary final demand aggregates. Default FALSE. method One \"solve\", \"QR\", \"SVD\". Default \"solve\". See details. tol_invert tolerance detecting linear dependencies columns inverted matrices. Default .Machine$double.eps. tol_chop_sum allowable deviation 0 difference sum chopped ECCs original ECC. Default 1e-4. R, U, U_feed, V, Y, S_units Matrices describe energy conversion chain (ECC). See Recca::psut_cols default values. chop_df, aggregate_primary, net_aggregate_demand, gross_aggregate_demand Names output columns. See Recca::aggregate_cols. product_sector name output column contains product, industry, sector footprint aggregates given. Default Recca::aggregate_cols$product_sector. .prime string denotes new matrices. string used suffix appended many variable names. Default \"_prime\". R_colname, U_colname, U_feed_colname, U_eiou_colname, r_eiou_colname, V_colname, Y_colname, S_units_colname Names input matrices .sut_data. See Recca::psut_cols default values. R_prime_colname, U_prime_colname, U_feed_prime_colname, U_eiou_prime_colname, r_eiou_prime_colname, V_prime_colname, Y_prime_colname, S_units_prime_colname Names output matrices return value. Default values constructed Recca::psut_cols values suffixed value .prime argument.","code":""},{"path":"/reference/chop-doc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop the R and Y matrices and swim downstream/upstream — chop-doc","text":"Chopped R Y energy conversion chains optional primary final demand aggregates.","code":""},{"path":"/reference/chop-doc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop the R and Y matrices and swim downstream/upstream — chop-doc","text":"Chopping R involves calculating ECC industry row product column R matrix. calculation accomplished description energy conversion chain (ECC) following algorithm: Calculate IO matrices calc_io_mats(). (step prior calling function.) Identify industry product rows columns R matrix. industry product independently, perform downstream swim new_R_ps() obtain ECC induced industry product . Optionally (included default calc_pfd_aggs = TRUE), calculate primary final demand aggregates using primary_aggregates() finaldemand_aggregates(). functions called = \"Total\", yielding total primary final demand aggregates. Add chopped ECCs right side .sut_data nested data frame. calculated, add primary final demand aggregates columns nested data frame. Chopping Y involves calculating ECC individual product row sector column final demand Y matrix. calculation accomplished description ECC following algorithm: Calculate io matrices calc_io_mats(). (step prior calling function.) Identify product sector rows columns Y matrix. product sector independently, perform upstream swim new_Y() obtain ECC requirements supply product sector . Optionally (included default), calculate primary final demand aggregates using primary_aggregates() finaldemand_aggregates(). functions called = \"Total\", yielding total primary final demand aggregates. Add chopped ECCs right side .sut_data nested data frame. calculated, add primary final demand aggregates columns nested data frame. Use unnest argument define aggregate data added right side .sut_data .sut_data matsindf data frame. Note nested data frame includes columns ECC matrices isolated product sector. Optionally, nested data frame includes primary final demand aggregates chopped ECCs. names columns data frame taken *_prime_colname arguments. chop_R() chop_Y() involve downstream upstream swims performed new_R_ps() new_Y() functions. involve matrix inverses. method arguments specify matrix inversion accomplished. tol argument specifies tolerance detecting linearities matrix inverted. See documentation matsbyname::invert_byname() details. tol method single values apply rows .sut_data. chopping swimming performed, original R Y matrix used downstream upstream swim (respectively). error emitted unable reproduce ECC matrices (U, U_feed, U_EIOU, V, Y case downstream swim chopping R; R, U, U_feed, U_EIOU, V case upstream swim chopping Y) within machine precision. R Y matrices chopped rows columns, sum ECCs created chopped rows columns equal original ECC. Internally, functions check sum consistency emits error inconsistencies found.","code":""},{"path":"/reference/chop-doc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop the R and Y matrices and swim downstream/upstream — chop-doc","text":"","code":"p_industries <- c(\"Resources - Crude\", \"Resources - NG\") fd_sectors <- c(\"Residential\", \"Transport\", \"Oil fields\") psut_mats <- UKEnergy2000mats %>%   tidyr::pivot_wider(names_from = matrix.name, values_from = matrix) psut_mats %>%   chop_Y(p_industries = p_industries, fd_sectors = fd_sectors) #> # A tibble: 4 × 13 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 5 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   Chopped.ECCs <list> psut_mats %>%   chop_Y(p_industries = p_industries, fd_sectors = fd_sectors, unnest = TRUE) #> # A tibble: 24 × 24 #>    Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>    <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #>  1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #>  2 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #>  3 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #>  4 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #>  5 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #>  6 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #>  7 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #>  8 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #>  9 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 10 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 14 more rows #> # ℹ 16 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   Product.Industry.Sector <chr>, R_prime <named list>, U_prime <named list>, #> #   U_feed_prime <named list>, U_EIOU_prime <named list>, #> #   r_EIOU_prime <named list>, V_prime <named list>, Y_prime <named list>, #> #   S_units_prime <named list>, EX.p <dbl>, EX.fd_gross <dbl>, EX.fd_net <dbl> psut_mats_2 <- psut_mats %>%   # Slice to avoid the services rows on which NA values are obtained due to unit homogeneity.   dplyr::filter(Last.stage != \"Services\") # Calculate aggregates psut_mats_2 %>%   chop_R(p_industries = p_industries, fd_sectors = fd_sectors) #> # A tibble: 2 × 13 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 5 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   Chopped.ECCs <list> psut_mats_2 %>%   chop_R(p_industries = p_industries, fd_sectors = fd_sectors, unnest = TRUE) #> # A tibble: 8 × 24 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 5 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 6 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 7 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 8 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 16 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   Product.Industry.Sector <chr>, R_prime <named list>, U_prime <named list>, #> #   U_feed_prime <named list>, U_EIOU_prime <named list>, #> #   r_EIOU_prime <named list>, V_prime <named list>, Y_prime <named list>, #> #   S_units_prime <named list>, EX.p <dbl>, EX.fd_gross <dbl>, EX.fd_net <dbl>"},{"path":"/reference/combine_RV.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine resource (R) and make (V) matrices into a make plus resource (R_plus_V) matrix — combine_RV","title":"Combine resource (R) and make (V) matrices into a make plus resource (R_plus_V) matrix — combine_RV","text":"combine_RV inverse separate_RV.","code":""},{"path":"/reference/combine_RV.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine resource (R) and make (V) matrices into a make plus resource (R_plus_V) matrix — combine_RV","text":"","code":"combine_RV(.sutmats = NULL, R = \"R\", V = \"V\", R_plus_V = \"R_plus_V\")"},{"path":"/reference/combine_RV.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine resource (R) and make (V) matrices into a make plus resource (R_plus_V) matrix — combine_RV","text":".sutmats list data frame containing use matrix(ces) make matrix(ces) R R matrix name column .sutmats contains . Default \"R\". V make (V) matrix name column .sutmats contains . Default \"V\". R_plus_V name R_plus_V matrix output. Default \"R_plus_V\".","code":""},{"path":"/reference/combine_RV.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine resource (R) and make (V) matrices into a make plus resource (R_plus_V) matrix — combine_RV","text":"list data frame containing R_plus_V","code":""},{"path":"/reference/combine_RV.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine resource (R) and make (V) matrices into a make plus resource (R_plus_V) matrix — combine_RV","text":"","code":"library(dplyr) library(tidyr) UKEnergy2000mats %>%   spread(key = \"matrix.name\", value = \"matrix\") %>%   combine_RV() #> # A tibble: 4 × 13 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 5 more variables: U_feed <list>, V <list>, Y <list>, r_EIOU <list>, #> #   R_plus_V <list>"},{"path":"/reference/cooling_eu.products.html","id":null,"dir":"Reference","previous_headings":"","what":"A list of Cooling useful work products — cooling_eu.products","title":"A list of Cooling useful work products — cooling_eu.products","text":"list Cooling useful work products","code":""},{"path":"/reference/cooling_eu.products.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A list of Cooling useful work products — cooling_eu.products","text":"","code":"cooling_eu.products"},{"path":"/reference/cooling_eu.products.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A list of Cooling useful work products — cooling_eu.products","text":"list 2 entries. LTC.-10.C useful work product (Eu.product) \"LTC.-10.C\" LTC.20.C useful work product (Eu.product) \"LTC.20.C\"","code":""},{"path":"/reference/data.html","id":null,"dir":"Reference","previous_headings":"","what":"Data pronoun — .data","title":"Data pronoun — .data","text":"See rlang::.data details.","code":""},{"path":"/reference/data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data pronoun — .data","text":"","code":".data"},{"path":"/reference/despecified_aggregates.html","id":null,"dir":"Reference","previous_headings":"","what":"Despecify and aggregate PSUT matrices — despecified_aggregates","title":"Despecify and aggregate PSUT matrices — despecified_aggregates","text":"PSUT matrices often row column names specified contain information simply industry product. Examples include \"Resources [Coal]\" \"Automobiles -> RoP\". sometimes helpful despecify aggregate rows columns \"Resources\" summed together, \"Automobiles\" summed together, etc. function performs aggregation.","code":""},{"path":"/reference/despecified_aggregates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Despecify and aggregate PSUT matrices — despecified_aggregates","text":"","code":"despecified_aggregates(   .sut_data = NULL,   piece_to_keep = \"noun\",   R = Recca::psut_cols$R,   U = Recca::psut_cols$U,   U_feed = Recca::psut_cols$U_feed,   U_eiou = Recca::psut_cols$U_eiou,   r_eiou = Recca::psut_cols$r_eiou,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   S_units = Recca::psut_cols$S_units,   inf_notation = TRUE,   notation = list(RCLabels::notations_list),   margin = list(c(1, 2)),   choose_most_specific = TRUE,   prepositions = list(RCLabels::prepositions_list),   R_aggregated_colname = paste0(Recca::psut_cols$R, aggregated_suffix),   U_aggregated_colname = paste0(Recca::psut_cols$U, aggregated_suffix),   U_feed_aggregated_colname = paste0(Recca::psut_cols$U_feed, aggregated_suffix),   U_eiou_aggregated_colname = paste0(Recca::psut_cols$U_eiou, aggregated_suffix),   r_eiou_aggregated_colname = paste0(Recca::psut_cols$r_eiou, aggregated_suffix),   V_aggregated_colname = paste0(Recca::psut_cols$V, aggregated_suffix),   Y_aggregated_colname = paste0(Recca::psut_cols$Y, aggregated_suffix),   S_units_aggregated_colname = paste0(Recca::psut_cols$S_units, aggregated_suffix),   aggregated_suffix = Recca::aggregate_cols$aggregated_suffix )"},{"path":"/reference/despecified_aggregates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Despecify and aggregate PSUT matrices — despecified_aggregates","text":".sut_data data frame matrices despecified aggregated. piece_to_keep piece label retain aggregation. Default \"noun\". R, U, U_feed, U_eiou, r_eiou, V, Y, S_units Matrices names columns .sut_data despecified aggregated. See Recca::psut_cols. inf_notation boolean tells whether infer row column label notation. Default TRUE. notation notation row column labels. Default list(RCLabels::notations_list). margin margins aggregation performed. Default list(c(1, 2)). choose_most_specific boolean tells whether choose -specific notation 2 notations match. Default TRUE. prepositions list prepositions appear row column names. Default list(RCLabels::prepositions_list). R_aggregated_colname, U_aggregated_colname, U_feed_aggregated_colname, U_eiou_aggregated_colname, r_eiou_aggregated_colname, V_aggregated_colname, Y_aggregated_colname, S_units_aggregated_colname Names aggregated matrices columns. aggregated_suffix string suffix used form names aggregated matrices. Default \"_aggregated\".","code":""},{"path":"/reference/despecified_aggregates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Despecify and aggregate PSUT matrices — despecified_aggregates","text":"modified version .sut_data rows columns matrices aggregated despecified parts.","code":""},{"path":"/reference/despecified_aggregates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Despecify and aggregate PSUT matrices — despecified_aggregates","text":"default, aggregation made nouns row column names defined RCLabels package. piece aggregated given piece_to_keep argument. Internally, function uses matsbyname::aggregate_pieces_byname() heavy lifting.","code":""},{"path":"/reference/despecified_aggregates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Despecify and aggregate PSUT matrices — despecified_aggregates","text":"","code":"UKEnergy2000mats %>%   tidyr::pivot_wider(names_from = matrix.name, values_from = matrix) %>%   despecified_aggregates() #> # A tibble: 4 × 20 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 12 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   R_aggregated <list>, U_aggregated <list>, U_feed_aggregated <list>, #> #   U_EIOU_aggregated <list>, r_EIOU_aggregated <list>, V_aggregated <list>, #> #   Y_aggregated <list>, S_units_aggregated <list>"},{"path":"/reference/edge_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an edge list — edge_list","title":"Create an edge list — edge_list","text":"edge list data frame row describes flow one entity another. Columns edge list data frame , , Value, Product. edge list can created U, V, Y matrices energy conversion chain. Edge lists typical data format visualization software.","code":""},{"path":"/reference/edge_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an edge list — edge_list","text":"","code":"edge_list(   .sutdata = NULL,   R = \"R\",   U = \"U\",   V = \"V\",   Y = \"Y\",   edge_list = \"Edge list\",   from = \"From\",   to = \"To\",   value = \"Value\",   product = \"Product\",   waste = \"Waste\",   rowtypes = \"rowtype\",   coltypes = \"coltype\",   node_id = \"node_id\",   first_node = 0,   edge_id = \"edge_id\",   simplify_edges = TRUE )"},{"path":"/reference/edge_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an edge list — edge_list","text":".sutdata Optionally, data frame containing columns named values U, V, Y arguments. R resource matrix name column .sutdata containing resource matrices. (Default \"R\".) U use matrix name column .sutdata containing use matrices. (Default \"U\".) V make matrix name column .sutdata containing make matrices. (Default \"V\".) Y final demand matrix name column .sutdata containing final demand matrices. (Default \"Y\".) edge_list name column output data frame containing edge lists. name item return list .sutdata specified. (Default \"Edge list\".) name edge list column containing source nodes. (Default \"\".) name edge list column containing destination nodes. (Default \"\".) value name edge list column containing magnitudes flows. (Default \"Value\".) product name edge list column containing product edge list flow. (Default \"Product\".) waste name waste product destination node wastes. Set NULL suppress addition waste edges. (Default \"Waste\".) rowtypes name rowtypes. (Default \"rowtype\".) coltypes name rowtypes. (Default \"coltype\".) node_id base name node ID columns. Set NULL suppress addition node ID numbers. (Default \"node_id\".) first_node first node number. (Default 0.) edge_id name edge ID column. Set NULL suppress addition edge ID numbers. (Default \"edge_id\".) simplify_edges TRUE, products one source node. source product connected directly consumers. FALSE, simplifications made. (Default TRUE.)","code":""},{"path":"/reference/edge_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an edge list — edge_list","text":"edge list column edge lists","code":""},{"path":"/reference/edge_list.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create an edge list — edge_list","text":"Optionally, waste streams can calculated U V matrices added edge list. Optionally, edges can simplified product single source. event, node named product removed, destinations connected sources.","code":""},{"path":"/reference/edge_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an edge list — edge_list","text":"","code":"library(matsbyname) library(tidyr) sutmats <- UKEnergy2000mats %>%   spread(key = matrix.name, value = matrix) # Don't simplify edges and don't include waste edges el_basic <- edge_list(sutmats, simplify_edges = FALSE) head(el_basic$`Edge list`[[1]]) #>                  From           To Value             Product edge_id #> 1  Crude [from Dist.]  Crude dist.   500  Crude [from Dist.]       1 #> 2 Crude [from Fields]  Crude dist. 47500 Crude [from Fields]       2 #> 3 Diesel [from Dist.]  Crude dist.    25 Diesel [from Dist.]       3 #> 4   Elect [from Grid]  Crude dist.    25   Elect [from Grid]       4 #> 5              Diesel Diesel dist. 15500              Diesel       5 #> 6 Diesel [from Dist.] Diesel dist.   350 Diesel [from Dist.]       6 #>   From_node_id To_node_id #> 1            0         14 #> 2            1         14 #> 3            2         14 #> 4            3         14 #> 5            4         17 #> 6            2         17 tail(el_basic$`Edge list`[[1]]) #>                 From    To Value Product edge_id From_node_id To_node_id #> 46 Gas wells & proc. Waste  2075   Waste      46           21         25 #> 47          NG dist. Waste    50   Waste      47           20         25 #> 48        Oil fields Waste  2575   Waste      48           15         25 #> 49    Oil refineries Waste  5075   Waste      49           16         25 #> 50      Petrol dist. Waste   750   Waste      50           22         25 #> 51      Power plants Waste  9700   Waste      51           18         25 # Simplify edges and include waste el <- edge_list(sutmats) head(el$`Edge list`[[1]]) #>                   From             To Value             Product edge_id #> 1 Resources [of Crude]     Oil fields 50000               Crude       1 #> 2          Crude dist.    Crude dist.   500  Crude [from Dist.]       2 #> 3          Crude dist. Oil refineries 47000  Crude [from Dist.]       3 #> 4           Oil fields    Crude dist. 47500 Crude [from Fields]       4 #> 5           Oil fields     Oil fields  2500 Crude [from Fields]       5 #> 6       Oil refineries   Diesel dist. 15500              Diesel       6 #>   From_node_id To_node_id #> 1            0          2 #> 2            1          1 #> 3            1          3 #> 4            2          1 #> 5            2          2 #> 6            3          4 # Now includes waste edges tail(el$`Edge list`[[1]]) #>                 From    To Value Product edge_id From_node_id To_node_id #> 34 Gas wells & proc. Waste  2075   Waste      34            9         13 #> 35          NG dist. Waste    50   Waste      35            8         13 #> 36        Oil fields Waste  2575   Waste      36            2         13 #> 37    Oil refineries Waste  5075   Waste      37            3         13 #> 38      Petrol dist. Waste   750   Waste      38           10         13 #> 39      Power plants Waste  9700   Waste      39            5         13 # Works with single matrices, too. elmats <- edge_list(R = sutmats$R[[1]], U = sutmats$U[[1]], V = sutmats$V[[1]], Y = sutmats$Y[[1]]) head(elmats[[\"Edge list\"]]) #>                   From             To Value             Product edge_id #> 1 Resources [of Crude]     Oil fields 50000               Crude       1 #> 2          Crude dist.    Crude dist.   500  Crude [from Dist.]       2 #> 3          Crude dist. Oil refineries 47000  Crude [from Dist.]       3 #> 4           Oil fields    Crude dist. 47500 Crude [from Fields]       4 #> 5           Oil fields     Oil fields  2500 Crude [from Fields]       5 #> 6       Oil refineries   Diesel dist. 15500              Diesel       6 #>   From_node_id To_node_id #> 1            0          2 #> 2            1          1 #> 3            1          3 #> 4            2          1 #> 5            2          2 #> 6            3          4 tail(elmats[[\"Edge list\"]]) #>                 From    To Value Product edge_id From_node_id To_node_id #> 34 Gas wells & proc. Waste  2075   Waste      34            9         13 #> 35          NG dist. Waste    50   Waste      35            8         13 #> 36        Oil fields Waste  2575   Waste      36            2         13 #> 37    Oil refineries Waste  5075   Waste      37            3         13 #> 38      Petrol dist. Waste   750   Waste      38           10         13 #> 39      Power plants Waste  9700   Waste      39            5         13"},{"path":"/reference/efficiency_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Efficiency data frame column names — efficiency_cols","title":"Efficiency data frame column names — efficiency_cols","text":"string list containing named names columns efficiency data frames. Items list provide default values column name function arguments efficiency functions throughout Recca package.","code":""},{"path":"/reference/efficiency_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Efficiency data frame column names — efficiency_cols","text":"","code":"efficiency_cols"},{"path":"/reference/efficiency_cols.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Efficiency data frame column names — efficiency_cols","text":"string list 14 entries. eta_i name column wide--matrices data frame containing industry efficiencies. eta_pfd_gross name column wide--matrices data frame containing  efficiencies primary gross final demand stages. eta_pfd_net name column wide--matrices data frame containing efficiencies primary net final demand stages. eta_pfd name column wide--matrices data frame containing efficiencies primary final demand stages, regardless net gross. eta_pf string name primary--final efficiency. eta_fu string name final--useful efficiency. eta_pu string name primary--useful efficiency. eta_ps string name primary--services efficiency. eta_fs string name final--services efficiency. eta_us string name useful--services efficiency. efficiency_name_suffix suffix names columns containing efficiency names. gross_net name column contains \"Gross\" \"Net\" type efficiency. gross entry gross_net column identifies gross efficiency. net entry gross_net column identifies net efficiency.","code":""},{"path":"/reference/efficiency_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Efficiency data frame column names — efficiency_cols","text":"","code":"efficiency_cols #> $eta_i #> [1] \"eta_i\" #>  #> $eta_pfd_gross #> [1] \"eta_pfd_gross\" #>  #> $eta_pfd_net #> [1] \"eta_pfd_net\" #>  #> $eta_pfd #> [1] \"eta_pfd\" #>  #> $eta_pf #> [1] \"eta_pf\" #>  #> $eta_fu #> [1] \"eta_fu\" #>  #> $eta_pu #> [1] \"eta_pu\" #>  #> $eta_ps #> [1] \"eta_ps\" #>  #> $eta_fs #> [1] \"eta_fs\" #>  #> $eta_us #> [1] \"eta_us\" #>  #> $efficiency_name_suffix #> [1] \"_name\" #>  #> $gross_net #> [1] \"GrossNet\" #>  #> $gross #> [1] \"Gross\" #>  #> $net #> [1] \"Net\" #>"},{"path":"/reference/energy_types.html","id":null,"dir":"Reference","previous_headings":"","what":"A list of energy types — energy_types","title":"A list of energy types — energy_types","text":"list energy type options \"Energy.type\" column.","code":""},{"path":"/reference/energy_types.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A list of energy types — energy_types","text":"","code":"energy_types"},{"path":"/reference/energy_types.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A list of energy types — energy_types","text":"list 3 entries. energy_type name energy type column, \"Energy.type\". e energy x exergy","code":""},{"path":"/reference/euproduct_aggregation_map.html","id":null,"dir":"Reference","previous_headings":"","what":"A list of Name - Eu.product list combinations — euproduct_aggregation_map","title":"A list of Name - Eu.product list combinations — euproduct_aggregation_map","text":"list Name - Eu.product list combinations use aggregating individual useful work products groups","code":""},{"path":"/reference/euproduct_aggregation_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A list of Name - Eu.product list combinations — euproduct_aggregation_map","text":"","code":"euproduct_aggregation_map"},{"path":"/reference/euproduct_aggregation_map.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A list of Name - Eu.product list combinations — euproduct_aggregation_map","text":"list 10 entries.","code":""},{"path":"/reference/extend_to_exergy.html","id":null,"dir":"Reference","previous_headings":"","what":"Extend an ECC in PSUT format from energy to exergy — extend_to_exergy","title":"Extend an ECC in PSUT format from energy to exergy — extend_to_exergy","text":"energy conversion chain can represented energy exergy quantifications energy. function moves energy quantification exergy quantification, given matrices energy quantification phi (exergy--energy ratio) vectors.","code":""},{"path":"/reference/extend_to_exergy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extend an ECC in PSUT format from energy to exergy — extend_to_exergy","text":"","code":"extend_to_exergy(   .sutmats = NULL,   clean_up_df = TRUE,   R = Recca::psut_cols$R,   U = Recca::psut_cols$U,   U_feed = Recca::psut_cols$U_feed,   U_eiou = Recca::psut_cols$U_eiou,   r_eiou = Recca::psut_cols$r_eiou,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   phi = Recca::psut_cols$phi,   .exergy_suffix = \"_exergy\",   mat_piece = \"all\",   phi_piece = \"all\",   notation = RCLabels::bracket_notation,   prepositions = RCLabels::prepositions_list,   R_name = Recca::psut_cols$R,   U_name = Recca::psut_cols$U,   U_feed_name = Recca::psut_cols$U_feed,   U_eiou_name = Recca::psut_cols$U_eiou,   r_eiou_name = Recca::psut_cols$r_eiou,   V_name = Recca::psut_cols$V,   Y_name = Recca::psut_cols$Y,   phi_name = Recca::psut_cols$phi,   energy_type = Recca::psut_cols$energy_type,   S_units = Recca::psut_cols$S_units,   energy = Recca::energy_types$e,   exergy = Recca::energy_types$x )"},{"path":"/reference/extend_to_exergy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extend an ECC in PSUT format from energy to exergy — extend_to_exergy","text":".sutmats optional data frame energy conversion chain matrices. clean_up_df .sutmats data frame, tells whether tidyr::pivot_longer() result, remove -longer-needed input column phi, fill energy_type column \"X\" exergy versions ECC matrices. Default TRUE. R, U, U_feed, U_eiou, r_eiou, V, Y, phi Names columns .sutmats single matrices. See Recca::psut_cols. .exergy_suffix string suffix appended exergy versions ECC matrices. mat_piece piece matrix row column names R, U, U_feed, U_EIOU, V, Y matrices matched names phi vector. Default \"\", meaning entire names matched. phi_piece piece names phi vector row column names matrices R, U, U_feed, U_EIOU, V, Y matrices matched. Default \"\", meaning entire names matched. notation nomenclature row column labels. Default RCLabels::bracket_notation. prepositions prepositions used row column notation. Default RCLabels::prepositions_list. R_name, U_name, U_feed_name, U_eiou_name, r_eiou_name, V_name, Y_name, phi_name, energy_type, S_units Names output matrices energy, exergy See Recca::energy_types.","code":""},{"path":"/reference/extend_to_exergy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extend an ECC in PSUT format from energy to exergy — extend_to_exergy","text":"data frame list matrices represents exergy version ECC.","code":""},{"path":"/reference/extend_to_exergy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extend an ECC in PSUT format from energy to exergy — extend_to_exergy","text":"Internally, function uses matsindf::apply(), ECC matrices can provided individual matrices, named list, data frame (case arguments given string names columns .sutmats data frame, default). vector phi considered store values applied type energy carrier. determine entry phi vector  matched energy carrier, mat_piece phi_piece consulted. mat_piece phi_piece can \"\", \"pref\", \"suff\", \"noun\", one many prepositions given suffixes","code":""},{"path":"/reference/extend_to_exergy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extend an ECC in PSUT format from energy to exergy — extend_to_exergy","text":"","code":"sutmats <- UKEnergy2000mats %>%   # Put in wide-by-matrix format.   tidyr::spread(key = matrix.name, value = matrix) %>%   # Eliminate services ECCs.   dplyr::filter(Last.stage %in% c(\"Final\", \"Useful\")) %>%   dplyr::mutate(     phi = RCLabels::make_list(Recca::phi_vec, n = nrow(.), lenx = 1)   ) extend_to_exergy(sutmats) #>   Country Year Energy.type Last.stage                  R #> 1     GBR 2000           E      Final 50000, 0, 0, 43000 #> 2     GBR 2000           E     Useful 50000, 0, 0, 43000 #> 3     GBR 2000           X      Final 53000, 0, 0, 44720 #> 4     GBR 2000           X     Useful 53000, 0, 0, 44720 #>                                          S_units #> 1             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 #> 2 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 #> 3             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 #> 4 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 #>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       U #> 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     0, 500, 47500, 0, 25, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 15500, 350, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 25, 43000, 0, 2000, 0, 0, 0, 0, 0, 0, 25, 0, 25, 0, 0, 41000, 0, 0, 50000, 0, 2500, 0, 50, 0, 25, 0, 0, 0, 0, 0, 0, 47000, 0, 5000, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 250, 0, 0, 0, 0, 0, 26500, 500, 0, 0, 0, 0, 0, 0, 100, 0, 16000, 0, 0, 0 #> 2 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 26000.0000, 0.0000, 0.0000, 47500.0000, 0.0000, 0.0000, 0.0000, 25.0000, 20.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 15500.0000, 0.0000, 0.0000, 0.0000, 17.9998, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 6400.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 25000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 50.0000, 0.0000, 25.0000, 0.0000, 43000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 6000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 25.0000, 20.0000, 0.0000, 0.0000, 41000.0000, 0.0000, 0.0000, 50000.0000, 0.0000, 0.0000, 0.0000, 50.0000, 0.0000, 25.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 47000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 75.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 26.9997, 0.0000, 0.0000, 0.0000, 26500.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 100.0000, 0.0000, 0.0000, 16000.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 15050.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 #> 3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          0.0, 530.0, 50350.0, 0.0, 26.5, 0.0, 25.0, 0.0, NA, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 16430.0, 371.0, 0.0, 0.0, 0.0, NA, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6400.0, 0.0, 0.0, NA, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 53.0, 0.0, 25.0, 44720.0, NA, 2080.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 26.5, 0.0, 25.0, 0.0, NA, 42640.0, 0.0, 0.0, 53000.0, 0.0, 2650.0, 0.0, 53.0, 0.0, 25.0, 0.0, NA, 0.0, 0.0, 0.0, 0.0, 49820.0, 0.0, 5300.0, 0.0, 0.0, 75.0, 0.0, NA, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 265.0, 0.0, 0.0, 0.0, NA, 0.0, 28090.0, 530.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 100.0, 0.0, NA, 0.0, 0.0, 0.0 #> 4                                                             0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, NA, 0.0000, 0.0000, 27560.0000, 0.0000, 0.0000, 50350.0000, 0.0000, 0.0000, 0.0000, 25.0000, 20.0000, 0.0000, NA, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 16430.0000, 0.0000, 0.0000, 0.0000, 17.9998, 0.0000, NA, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 6400.0000, 0.0000, 0.0000, 0.0000, NA, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, NA, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 53.0000, 0.0000, 25.0000, 0.0000, 44720.0000, NA, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 6000.0000, 0.0000, 0.0000, NA, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 25.0000, 20.0000, 0.0000, NA, 42640.0000, 0.0000, 0.0000, 53000.0000, 0.0000, 0.0000, 0.0000, 53.0000, 0.0000, 25.0000, 0.0000, 0.0000, NA, 0.0000, 0.0000, 0.0000, 0.0000, 49820.0000, 0.0000, 0.0000, 0.0000, 0.0000, 75.0000, 0.0000, 0.0000, NA, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 26.9997, 0.0000, NA, 0.0000, 28090.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 100.0000, 0.0000, 0.0000, NA, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 15953.0000, 0.0000, 0.0000, 0.0000, 0.0000, NA, 0.0000, 0.0000, 0.0000 #>                                                                                                                                                                                                                                                                                                               U_EIOU #> 1                                                                                                                 500, 0, 0, 25, 25, 0, 0, 0, 0, 0, 350, 0, 0, 0, 0, 0, 0, 50, 25, 2000, 0, 0, 0, 0, 25, 25, 0, 0, 0, 2500, 0, 50, 25, 0, 0, 0, 0, 5000, 0, 75, 0, 0, 0, 0, 0, 250, 0, 0, 500, 0, 0, 0, 0, 100, 0, 0 #> 2                                                                                                        0.0000, 25.0000, 20.0000, 0.0000, 0.0000, 17.9998, 50.0000, 25.0000, 0.0000, 0.0000, 25.0000, 20.0000, 50.0000, 25.0000, 0.0000, 0.0000, 75.0000, 0.0000, 0.0000, 0.0000, 26.9997, 0.0000, 100.0000, 0.0000 #> 3 530.0, 0.0, 0.0, 26.5, 25.0, 0.0, 0.0, 0.0, 0.0, 0.0, 371.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 53.0, 25.0, 2080.0, 0.0, 0.0, 0.0, 0.0, 26.5, 25.0, 0.0, 0.0, 0.0, 2650.0, 0.0, 53.0, 25.0, 0.0, 0.0, 0.0, 0.0, 5300.0, 0.0, 75.0, 0.0, 0.0, 0.0, 0.0, 0.0, 265.0, 0.0, 0.0, 530.0, 0.0, 0.0, 0.0, 0.0, 100.0, 0.0, 0.0 #> 4                                                                                                        0.0000, 25.0000, 20.0000, 0.0000, 0.0000, 17.9998, 53.0000, 25.0000, 0.0000, 0.0000, 25.0000, 20.0000, 53.0000, 25.0000, 0.0000, 0.0000, 75.0000, 0.0000, 0.0000, 0.0000, 26.9997, 0.0000, 100.0000, 0.0000 #>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      U_feed #> 1                                                                                                                                                                                                                                                      0, 0, 47500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41000, 0, 50000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26500, 0, 0, 0, 0, 0, 0, 16000, 0, 0 #> 2      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26000, 0, 0, 47500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41000, 0, 0, 50000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16000, 0, 0, 0, 0, 0, 0, 0, 15050, 0, 0, 0, 0, 0, 0, 0 #> 3                                                                                                                                                                                                                                                 0, 0, 50350, 0, 0, 0, NA, 0, 0, 0, 0, 0, 16430, 0, 0, NA, 0, 0, 0, 0, 0, 0, 6400, 0, NA, 0, 0, 0, 0, 0, 0, 0, 44720, NA, 0, 0, 0, 0, 0, 0, 0, 0, NA, 42640, 0, 53000, 0, 0, 0, 0, 0, NA, 0, 0, 0, 49820, 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, NA, 0, 28090, 0, 0, 0, 0, 0, 0, NA, 0, 0 #> 4 0, 0, 0, 0, 0, 0, 0, 0, NA, 0, 0, 27560, 0, 0, 50350, 0, 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 16430, 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 6400, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44720, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6000, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, 42640, 0, 0, 53000, 0, 0, 0, 0, 0, 0, 0, NA, 0, 0, 0, 0, 49820, 0, 0, 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, 0, 28090, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 15953, 0, 0, 0, NA, 0, 0, 0 #>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       V #> 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    47500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20500, 0, 0, 0, 15500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6400, 0, 0, 6275, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41000, 0, 0, 0, 0, 0, 0, 0, 43000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26500, 0 #> 2 0.00, 47000.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 47500.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 15500.00, 0.00, 0.00, 0.00, 0.00, 0.00, 15150.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 6400.00, 0.00, 0.00, 0.00, 0.00, 6275.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 1200.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 20000.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 3000.40, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 1799.98, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 41000.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 41000.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 26500.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 26000.00, 0.00, 0.00 #> 3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               50350, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21730, 0, 0, 0, 16430, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6400, 0, 0, 6275, 0, 0, 0, 0, 0, 0, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0, 0, 0, 44720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28090, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28090, 0 #> 4                                0.00, 49820.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 50350.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 16430.00, 0.00, 0.00, 0.00, 0.00, 0.00, 16059.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 6400.00, 0.00, 0.00, 0.00, 0.00, 6275.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 1023.40, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 1147.20, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 3000.40, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 1799.98, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.00, 0.00, 0.00, 0.00, 0.00, 42640.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 28090.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 27560.00, 0.00, 0.00 #>                                                             Y #> 1                       0, 6000, 25000, 0, 14750, 0, 0, 26000 #> 2 1200.00, 0.00, 3000.40, 0.00, 0.00, 20000.00, 0.00, 1714.98 #> 3                         0, 6000, NA, 0, 15635, 0, NA, 27560 #> 4  0.00, 1147.20, 3000.40, 0.00, 1023.40, 0.00, 0.00, 1714.98 #>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   r_EIOU #> 1                                                                                                                                                                                                     0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 #> 2              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 #> 3                                                                                                                                                                                            0, 1, 0, 0, 1, 0, 1, 0, NA, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, NA, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, NA, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, NA, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, NA, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, NA, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, NA, 0, 0, 0 #> 4 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, NA, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, 0, 0, 0"},{"path":"/reference/finaldemand_aggregates.html","id":null,"dir":"Reference","previous_headings":"","what":"Final demand energy and exergy aggregates — finaldemand_aggregates","title":"Final demand energy and exergy aggregates — finaldemand_aggregates","text":"Calculates aggregate final demand energy data frame Supply-Use matrices. calculation counts fd_sectors final demand aggregates. .sutdata NULL, fd_sectors can single vector industry names.","code":""},{"path":"/reference/finaldemand_aggregates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Final demand energy and exergy aggregates — finaldemand_aggregates","text":"","code":"finaldemand_aggregates(   .sutdata = NULL,   fd_sectors,   piece = \"all\",   notation = RCLabels::notations_list,   pattern_type = c(\"exact\", \"leading\", \"trailing\", \"anywhere\", \"literal\"),   prepositions = RCLabels::prepositions_list,   U_eiou = Recca::psut_cols$U_eiou,   Y = Recca::psut_cols$Y,   by = c(\"Total\", \"Product\", \"Sector\", \"Industry\"),   net_aggregate_demand = Recca::aggregate_cols$net_aggregate_demand,   gross_aggregate_demand = Recca::aggregate_cols$gross_aggregate_demand )"},{"path":"/reference/finaldemand_aggregates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Final demand energy and exergy aggregates — finaldemand_aggregates","text":".sutdata data frame columns matrices supply-use analysis. fd_sectors vector names sectors final demand. Names include columns Y U_EIOU matrices cover net (Y) gross (Y U_EIOU) final demand. piece, notation, pattern_type, prepositions Arguments control way row column matching accomplished selecting parts U_EIOU Y matrices final demand aggregation. arguments passed matsbyname::select_rowcol_piece_byname() eventually RCLabels::match_by_pattern() RCLabels::make_or_pattern(). Default values piece = \"\", notation = RCLabels::notations_list, pattern_type = \"exact\", prepositions = RCLabels::prepositions_list. U_eiou, Y Input matrices. See Recca::psut_cols. One \"Product\", \"Sector\", \"Total\" indicate desired aggregation: \"Product\" aggregation energy carrier (Crude oil, Primary solid biofuels, etc.), \"Sector\" aggregation final demand sector (Agriculture/forestry, Domestic navigation, etc.), \"Total\" aggregation Product Sector (default). net_aggregate_demand, gross_aggregate_demand See Recca::aggregate_cols. Defaults Recca::aggregate_cols$net_aggregate_demand Recca::aggregate_cols$gross_aggregate_demand.","code":""},{"path":"/reference/finaldemand_aggregates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Final demand energy and exergy aggregates — finaldemand_aggregates","text":"list data frame containing net_aggregate_demand gross_aggregate_demand columns.","code":""},{"path":"/reference/finaldemand_aggregates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Final demand energy and exergy aggregates — finaldemand_aggregates","text":"Net energy demand calculated matsbyname::sum_byname(Y_fd), sums across rows, columns, total needed. Gross energy demand calculated matsbyname::sum_byname(Y_fd) + matsbyname::sum_byname(U_EIOU), sums across rows, columns, total needed.","code":""},{"path":"/reference/finaldemand_aggregates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Final demand energy and exergy aggregates — finaldemand_aggregates","text":"","code":"library(matsbyname) UKEnergy2000mats %>%   tidyr::pivot_wider(names_from = \"matrix.name\", values_from = \"matrix\") %>%   dplyr::mutate(     fd_sectors = rep(list(c(\"Residential\", \"Transport\")), times = nrow(.))   ) %>%   dplyr::filter(Last.stage %in% c(IEATools::last_stages$final,                                   IEATools::last_stages$useful)) %>%   finaldemand_aggregates(fd_sectors = \"fd_sectors\", by = \"Sector\") #> Error in finaldemand_aggregates(., fd_sectors = \"fd_sectors\", by = \"Sector\"): unused arguments (fd_sectors = \"fd_sectors\", by = \"Sector\")"},{"path":"/reference/finaldemand_aggregates_with_units.html","id":null,"dir":"Reference","previous_headings":"","what":"Final demand energy and exergy aggregates with units — finaldemand_aggregates_with_units","title":"Final demand energy and exergy aggregates with units — finaldemand_aggregates_with_units","text":"Calculates aggregate final demand energy services data frame Supply-Use matrices. calculation includes non-energy uses present final demand matrix. calculation include balancing items (Losses Statistical differences). .sutdata data frame, fd_sectors name column data frame. .sutdata NULL, fd_sectors can single vector industry names.","code":""},{"path":"/reference/finaldemand_aggregates_with_units.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Final demand energy and exergy aggregates with units — finaldemand_aggregates_with_units","text":"","code":"finaldemand_aggregates_with_units(   .sutdata,   fd_sectors,   pattern_type = c(\"exact\", \"leading\", \"trailing\", \"anywhere\"),   U = Recca::psut_cols$U,   Y = Recca::psut_cols$Y,   r_EIOU = Recca::psut_cols$r_eiou,   S_units = Recca::psut_cols$S_units,   by = c(\"Total\", \"Product\", \"Sector\"),   net_aggregate_demand = Recca::aggregate_cols$net_aggregate_demand,   gross_aggregate_demand = Recca::aggregate_cols$gross_aggregate_demand )"},{"path":"/reference/finaldemand_aggregates_with_units.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Final demand energy and exergy aggregates with units — finaldemand_aggregates_with_units","text":".sutdata data frame columns matrices supply-use analysis. fd_sectors vector names sectors final demand. Names include columns Y U_EIOU matrices cover net (Y) gross (Y U_EIOU) final demand. pattern_type One \"exact\", \"leading\", \"trailing\", \"anywhere\" specifies matches made fd_sectors. \"exact\", exact matches specify sectors aggregated. \"leading\", sectors aggregated entry fd_sectors matches leading part final demand sector's name. \"trailing\", sectors aggregated entry fd_sectors matches trailing part final demand sector's name. \"anywhere\", sectors aggregated entry fd_sectors matches part final demand sector's name. Default \"exact\". U Use (U) matrix name column .sutdata containing . Y Final demand (Y) matrix name column .sutdata containing . r_EIOU Matrix ratios EIOU make (U) matrix name column .sutdata containing . S_units name column .sutdata containing S_units matrices. One \"Product\", \"Sector\", \"Total\" indicate desired aggregation: \"Product\" aggregation energy carrier (Crude oil, Primary solid biofuels, etc.), \"Sector\" aggregation final demand sector (Agriculture/forestry, Domestic navigation, etc.), \"Total\" aggregation Product Sector (default). net_aggregate_demand name net energy demand (excludes energy industry use) output. gross_aggregate_demand name gross energy demand (includes energy industry use) output.","code":""},{"path":"/reference/finaldemand_aggregates_with_units.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Final demand energy and exergy aggregates with units — finaldemand_aggregates_with_units","text":"list data frame containing net aggregate energy demand gross aggregate energy demand.","code":""},{"path":"/reference/find_p_industry_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Scrape primary industry names from R, V, and Y matrices — find_p_industry_names","title":"Scrape primary industry names from R, V, and Y matrices — find_p_industry_names","text":"Primary industry names needed aggregation. function interrogates row names R V column names Y matrices names start p_industries. assumption many row column names may compound names form \"Resources [Oil gas extraction]\". function looks leading strings. \"Resources\" p_industries, \"Resources [Oil gas extraction]\" among returned strings.","code":""},{"path":"/reference/find_p_industry_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scrape primary industry names from R, V, and Y matrices — find_p_industry_names","text":"","code":"find_p_industry_names(   .sutdata = NULL,   p_industry_prefixes = Recca::industry_cols$p_industry_prefixes,   R = Recca::psut_cols$R,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   p_industries_complete = Recca::industry_cols$p_industries_complete )"},{"path":"/reference/find_p_industry_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scrape primary industry names from R, V, and Y matrices — find_p_industry_names","text":".sutdata optional data frame containing columns PSUT matrices p_industry_prefixes name column .sutdata containing vectors prefixes identify primary industry names, vector prefixes identify primary industry names. Default Recca::industry_cols$p_industry_prefixes. Hint: IEATools::tpes_flows contains good list primary industry prefixes. R name R matrix column .sutdata R matrix. V name V matrix column .sutdata V matrix. Y name Y matrix column .sutdata Y matrix. p_industries_complete name output column containing complete names primary industries. Default Recca::industry_cols$p_industries_complete.","code":""},{"path":"/reference/find_p_industry_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scrape primary industry names from R, V, and Y matrices — find_p_industry_names","text":".sutdata data frame, data frame additional column p_industries_complete. .sutdata list named matrices (R, V, Y), vector vectors full names primary industries R, V, Y matrices, list primary industries.","code":""},{"path":"/reference/find_p_industry_names.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scrape primary industry names from R, V, and Y matrices — find_p_industry_names","text":"Note R, V, Y need specified.","code":""},{"path":"/reference/find_p_industry_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scrape primary industry names from R, V, and Y matrices — find_p_industry_names","text":"","code":"Rrows <- c(\"Resources [of Oil and gas extraction]\", \"Resources [of Coal mines]\") R <- matrix(c(1, 0,               0, 2), nrow = 2, byrow = TRUE,             dimnames = list(Rrows, c(\"Crude oil\", \"Brown coal\"))) Vrows <- c(\"Imports [of Crude oil]\", \"Stock changes [of Bituminous coal]\") V <- matrix(c(3, 0,               0, 4), nrow = 2, byrow = TRUE,             dimnames = list(Vrows, c(\"Crude oil\", \"Bituminous coal\"))) Ycols <- c(\"Exports [of Electricity]\", \"International marine bunkers [of Gas/diesel oil]\") Y <- matrix(c(5, 0,               0, 6), nrow = 2, byrow = TRUE,             dimnames = list(c(\"Electricity\", \"Gas/diesel oil\"), Ycols)) p_industry_prefixes <- c(\"Resources\", \"Imports\", \"Exports\",                          \"Stock changes\", \"International marine bunkers\") # This function works with individual matrices, so long as they are # first wrapped in `list()`. find_p_industry_names(p_industry_prefixes = list(p_industry_prefixes),                       R = list(R), V = list(V), Y = list(Y)) #> $p_industries_complete #> [1] \"Resources [of Oil and gas extraction]\"            #> [2] \"Resources [of Coal mines]\"                        #> [3] \"Imports [of Crude oil]\"                           #> [4] \"Stock changes [of Bituminous coal]\"               #> [5] \"Exports [of Electricity]\"                         #> [6] \"International marine bunkers [of Gas/diesel oil]\" #>  # Also works in the context of a data frame. # Use a `tibble`, because it handles matrices better res <- tibble::tibble(R = list(R,R), V = list(V,V), Y = list(Y,Y),                      p_industries = list(p_industry_prefixes, \"Resources\")) %>%  find_p_industry_names(p_industry_prefixes = \"p_industries\") res$p_industries_complete[[1]] #> [1] \"Resources [of Oil and gas extraction]\"            #> [2] \"Resources [of Coal mines]\"                        #> [3] \"Imports [of Crude oil]\"                           #> [4] \"Stock changes [of Bituminous coal]\"               #> [5] \"Exports [of Electricity]\"                         #> [6] \"International marine bunkers [of Gas/diesel oil]\" res$p_industries_complete[[2]] #> [1] \"Resources [of Oil and gas extraction]\" #> [2] \"Resources [of Coal mines]\""},{"path":"/reference/flows_unit_homogeneous.html","id":null,"dir":"Reference","previous_headings":"","what":"Tell whether industry flows (inputs and outputs) are unit-homogeneous — flows_unit_homogeneous","title":"Tell whether industry flows (inputs and outputs) are unit-homogeneous — flows_unit_homogeneous","text":"Returns TRUE industry's flows (inputs outputs) unit-homogeneous.","code":""},{"path":"/reference/flows_unit_homogeneous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tell whether industry flows (inputs and outputs) are unit-homogeneous — flows_unit_homogeneous","text":"","code":"flows_unit_homogeneous(   .sutmats = NULL,   U = \"U\",   V = \"V\",   S_units = \"S_units\",   keep_details = FALSE,   flows_unit_homogeneous = \".flows_unit_homogeneous\" )"},{"path":"/reference/flows_unit_homogeneous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tell whether industry flows (inputs and outputs) are unit-homogeneous — flows_unit_homogeneous","text":".sutmats data frame supply-use table matrices matrices arranged columns. U use (U) matrix name column .sutmats contains . Default \"U\". V make (V) matrix name column .sutmats contains . Default \"V\". S_units S_units matrix name column .sutmats contains . Default \"S_units\". keep_details TRUE, per-industry results returned; FALSE, per-ECC results returned. Default \"FALSE\". flows_unit_homogeneous name output column tells whether industry's outputs unit-homogeneous. Default \".flows_unit_homogeneous\".","code":""},{"path":"/reference/flows_unit_homogeneous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tell whether industry flows (inputs and outputs) are unit-homogeneous — flows_unit_homogeneous","text":".sutdata additional column \"flows_unit_homogeneous\" containing TRUE industry's flows unit-homogeneous, FALSE industry's flows unit-heterogeneous.","code":""},{"path":"/reference/flows_unit_homogeneous.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tell whether industry flows (inputs and outputs) are unit-homogeneous — flows_unit_homogeneous","text":"V_bar matrix queried number non-zero entries row. number non-zero entries row exactly 1, industry outputs unit-homogeneous. Note V_bar = matrixproduct_byname(V, S_units).","code":""},{"path":"/reference/flows_unit_homogeneous.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tell whether industry flows (inputs and outputs) are unit-homogeneous — flows_unit_homogeneous","text":"","code":"library(tidyr) UKEnergy2000mats %>%   spread(key = \"matrix.name\", value = \"matrix\") %>%   flows_unit_homogeneous() #> # A tibble: 4 × 13 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 5 more variables: U_feed <list>, V <list>, Y <list>, r_EIOU <list>, #> #   .flows_unit_homogeneous <lgl>"},{"path":"/reference/get_all_products_and_industries.html","id":null,"dir":"Reference","previous_headings":"","what":"Create lists of all products and industries — get_all_products_and_industries","title":"Create lists of all products and industries — get_all_products_and_industries","text":"matrices describe energy conversion chain (R, U, V, Y), create list unique products (energy carriers) industries (processing stages) energy conversion chain.","code":""},{"path":"/reference/get_all_products_and_industries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create lists of all products and industries — get_all_products_and_industries","text":"","code":"get_all_products_and_industries(   .sutdata,   piece = \"all\",   inf_notation = TRUE,   notation = list(RCLabels::notations_list),   choose_most_specific = FALSE,   prepositions = list(RCLabels::prepositions_list),   R = IEATools::psut_cols$R,   U = IEATools::psut_cols$U,   V = IEATools::psut_cols$V,   Y = IEATools::psut_cols$Y,   products_col = Recca::prod_ind_names_colnames$product_names,   industries_col = Recca::prod_ind_names_colnames$industry_names )"},{"path":"/reference/get_all_products_and_industries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create lists of all products and industries — get_all_products_and_industries","text":".sutdata data frame list matsindf matrices. piece character string indicating piece row column names retain, one \"\", \"noun\", \"pps\", \"pref\" \"suff\", preposition, indicating part row column name retained. Default \"\". inf_notation boolean tells whether infer notation. Default TRUE. notation notation used row column labels. Default list(RCLabels::notations_list). default value wrapped list, RCLabels::notations_list , , list. See RCLabels. choose_most_specific boolean indicates whether -specific notation inferred one notation matches row column label allow_multiple = FALSE. FALSE, first matching notation notations returned allow_multiple = FALSE. Default FALSE. prepositions Prepositions can used row column label. Default RCLabels::prepositions_list. R, U, V, Y names PSUT matrices. See IEAtools::psut_cols. products_col name products column output list data frame. Default Recca::prod_ind_names_colnames$product_names. industries_col name products column output list data frame. Default Recca::prod_ind_names_colnames$industry_names.","code":""},{"path":"/reference/get_all_products_and_industries.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create lists of all products and industries — get_all_products_and_industries","text":".sutdata two new columns containing names products industries.","code":""},{"path":"/reference/get_all_products_and_industries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create lists of all products and industries — get_all_products_and_industries","text":"function matsindf::matsindf_apply() style function. can accept matsindf data frame .df argument string R, U, V, Y (column names) arguments.","code":""},{"path":"/reference/get_all_products_and_industries.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create lists of all products and industries — get_all_products_and_industries","text":"","code":"ecc <- UKEnergy2000mats %>%   tidyr::pivot_wider(names_from = \"matrix.name\", values_from = \"matrix\") %>%   get_all_products_and_industries() # Show all unique product (energy carrier) names in the first row of ecc ecc[[Recca::prod_ind_names_colnames$product_names]][[1]] #>  [1] \"Crude\"               \"NG\"                  \"Crude [from Dist.]\"  #>  [4] \"Crude [from Fields]\" \"Diesel\"              \"Diesel [from Dist.]\" #>  [7] \"Elect\"               \"Elect [from Grid]\"   \"NG [from Dist.]\"     #> [10] \"NG [from Wells]\"     \"Petrol\"              \"Petrol [from Dist.]\" # Show all unique industry (processing stage) names # in the fourth row of ecc. ecc[[Recca::prod_ind_names_colnames$industry_names]][[4]] #>  [1] \"Resources [of Crude]\" \"Resources [of NG]\"    \"Car engines\"          #>  [4] \"Cars\"                 \"Crude dist.\"          \"Diesel dist.\"         #>  [7] \"Elect. grid\"          \"Furnaces\"             \"Gas wells & proc.\"    #> [10] \"Homes\"                \"Light fixtures\"       \"NG dist.\"             #> [13] \"Oil fields\"           \"Oil refineries\"       \"Petrol dist.\"         #> [16] \"Power plants\"         \"Rooms\"                \"Truck engines\"        #> [19] \"Trucks\"               \"Residential\"          \"Transport\""},{"path":"/reference/grouped_aggregates.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform grouping aggregations on PSUT matrices — grouped_aggregates","title":"Perform grouping aggregations on PSUT matrices — grouped_aggregates","text":"often helpful aggregate data industry product categories, \"Anthracite\" \"Brown coal\" \"Coal coal products\" \"Domestic aviation\" \"Domestic navigation\" \"Transport\". help aggregation_map, function performs aggregations set PSUT matrices.","code":""},{"path":"/reference/grouped_aggregates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform grouping aggregations on PSUT matrices — grouped_aggregates","text":"","code":"grouped_aggregates(   .sut_data = NULL,   aggregation_map,   margin = c(1, 2),   pattern_type = \"exact\",   R = Recca::psut_cols$R,   U = Recca::psut_cols$U,   U_feed = Recca::psut_cols$U_feed,   U_eiou = Recca::psut_cols$U_eiou,   r_eiou = Recca::psut_cols$r_eiou,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   S_units = Recca::psut_cols$S_units,   R_aggregated_colname = paste0(Recca::psut_cols$R, aggregated_suffix),   U_aggregated_colname = paste0(Recca::psut_cols$U, aggregated_suffix),   U_feed_aggregated_colname = paste0(Recca::psut_cols$U_feed, aggregated_suffix),   U_eiou_aggregated_colname = paste0(Recca::psut_cols$U_eiou, aggregated_suffix),   r_eiou_aggregated_colname = paste0(Recca::psut_cols$r_eiou, aggregated_suffix),   V_aggregated_colname = paste0(Recca::psut_cols$V, aggregated_suffix),   Y_aggregated_colname = paste0(Recca::psut_cols$Y, aggregated_suffix),   S_units_aggregated_colname = paste0(Recca::psut_cols$S_units, aggregated_suffix),   aggregated_suffix = Recca::aggregate_cols$aggregated_suffix )"},{"path":"/reference/grouped_aggregates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform grouping aggregations on PSUT matrices — grouped_aggregates","text":".sut_data data frame matrices despecified aggregated. aggregation_map Aggregation details. See documentation matsbyname::aggregate_byname() information. margin 1, 2, c(1, 2) row aggregation, column aggregation, . Can row column type. Default c(1, 2). pattern_type See RCLabels::make_or_pattern(). Default \"exact\". R, U, U_feed, U_eiou, r_eiou, V, Y, S_units Matrices names columns .sut_data despecified aggregated. See Recca::psut_cols. R_aggregated_colname, U_aggregated_colname, U_feed_aggregated_colname, U_eiou_aggregated_colname, r_eiou_aggregated_colname, V_aggregated_colname, Y_aggregated_colname, S_units_aggregated_colname Names aggregated matrices columns. aggregated_suffix string suffix used form names aggregated matrices. Default \"_aggregated\".","code":""},{"path":"/reference/grouped_aggregates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform grouping aggregations on PSUT matrices — grouped_aggregates","text":"PSUT matrices aggregated according aggregation_map.","code":""},{"path":"/reference/grouped_aggregates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform grouping aggregations on PSUT matrices — grouped_aggregates","text":"Internally, function uses matsbyname::aggregate_byname(). See documentation details format aggregation_map.","code":""},{"path":"/reference/grouped_aggregates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform grouping aggregations on PSUT matrices — grouped_aggregates","text":"","code":"UKEnergy2000mats %>%   tidyr::pivot_wider(names_from = matrix.name, values_from = matrix) %>%   grouped_aggregates(aggregation_map = list(`Oil and oil products` =                                             c(\"Crude\", \"Diesel\", \"Petrol\")),                      pattern_type = \"leading\",                      margin = \"Product\") #> # A tibble: 4 × 20 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 12 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   R_aggregated <list>, U_aggregated <list>, U_feed_aggregated <list>, #> #   U_EIOU_aggregated <list>, r_EIOU_aggregated <list>, V_aggregated <list>, #> #   Y_aggregated <list>, S_units_aggregated <list>"},{"path":"/reference/hpm_eu.products.html","id":null,"dir":"Reference","previous_headings":"","what":"A list of High pressure matter (HPM) useful work products — hpm_eu.products","title":"A list of High pressure matter (HPM) useful work products — hpm_eu.products","text":"list High pressure matter (HPM) useful work products.","code":""},{"path":"/reference/hpm_eu.products.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A list of High pressure matter (HPM) useful work products — hpm_eu.products","text":"","code":"hpm_eu.products"},{"path":"/reference/hpm_eu.products.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A list of High pressure matter (HPM) useful work products — hpm_eu.products","text":"list 3 entries. HPA useful work product (Eu.product) \"High pressure air\" HPL useful work product (Eu.product) \"High pressure liquids\" HPNG useful work product (Eu.product) \"High pressure natural gas\"","code":""},{"path":"/reference/hth_eu.products.html","id":null,"dir":"Reference","previous_headings":"","what":"A list of High temperature heat (HTH) useful work products — hth_eu.products","title":"A list of High temperature heat (HTH) useful work products — hth_eu.products","text":"list High temperature heat (HTH) useful work products","code":""},{"path":"/reference/hth_eu.products.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A list of High temperature heat (HTH) useful work products — hth_eu.products","text":"","code":"hth_eu.products"},{"path":"/reference/hth_eu.products.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A list of High temperature heat (HTH) useful work products — hth_eu.products","text":"list 7 entries. HTH.400.C useful work product (Eu.product) \"HTH.400.C\" HTH.600.C useful work product (Eu.product) \"HTH.600.C\" HTH.850.C useful work product (Eu.product) \"HTH.850.C\" HTH.960.C useful work product (Eu.product) \"HTH.960.C\" HTH.1000.C useful work product (Eu.product) \"HTH.1000.C\" HTH.1300.C useful work product (Eu.product) \"HTH.1300.C\" HTH.1600.C useful work product (Eu.product) \"HTH.1600.C\"","code":""},{"path":"/reference/industry_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Primary industry column names — industry_cols","title":"Primary industry column names — industry_cols","text":"string list containing named names columns SUT data frames. Items list provide default values column name function arguments throughout Recca package.","code":""},{"path":"/reference/industry_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primary industry column names — industry_cols","text":"","code":"industry_cols"},{"path":"/reference/industry_cols.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Primary industry column names — industry_cols","text":"string list 2 entries. p_industries_prefixes name column wide--matrices data frame containing prefixes names primary industries. p_industries_complete name column wide--matrices data frame containing complete names primary industries.","code":""},{"path":"/reference/industry_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primary industry column names — industry_cols","text":"","code":"industry_cols #> $p_industry_prefixes #> [1] \"p_industry_prefixes\" #>  #> $p_industries_complete #> [1] \"p_industries_complete\" #>"},{"path":"/reference/inputs_outputs_unit_homogeneous.html","id":null,"dir":"Reference","previous_headings":"","what":"Tell whether industry inputs are unit-homogeneous and industry outputs are unit-homogeneous — inputs_outputs_unit_homogeneous","title":"Tell whether industry inputs are unit-homogeneous and industry outputs are unit-homogeneous — inputs_outputs_unit_homogeneous","text":"Returns TRUE industry's inputs unit-homogeneous industry's outputs unit homogeneous. inputs different units outputs, (inputs unit-homogeneous outputs unit-homogeneous), TRUE returned.","code":""},{"path":"/reference/inputs_outputs_unit_homogeneous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tell whether industry inputs are unit-homogeneous and industry outputs are unit-homogeneous — inputs_outputs_unit_homogeneous","text":"","code":"inputs_outputs_unit_homogeneous(   .sutmats = NULL,   U = \"U\",   V = \"V\",   S_units = \"S_units\",   keep_details = FALSE,   ins_outs_unit_homogeneous = \".inputs_outputs_unit_homogeneous\" )"},{"path":"/reference/inputs_outputs_unit_homogeneous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tell whether industry inputs are unit-homogeneous and industry outputs are unit-homogeneous — inputs_outputs_unit_homogeneous","text":".sutmats data frame supply-use table matrices matrices arranged columns. U use (U) matrix name column .sutmats contains . Default \"U\". V make (V) matrix name column .sutmats contains . Default \"V\". S_units S_units matrix name column .sutmats contains . Default \"S_units\". keep_details TRUE, per-industry results returned; FALSE, per-ECC results returned. ins_outs_unit_homogeneous name output column tells whether industry's inputs outputs unit-homogeneous (though necessarily units). Default \".inputs_outputs_unit_homogeneous\".","code":""},{"path":"/reference/inputs_outputs_unit_homogeneous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tell whether industry inputs are unit-homogeneous and industry outputs are unit-homogeneous — inputs_outputs_unit_homogeneous","text":"list data frame containing TRUE inputs energy conversion industry unit-homogeneous outputs energy conversion industry unit-homogeneous, FALSE otherwise.","code":""},{"path":"/reference/inputs_outputs_unit_homogeneous.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tell whether industry inputs are unit-homogeneous and industry outputs are unit-homogeneous — inputs_outputs_unit_homogeneous","text":"function uses inputs_unit_homogeneous outputs_unit_homogeneous internally. function differs flows_unit_homogeneous, flows_unit_homogeneous requires flows unit-homogeneous returning TRUE. function (inputs_outputs_unit_homogeneous) return true inputs unit-homogeneous different units outputs (also unit-homogeoenous).","code":""},{"path":[]},{"path":"/reference/inputs_outputs_unit_homogeneous.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tell whether industry inputs are unit-homogeneous and industry outputs are unit-homogeneous — inputs_outputs_unit_homogeneous","text":"","code":"library(tidyr) result <- UKEnergy2000mats %>%   spread(key = \"matrix.name\", value = \"matrix\") %>%   inputs_outputs_unit_homogeneous()"},{"path":"/reference/inputs_unit_homogeneous.html","id":null,"dir":"Reference","previous_headings":"","what":"Tell whether each industry's inputs are unit-homogeneous — inputs_unit_homogeneous","title":"Tell whether each industry's inputs are unit-homogeneous — inputs_unit_homogeneous","text":"Returns TRUE industry's inputs unit-homogeneous.","code":""},{"path":"/reference/inputs_unit_homogeneous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tell whether each industry's inputs are unit-homogeneous — inputs_unit_homogeneous","text":"","code":"inputs_unit_homogeneous(   .sutmats = NULL,   U = \"U\",   S_units = \"S_units\",   keep_details = FALSE,   ins_unit_homogeneous = \".inputs_unit_homogeneous\" )"},{"path":"/reference/inputs_unit_homogeneous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tell whether each industry's inputs are unit-homogeneous — inputs_unit_homogeneous","text":".sutmats data frame supply-use table matrices matrices arranged columns. U use (U) matrix name column .sutmats contains . Default \"U\". S_units S_units matrix name column .sutmats contains . Default \"S_units\". keep_details TRUE, per-product results returned; FALSE, per-ECC results returned. Default FALSE. ins_unit_homogeneous name output boolean tells whether industry's inputs unit-homogeneous. Default \".inputs_unit_homogeneous\".","code":""},{"path":"/reference/inputs_unit_homogeneous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tell whether each industry's inputs are unit-homogeneous — inputs_unit_homogeneous","text":"list data frame containing TRUE inputs energy conversion industry unit-homogeneous, FALSE otherwise.","code":""},{"path":"/reference/inputs_unit_homogeneous.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tell whether each industry's inputs are unit-homogeneous — inputs_unit_homogeneous","text":"U_bar matrix queried number non-zero entries column. number non-zero entries column exactly 1, industry inputs unit-homogeneous. Note U_bar = matrixproduct_byname(transpose_byname(S_units), U).","code":""},{"path":"/reference/inputs_unit_homogeneous.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tell whether each industry's inputs are unit-homogeneous — inputs_unit_homogeneous","text":"","code":"library(tidyr) UKEnergy2000mats %>%   spread(key = \"matrix.name\", value = \"matrix\") %>%   inputs_unit_homogeneous() #> # A tibble: 4 × 13 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 5 more variables: U_feed <list>, V <list>, Y <list>, r_EIOU <list>, #> #   .inputs_unit_homogeneous <lgl>"},{"path":"/reference/ip_eu.products.html","id":null,"dir":"Reference","previous_headings":"","what":"A list of Information processing useful work products — ip_eu.products","title":"A list of Information processing useful work products — ip_eu.products","text":"list Information processing useful work products","code":""},{"path":"/reference/ip_eu.products.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A list of Information processing useful work products — ip_eu.products","text":"","code":"ip_eu.products"},{"path":"/reference/ip_eu.products.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A list of Information processing useful work products — ip_eu.products","text":"list 1 entries. IP useful work product (Eu.product) Information processing","code":""},{"path":"/reference/l_eu.products.html","id":null,"dir":"Reference","previous_headings":"","what":"A list of Light useful work products — l_eu.products","title":"A list of Light useful work products — l_eu.products","text":"list Light useful work products","code":""},{"path":"/reference/l_eu.products.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A list of Light useful work products — l_eu.products","text":"","code":"l_eu.products"},{"path":"/reference/l_eu.products.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A list of Light useful work products — l_eu.products","text":"list 1 entries. L useful work product (Eu.product) Light","code":""},{"path":"/reference/lth_eu.products.html","id":null,"dir":"Reference","previous_headings":"","what":"A list of Low temperature heat (LTH) useful work products — lth_eu.products","title":"A list of Low temperature heat (LTH) useful work products — lth_eu.products","text":"list Low temperature heat (LTH) useful work products","code":""},{"path":"/reference/lth_eu.products.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A list of Low temperature heat (LTH) useful work products — lth_eu.products","text":"","code":"lth_eu.products"},{"path":"/reference/lth_eu.products.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A list of Low temperature heat (LTH) useful work products — lth_eu.products","text":"list 2 entries. LTH.20.C useful work product (Eu.product) \"LTH.20.C\" LTH.60.C useful work product (Eu.product) \"LTH.60.C\"","code":""},{"path":"/reference/make_sankey.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a Sankey diagram — make_sankey","title":"Make a Sankey diagram — make_sankey","text":"Sankey diagram flow diagram width lines proportional rate energy flow. Sankey diagrams helpful way visualize energy flows energy conversion chain (ECC). function takes matrix description ECC produces Sankey diagram.","code":""},{"path":"/reference/make_sankey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a Sankey diagram — make_sankey","text":"","code":"make_sankey(   .sutmats = NULL,   R = Recca::psut_cols$R,   U = Recca::psut_cols$U,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   simplify_edges = TRUE,   sankey = Recca::sankey_cols$sankey,   ... )"},{"path":"/reference/make_sankey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a Sankey diagram — make_sankey","text":".sutmats optional wide--matrices data frame R, U, V, Y See Recca::psut_cols. simplify_edges boolean tells whether edges simplified. Applies every row .sutmats .sutmats specified. sankey See Recca::sankey_cols. ... Arguments passed networkD3::sankeyNetwork(), mostly formatting purposes.","code":""},{"path":"/reference/make_sankey.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a Sankey diagram — make_sankey","text":"Sankey diagram","code":""},{"path":"/reference/make_sankey.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make a Sankey diagram — make_sankey","text":"present, function uses networkD3 package draw Sankey diagram. R, U, V, Y NA, NA returned.","code":""},{"path":"/reference/make_sankey.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a Sankey diagram — make_sankey","text":"","code":"library(dplyr) library(magrittr) #>  #> Attaching package: ‘magrittr’ #> The following object is masked from ‘package:tidyr’: #>  #>     extract #> The following objects are masked from ‘package:testthat’: #>  #>     equals, is_less_than, not library(networkD3) library(tidyr) UKEnergy2000mats %>%   spread(key = \"matrix.name\", value = \"matrix\") %>%   make_sankey() %>%   extract2(\"Sankey\") %>%   extract2(1)  {\"x\":{\"links\":{\"source\":[0,1,1,2,2,3,3,4,4,4,4,4,4,4,5,6,6,6,6,6,6,6,7,8,8,9,9,3,10,10,1,4,6,9,8,2,3,10,5],\"target\":[2,1,3,1,2,4,3,1,4,9,8,2,10,11,6,1,9,8,2,3,5,12,9,5,12,9,8,10,10,11,13,13,13,13,13,13,13,13,13],\"value\":[50000,500,47000,47500,2500,15500,5000,25,350,50,25,50,250,14750,6400,25,25,25,25,75,100,6000,43000,16000,25000,2000,41000,26500,500,26000,550,350,125,2075,50,2575,5075,750,9700]},\"nodes\":{\"name\":[\"Resources [of Crude]\",\"Crude dist.\",\"Oil fields\",\"Oil refineries\",\"Diesel dist.\",\"Power plants\",\"Elect. grid\",\"Resources [of NG]\",\"NG dist.\",\"Gas wells & proc.\",\"Petrol dist.\",\"Transport\",\"Residential\",\"Waste\"],\"group\":[\"Resources [of Crude]\",\"Crude dist.\",\"Oil fields\",\"Oil refineries\",\"Diesel dist.\",\"Power plants\",\"Elect. grid\",\"Resources [of NG]\",\"NG dist.\",\"Gas wells & proc.\",\"Petrol dist.\",\"Transport\",\"Residential\",\"Waste\"]},\"options\":{\"NodeID\":\"Node\",\"NodeGroup\":\"Node\",\"LinkGroup\":null,\"colourScale\":\"d3.scaleOrdinal(d3.schemeCategory20);\",\"fontSize\":7,\"fontFamily\":null,\"nodeWidth\":15,\"nodePadding\":10,\"units\":\"\",\"margin\":{\"top\":null,\"right\":null,\"bottom\":null,\"left\":null},\"iterations\":32,\"sinksRight\":true}},\"evals\":[],\"jsHooks\":[]}"},{"path":"/reference/mechanical_eu.products.html","id":null,"dir":"Reference","previous_headings":"","what":"A list of Mechanical useful work products — mechanical_eu.products","title":"A list of Mechanical useful work products — mechanical_eu.products","text":"list Mechanical useful work products","code":""},{"path":"/reference/mechanical_eu.products.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A list of Mechanical useful work products — mechanical_eu.products","text":"","code":"mechanical_eu.products"},{"path":"/reference/mechanical_eu.products.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A list of Mechanical useful work products — mechanical_eu.products","text":"list 4 entries. MD useful work product (Eu.product) Mechanical drive KE useful work product (Eu.product) Kinetic energy MW useful work product (Eu.product) Mechanical work MF useful work product (Eu.product) Material fracture","code":""},{"path":"/reference/mth_eu.products.html","id":null,"dir":"Reference","previous_headings":"","what":"A list of Medium temperature heat (MTH) useful work products — mth_eu.products","title":"A list of Medium temperature heat (MTH) useful work products — mth_eu.products","text":"list Medium temperature heat (MTH) useful work products","code":""},{"path":"/reference/mth_eu.products.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A list of Medium temperature heat (MTH) useful work products — mth_eu.products","text":"","code":"mth_eu.products"},{"path":"/reference/mth_eu.products.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A list of Medium temperature heat (MTH) useful work products — mth_eu.products","text":"list 2 entries. MTH.100.C useful work product (Eu.product) \"MTH.100.C\" MTH.200.C useful work product (Eu.product) \"MTH.200.C\"","code":""},{"path":"/reference/neu_eu.products.html","id":null,"dir":"Reference","previous_headings":"","what":"A list of Non-energy use useful work products — neu_eu.products","title":"A list of Non-energy use useful work products — neu_eu.products","text":"list Non-energy use useful work products","code":""},{"path":"/reference/neu_eu.products.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A list of Non-energy use useful work products — neu_eu.products","text":"","code":"neu_eu.products"},{"path":"/reference/neu_eu.products.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A list of Non-energy use useful work products — neu_eu.products","text":"list 1 entries. NEU useful work product (Eu.product) Non-energy use","code":""},{"path":"/reference/new_R_ps.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates downstream effects of a new level of extracted resources — new_R_ps","title":"Calculates downstream effects of a new level of extracted resources — new_R_ps","text":"function calculates effect changing resources available ECC, .e. new resources matrix R_prime rest ECC matrices (U, V, W, Y). New versions U, V, W, Y matrices returned, respectively called U_prime, V_prime, W_prime, Y_prime. function assumes industry's inputs perfectly substitutable (ps).","code":""},{"path":"/reference/new_R_ps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates downstream effects of a new level of extracted resources — new_R_ps","text":"","code":"new_R_ps(   .sutmats = NULL,   method = c(\"solve\", \"QR\", \"SVD\"),   tol = .Machine$double.eps,   R_prime = \"R_prime\",   U = \"U\",   U_feed = \"U_feed\",   V = \"V\",   Y = \"Y\",   q = \"q\",   f = \"f\",   G_pxp = \"G_pxp\",   G_ixp = \"G_ixp\",   O_s = \"O_s\",   D_s = \"D_s\",   D_feed_s = \"D_feed_s\",   Z_s = \"Z_s\",   U_prime = \"U_prime\",   U_feed_prime = \"U_feed_prime\",   U_eiou_prime = \"U_EIOU_prime\",   r_eiou_prime = \"r_EIOU_prime\",   V_prime = \"V_prime\",   Y_prime = \"Y_prime\" )"},{"path":"/reference/new_R_ps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates downstream effects of a new level of extracted resources — new_R_ps","text":".sutmats data frame supply-use table matrices matrices arranged columns. method One \"solve\", \"QR\", \"SVD\". Default \"solve\". See details. tol tolerance detecting linear dependencies matrix inversion. Default .Machine$double.eps. R_prime name new R matrix column input data frame, new ECC must assessed. Default \"R_prime\". U name U matrix column input data frame. Default \"U\". U_feed name U_feed matrix column input data frame. Default \"U_feed\". V name V matrix column input data frame. Default \"V\". Y name Y matrix column input data frame. Default \"Y\". q name q vector column input data frame. Default \"q\". f name f vector column input data frame. Default \"f\". G_pxp name G_pxp matrix column input data frame. Default \"G_pxp\". G_ixp name G_ixp matrix column input data frame. Default \"G_ixp\". O_s name O_s matrix column input data frame. Default \"O_s\", \"_s\" indicates supply-sided. D_s name D_s matrix column input data frame. Default \"D_s\", \"_s\" indicates supply-sided. D_feed_s name D_feed_s matrix column input data frame. Default \"D_feed_s\", \"_s\" indicates supply-sided. Z_s name Z_s matrix column input data frame. Default \"Z_s\", \"_s\" indicates supply-sided. U_prime name output column containing new U matrices. Default \"U_prime\". U_feed_prime name output column containing new U_feed matrices. Default \"U_feed_prime\". U_eiou_prime name output column containing new U_EIOU matrices. Default \"U_EIOU_prime\". r_eiou_prime name output column containing new r_EIOU matrices. Default \"r_EIOU_prime\". V_prime name output column containing new V matrices. Default \"V_prime\". Y_prime name output column containing new Y matrices. Default \"Y_prime\".","code":""},{"path":"/reference/new_R_ps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates downstream effects of a new level of extracted resources — new_R_ps","text":"data frame added columns representing new U_prime, U_feed_prime, U_EIOU_prime, r_EIOU_prime, V_prime, Y_prime matrices.","code":""},{"path":"/reference/new_R_ps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates downstream effects of a new level of extracted resources — new_R_ps","text":"industry must unit-homogeneous inputs. , matrix populated NA returned result U_prime, V_prime, Y_prime. Calculating new matrices requires matrix inversion operation. method argument specifies method used calculating inverse. \"solve\" uses base::solve() value tol. \"QR\" uses base::solve.qr() value tol. \"SVD\" uses matrixcalc::svd.inverse(), ignoring tol argument. tol method single values apply matrices .","code":""},{"path":"/reference/new_R_ps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates downstream effects of a new level of extracted resources — new_R_ps","text":"","code":"UKEnergy2000mats %>%   tidyr::spread(key = \"matrix.name\", value = \"matrix\") %>%   # When Last.stage is \"services\", we get units problems.   # Avoid by using only ECCs with \"Final\" and \"Useful\" as the Last.stage.   dplyr::filter(Last.stage != IEATools::last_stages$services) %>%   # Calculate the input-output matrices which are inputs to the new_R function.   calc_io_mats(direction = \"downstream\") %>%   # Make an R_prime matrix that gives twice the resource inputs to the economy.   dplyr::mutate(     R_prime = matsbyname::hadamardproduct_byname(2, R)   ) %>%   # Now call new_R_ps() which will calculate   # updated U, V, and Y matrices (U_prime, V_prime, and Y_prime)   # given R_prime.   # Each of the *_prime matrices should be 2x their originals,   # because R_prime is 2x relative to R.   new_R_ps() #> # A tibble: 2 × 34 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 26 more variables: U_feed <list>, V <list>, Y <list>, r_EIOU <list>, #> #   y <list>, q <list>, f <list>, g <list>, h <list>, r <list>, W <list>, #> #   Z_s <list>, C_s <list>, D_s <list>, D_feed_s <list>, O_s <list>, B <list>, #> #   G_pxp <list>, G_ixp <list>, R_prime <list>, U_prime <list>, #> #   U_feed_prime <list>, U_EIOU_prime <list>, r_EIOU_prime <list>, #> #   V_prime <list>, Y_prime <list>"},{"path":"/reference/new_Y.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconstruct an economy given a new final demand matrix — new_Y","title":"Reconstruct an economy given a new final demand matrix — new_Y","text":"final demand matrix changes Y Y_prime, function calculates new resource (R_prime), use (U_prime), feed (U_feed), energy industry use (U_eiou), ratio (r_eiou), make (V_prime) matrices required meet new final demand (Y_prime).","code":""},{"path":"/reference/new_Y.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconstruct an economy given a new final demand matrix — new_Y","text":"","code":"new_Y(   .sutmats = NULL,   Y_prime = \"Y_prime\",   L_ixp = \"L_ixp\",   L_pxp = \"L_pxp\",   Z = \"Z\",   Z_feed = \"Z_feed\",   D = \"D\",   O = \"O\",   R_prime = \"R_prime\",   U_prime = \"U_prime\",   U_feed_prime = \"U_feed_prime\",   U_eiou_prime = \"U_EIOU_prime\",   r_eiou_prime = \"r_EIOU_prime\",   V_prime = \"V_prime\" )"},{"path":"/reference/new_Y.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconstruct an economy given a new final demand matrix — new_Y","text":".sutmats data frame supply-use table matrices matrices arranged columns. Y_prime new final demand matrix name column .sutmats containing . Default \"Y_prime\". L_ixp, L_pxp, Z, Z_feed, D, O Input matrices describe structure energy conversion chain. Values can string names (default) columns data frame .sutmats names items list .sutmats R_prime, U_prime, U_feed_prime, U_eiou_prime, r_eiou_prime, V_prime new names new matrices. Defaults argument name string.","code":""},{"path":"/reference/new_Y.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconstruct an economy given a new final demand matrix — new_Y","text":"list data frame containing R_prime, U_prime, U_feed, U_eiou, r_eiou, V_prime matrices.","code":""},{"path":"/reference/new_Y.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reconstruct an economy given a new final demand matrix — new_Y","text":"Note inputs L_ixp, L_pxp, Z, D can conveniently calculated function calc_io_mats(). Internally, function uses matsindf::matsindf_apply(), documentation assumes .sutmats NULL data frame. .sutmats can also named list matrices. matrices can supplied individually Y_prime, L_ixp, L_pxp, Z, Z_feed, D, O arguments. .sutmats present, output data frame columns named string values output arguments, input arguments character strings name columns .sutmats. .sutmats NULL (default), output list items named output strings, input arguments single matrices vectors.","code":""},{"path":"/reference/new_Y.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reconstruct an economy given a new final demand matrix — new_Y","text":"","code":"library(dplyr) library(matsbyname) library(tidyr) UKEnergy2000mats %>%   spread(key = matrix.name, value = matrix) %>%   select(Country, Year, Energy.type, Last.stage, R, U, U_feed, V, Y, r_EIOU, S_units) %>%   calc_io_mats() %>%   mutate(     # Give new Y matrices that are double the existing Y matrices     Y_prime = matsbyname::hadamardproduct_byname(2, Y)   ) %>%   # Should give U_prime and V_prime matrices that are double the existing U and V matrices   new_Y() #> # A tibble: 4 × 38 #>   Country  Year Energy.type Last.stage R             U        U_feed   V        #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 30 more variables: Y <list>, r_EIOU <list>, S_units <list>, y <list>, #> #   q <list>, f <list>, g <list>, h <list>, r <list>, W <list>, Z <list>, #> #   K <list>, C <list>, D <list>, A <list>, O <list>, L_pxp <list>, #> #   L_ixp <list>, Z_feed <list>, K_feed <list>, A_feed <list>, #> #   L_pxp_feed <list>, L_ixp_feed <list>, Y_prime <list>, R_prime <list>, #> #   U_prime <list>, U_feed_prime <list>, U_EIOU_prime <list>, #> #   r_EIOU_prime <list>, V_prime <list>"},{"path":"/reference/new_k_ps.html","id":null,"dir":"Reference","previous_headings":"","what":"Assess the effect of changing perfectly substitutable intermediate inputs to an industry — new_k_ps","title":"Assess the effect of changing perfectly substitutable intermediate inputs to an industry — new_k_ps","text":"function calculates effect changing perfectly-substitutable (ps) inputs intermediate industry. New versions U V matrices returned U_prime V_prime. Changes made upstream changed industry inputs. final demand matrix (Y) unchanged.","code":""},{"path":"/reference/new_k_ps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assess the effect of changing perfectly substitutable intermediate inputs to an industry — new_k_ps","text":"","code":"new_k_ps(   .sutmats = NULL,   k_prime = \"k_prime\",   R = \"R\",   U = \"U\",   V = \"V\",   Y = \"Y\",   K = \"K\",   L_ixp = \"L_ixp\",   L_pxp = \"L_pxp\",   Z = \"Z\",   D = \"D\",   f = \"f\",   R_prime = \"R_prime\",   U_prime = \"U_prime\",   V_prime = \"V_prime\" )"},{"path":"/reference/new_k_ps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assess the effect of changing perfectly substitutable intermediate inputs to an industry — new_k_ps","text":".sutmats data frame supply-use table matrices matrices arranged columns. k_prime new column vector K matrix representing new inputs industry name column .sutmats containing . Default \"k_prime\". name single k_prime column must match name one columns matrix K. R resource (R) matrix name column .sutmats contains . Default \"R\". U use (U) matrix name column .sutmats contains . Default \"U\". V make (V) matrix name column .sutmatsthat contains . Default \"V\". Y final demand (Y) matrix name column .sutmats contains . Default \"Y\". K K matrix name column .sutmats contains . Default \"K\". K consists columns sum 1. Elements K indicate fraction total input industries (columns) provided products (rows). K can calculated calc_io_mats(). L_ixp (L_ixp) matrix name column .sutmats contains . Default \"L_ixp\". L_pxp (L_pxp) matrix name column .sutmats contains . Default \"L_pxp\". Z Z matrix name column .sutmats contains . Default \"Z\". D D matrix name column .sutmats contains . Default \"D\". f f vector name column sutmats contains . Default \"f\". R_prime name R_prime matrix output. Default \"R_prime\". U_prime name U_prime matrix output. Default \"U_prime\". V_prime name V_prime matrix output. Default \"V_prime\".","code":""},{"path":"/reference/new_k_ps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assess the effect of changing perfectly substitutable intermediate inputs to an industry — new_k_ps","text":"list data frame containing U_prime V_prime matrices","code":""},{"path":"/reference/new_k_ps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assess the effect of changing perfectly substitutable intermediate inputs to an industry — new_k_ps","text":"Note inputs K, L_ixp, L_pxp, Z, D, f can conveniently calculated function calc_io_mats(). Internally, function uses matsindf::matsindf_apply(), documentation assumes .sutmats NULL data frame. .sutmats present, output data frame columns named string values output arguments, input arguments character strings name columns .sutmats. .sutmats NULL (default), output list items named output strings, input arguments single matrices vectors.","code":""},{"path":"/reference/new_k_ps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assess the effect of changing perfectly substitutable intermediate inputs to an industry — new_k_ps","text":"","code":"library(dplyr) library(matsbyname) library(tidyr) # To demonstrate calculating changes to an energy conversion chain due to changes # in perfectly-substitutable inputs to an intermediate industry, # we use the PerfectSubmats data frame. # But we need to calculate several important input-output matrices first. io_mats <- PerfectSubmats %>%   tidyr::spread(key = \"matrix.name\", value = \"matrix\") %>%   calc_io_mats() # Next, find the K matrix that contains the fraction of each type of energy # that enters each industry K <- io_mats$K[[1]] # Develop a new column vector for inputs to the Electric transport sector. # As provided, the Electric transport sector is dominated by Renewable elec. # What if the electricity input to the Electric transport sector # were split 50/50 between Renewable elect and FF elec? k_prime_vec <- K[, \"Electric transport\", drop = FALSE] k_prime_vec[\"FF elec\", \"Electric transport\"] <- 0.5 k_prime_vec[\"Ren elec\", \"Electric transport\"] <- 0.5 # Add k_prime_vec to the io_mats data frame. io_mats <- io_mats %>%   dplyr::mutate(     # Set up a new k_prime vector for Electric transport.     # That vector will be used for the infininte substitution calculation.     k_prime = matsbyname::select_cols_byname(K,            retain_pattern = RCLabels::make_or_pattern(\"Electric transport\",                                                       pattern_type = \"exact\")),     k_prime = RCLabels::make_list(k_prime_vec, n = 1)   ) # Now do the calculation of U_prime and V_prime matrices. new_UV <- new_k_ps(io_mats) # There is much more FF extraction now than before. io_mats$U[[1]][\"FF\", \"FF extraction\"] #> [1] 87 new_UV$U_prime[[1]][\"FF\", \"FF extraction\"] #> [1] 101.8523"},{"path":"/reference/node_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a node list — node_list","title":"Create a node list — node_list","text":"node list data frame containing node names associated node ID numbers (integers). function creates node list edge list, shown examples.","code":""},{"path":"/reference/node_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a node list — node_list","text":"","code":"node_list(   edge_list,   from = \"From\",   to = \"To\",   node = \"Node\",   node_id = \"node_id\" )"},{"path":"/reference/node_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a node list — node_list","text":"edge_list name column .sutmats containing edge lists single edge list data frame. (Default \"Edge list\".) name edge_list column containing names source nodes. (Default \"\".) name edge_list column containing names destination nodes. (Default \"\".) node name output column containing node names. (Default \"Node\".) node_id name output column containing node ID numbers. (Default \"node_id\".)","code":""},{"path":"/reference/node_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a node list — node_list","text":"node list","code":""},{"path":"/reference/node_list.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a node list — node_list","text":"See edge_list function create edge lists.","code":""},{"path":"/reference/node_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a node list — node_list","text":"","code":"library(matsbyname) library(tidyr) sutmats <- UKEnergy2000mats %>% spread(key = matrix.name, value = matrix) el <- edge_list(sutmats)$`Edge list`[[1]] node_list(el) #>                    Node node_id #> 1  Resources [of Crude]       0 #> 2           Crude dist.       1 #> 4            Oil fields       2 #> 6        Oil refineries       3 #> 8          Diesel dist.       4 #> 15         Power plants       5 #> 16          Elect. grid       6 #> 23    Resources [of NG]       7 #> 24             NG dist.       8 #> 26    Gas wells & proc.       9 #> 29         Petrol dist.      10 #> 53            Transport      11 #> 61          Residential      12 #> 70                Waste      13"},{"path":"/reference/nonenergy_products.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-energy products — nonenergy_products","title":"Non-energy products — nonenergy_products","text":"string vector containing names products classified \"Non-energy\" package development team. list include hydrocarbon-derived materials \"Lubricants\". list also includes products classified \"Crude, NGL, refinery feedstocks\" IEA World Extended Energy Balances 2021 documentation \"Additives/blending components\".","code":""},{"path":"/reference/nonenergy_products.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-energy products — nonenergy_products","text":"","code":"nonenergy_products"},{"path":"/reference/nonenergy_products.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Non-energy products — nonenergy_products","text":"object class list length 7.","code":""},{"path":"/reference/nonenergy_products.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-energy products — nonenergy_products","text":"","code":"Recca::nonenergy_products #> $additives_blending_components #> [1] \"Additives/blending components\" #>  #> $bitumen #> [1] \"Bitumen\" #>  #> $lubricants #> [1] \"Lubricants\" #>  #> $naphtha #> [1] \"Naphtha\" #>  #> $paraffin_waxes #> [1] \"Paraffin waxes\" #>  #> $refinery_feedstocks #> [1] \"Refinery feedstocks\" #>  #> $white_spirit_and_sbp #> [1] \"White spirit & SBP\" #>"},{"path":"/reference/outputs_unit_homogeneous.html","id":null,"dir":"Reference","previous_headings":"","what":"Tell whether industry outputs are unit-homogeneous — outputs_unit_homogeneous","title":"Tell whether industry outputs are unit-homogeneous — outputs_unit_homogeneous","text":"Returns TRUE industry's output unit-homogeneous.","code":""},{"path":"/reference/outputs_unit_homogeneous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tell whether industry outputs are unit-homogeneous — outputs_unit_homogeneous","text":"","code":"outputs_unit_homogeneous(   .sutmats = NULL,   V = \"V\",   S_units = \"S_units\",   keep_details = FALSE,   outs_unit_homogeneous = \".outputs_unit_homogeneous\" )"},{"path":"/reference/outputs_unit_homogeneous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tell whether industry outputs are unit-homogeneous — outputs_unit_homogeneous","text":".sutmats data frame supply-use table matrices matrices arranged columns. V make (V) matrix name column .sutmats contains . Default \"V\". S_units S_units matrix name column .sutmats contains . Default \"S_units\". keep_details TRUE, per-industry results returned; FALSE, per-ECC results returned. outs_unit_homogeneous name output column tells whether industry's outputs unit-homogeneous. Default \".outputs_unit_homogeneous\".","code":""},{"path":"/reference/outputs_unit_homogeneous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tell whether industry outputs are unit-homogeneous — outputs_unit_homogeneous","text":"list data frame containing TRUE outputs energy conversion industry unit-homogeneous, FALSE otherwise.","code":""},{"path":"/reference/outputs_unit_homogeneous.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tell whether industry outputs are unit-homogeneous — outputs_unit_homogeneous","text":"V_bar matrix queried number non-zero entries row. number non-zero entries row exactly 1, industry outputs unit-homogeneous. Note V_bar = matrixproduct_byname(V, S_units).","code":""},{"path":"/reference/outputs_unit_homogeneous.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tell whether industry outputs are unit-homogeneous — outputs_unit_homogeneous","text":"","code":"library(tidyr) UKEnergy2000mats %>%   spread(key = \"matrix.name\", value = \"matrix\") %>%   outputs_unit_homogeneous() #> # A tibble: 4 × 13 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 5 more variables: U_feed <list>, V <list>, Y <list>, r_EIOU <list>, #> #   .outputs_unit_homogeneous <lgl>"},{"path":"/reference/pfu_aggregates.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate to primary, final, and useful stages — pfu_aggregates","title":"Aggregate to primary, final, and useful stages — pfu_aggregates","text":"Calculate aggregates possible ECC stages (primary, final, useful), regardless whether last stage final useful. See details approach. Note services aggregations often inherently problematic, energy services often quantified different units. functions perform aggregation services. Users referred finaldemand_aggregates() aggregation services, desired sensible.","code":""},{"path":"/reference/pfu_aggregates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate to primary, final, and useful stages — pfu_aggregates","text":"","code":"pfu_aggregates(   .sutdata,   p_industries,   fd_sectors,   by = c(\"Total\", \"Product\", \"Industry\", \"Flow\"),   add_net_gross_cols = FALSE,   piece = \"all\",   notation = RCLabels::notations_list,   pattern_type = c(\"exact\", \"leading\", \"trailing\", \"anywhere\", \"literal\"),   prepositions = RCLabels::prepositions_list,   net_aggregate_primary = Recca::aggregate_cols$net_aggregate_primary,   gross_aggregate_primary = Recca::aggregate_cols$gross_aggregate_primary,   net_aggregate_final = Recca::aggregate_cols$net_aggregate_final,   gross_aggregate_final = Recca::aggregate_cols$gross_aggregate_final,   net_aggregate_useful = Recca::aggregate_cols$net_aggregate_useful,   gross_aggregate_useful = Recca::aggregate_cols$gross_aggregate_useful,   net_aggregate_services = Recca::aggregate_cols$net_aggregate_services,   gross_aggregate_services = Recca::aggregate_cols$gross_aggregate_services,   last_stage = Recca::psut_cols$last_stage,   primary = Recca::all_stages$primary,   final = Recca::all_stages$final,   useful = Recca::all_stages$useful,   services = Recca::all_stages$services,   sep = Recca::all_stages$last_stage_sep,   R = Recca::psut_cols$R,   U = Recca::psut_cols$U,   U_feed = Recca::psut_cols$U_feed,   U_eiou = Recca::psut_cols$U_eiou,   r_eiou = Recca::psut_cols$r_eiou,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   S_units = Recca::psut_cols$S_units,   R_lsfinal = paste0(Recca::psut_cols$R, sep, final),   U_lsfinal = paste0(Recca::psut_cols$U, sep, final),   U_feed_lsfinal = paste0(Recca::psut_cols$U_feed, sep, final),   U_eiou_lsfinal = paste0(Recca::psut_cols$U_eiou, sep, final),   r_eiou_lsfinal = paste0(Recca::psut_cols$r_eiou, sep, final),   V_lsfinal = paste0(Recca::psut_cols$V, sep, final),   Y_lsfinal = paste0(Recca::psut_cols$Y, sep, final),   S_units_lsfinal = paste0(Recca::psut_cols$S_units, sep, final),   R_lsuseful = paste0(Recca::psut_cols$R, sep, useful),   U_lsuseful = paste0(Recca::psut_cols$U, sep, useful),   U_feed_lsuseful = paste0(Recca::psut_cols$U_feed, sep, useful),   U_eiou_lsuseful = paste0(Recca::psut_cols$U_eiou, sep, useful),   r_eiou_lsuseful = paste0(Recca::psut_cols$r_eiou, sep, useful),   V_lsuseful = paste0(Recca::psut_cols$V, sep, useful),   Y_lsuseful = paste0(Recca::psut_cols$Y, sep, useful),   S_units_lsuseful = paste0(Recca::psut_cols$S_units, sep, useful),   R_lsservices = paste0(Recca::psut_cols$R, sep, services),   U_lsservices = paste0(Recca::psut_cols$U, sep, services),   U_feed_lsservices = paste0(Recca::psut_cols$U_feed, sep, services),   U_eiou_lsservices = paste0(Recca::psut_cols$U_eiou, sep, services),   r_eiou_lsservices = paste0(Recca::psut_cols$r_eiou, sep, services),   V_lsservices = paste0(Recca::psut_cols$V, sep, services),   Y_lsservices = paste0(Recca::psut_cols$Y, sep, services),   S_units_lsservices = paste0(Recca::psut_cols$S_units, sep, services),   .matnames = Recca::psut_cols$matnames,   .matvals = Recca::psut_cols$matvals,   tol = 1e-06 )"},{"path":"/reference/pfu_aggregates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate to primary, final, and useful stages — pfu_aggregates","text":".sutdata optional data frame containing physical supply use table descriptions energy conversion chains. p_industries string vector primary industries. fd_sectors string vector final demand sectors. Tells aggregate, one \"Total\", \"Product\", \"Industry\", \"Flow\". Default \"Total\". add_net_gross_cols boolean tells whether include net gross columns primary energy aggregation. Default FALSE. piece Tells piece row column labels use aggregation decision. Default \"\". notation Tells notation used row column labels. Default RCLabels::notations_list. pattern_type Tells match row column names. One \"exact\", \"leading\", \"trailing\", \"anywhere\", \"literal\". Default \"exact\". prepositions list prepositions row column labels. Default RCLabels::prepositions_list. net_aggregate_primary, gross_aggregate_primary, net_aggregate_final, gross_aggregate_final, net_aggregate_useful, gross_aggregate_useful, net_aggregate_services, gross_aggregate_services See Recca::aggregate_cols. last_stage Name last stage column. Default Recca::psut_cols$last_stage. primary, final, useful, services String identifiers ECC stages. See Recca::all_stages. sep string separator identifying last stage ECC. Default Recca::all_stages$last_stage_sep. R, U, U_feed, U_eiou, r_eiou, V, Y, S_units Names columns containing matrices. See Recca::psut_cols. R_lsfinal, U_lsfinal, U_feed_lsfinal, U_eiou_lsfinal, r_eiou_lsfinal, V_lsfinal, Y_lsfinal, S_units_lsfinal Names columns last stage final energy. Defaults unmodified column names concatenated sep final. R_lsuseful, U_lsuseful, U_feed_lsuseful, U_eiou_lsuseful, r_eiou_lsuseful, V_lsuseful, Y_lsuseful, S_units_lsuseful Names columns last stage useful energy. Defaults unmodified column names concatenated sep useful. R_lsservices, U_lsservices, U_feed_lsservices, U_eiou_lsservices, r_eiou_lsservices, V_lsservices, Y_lsservices, S_units_lsservices Names columns last stage energy services. Defaults unmodified column names concatenated sep services. .matnames, .matvals Names columns used internally. Defaults Recca::psut_cols. tol allowable energy imbalance units energy flows. Default 1e-6.","code":""},{"path":"/reference/pfu_aggregates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate to primary, final, and useful stages — pfu_aggregates","text":"data frame primary, final, useful aggregates.","code":""},{"path":"/reference/pfu_aggregates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate to primary, final, and useful stages — pfu_aggregates","text":"several ways aggregate energy conversion chain (ECC) data primary, final, useful stages ECC. primary_aggregates() aggregates primary energy using resource (R), make (V), final demand (Y) matrices. primary_aggregates() gives upstream (source) aggregations ECC. finaldemand_aggregates() aggregates last stage energy conversion chain using R Y matrices, regardless whether last stage final, useful, services. finaldemand_aggregates() gives downstream (sink) aggregations. However, applying finaldemand_aggregates() ECC whose last stage final produce useful stage aggregations. Similarly, applying finaldemand_aggregates() ECC whose last stage useful provide final stage aggregations. See following table. -axis aggregations, special considerations employed function. Note : two results primary_aggregates() equal within tol. agreement observed, error given. Note B: last stage useful want final stage aggregations final--useful stage efficiencies, can employ calc_eta_fu_Y_eiou() inverse relationship calculate final stage aggregates useful stage information known. result Y U_EIOU matrices structure Y_Useful U_EIOU_Useful containing final stage data. final----structure--useful matrices can used calculate final aggregations last stage useful. Note C: last stage final want useful energy aggregates final--useful efficiencies, can employ calc_eta_fu_Y_eiou() calculate useful energy piece final demand EIOU last stage final, giving Y U_EIOU matrices structure Y_Final U_EIOU_Final except containing useful energy data. useful----structure--final matrices can used calculate useful aggregations last stage final. Whereas primary_aggregates() finaldemand_aggregates() work independently last stage ECC, function requires final useful last stage ECCs present .sutdata. data last state services ignored function. Suffixes matrix names assumed indicate last stage ECC matrix applies. example, two versions R matrix present: R_final R_useful. .sutdata wide--matrices data frame contains last_stage column, .sutdata pivoted wide (convenience) put data correct shape, forming columns combination ECC matrix last stage. last_stage R columns make R_final R_useful columns. last_stage V columns make V_final V_useful columns. Etc. either last stage final last stage useful ECC representations missing, error thrown. See examples. Internally, function uses primary_aggregates() finaldemand_aggregates() complete work. Primary aggregates can computed last stage final, useful, services. Ostensibly, primary aggregates cases metadata . error thrown true within tol.","code":""},{"path":"/reference/pfu_aggregates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate to primary, final, and useful stages — pfu_aggregates","text":"","code":"p_industries <- c(\"Resources [of Crude]\", \"Resources [of NG]\") fd_sectors <- c(\"Residential\", \"Transport\", \"Oil fields\") # Primary TOTAL aggregates UKEnergy2000mats |>   tidyr::pivot_wider(names_from = matrix.name, values_from = matrix) |>   # Eliminate the case when last_stage == \"Final\"   dplyr::filter(.data[[Recca::psut_cols$last_stage]] != \"Final\") |>   pfu_aggregates(p_industries = p_industries, fd_sectors = fd_sectors,                 by = \"Total\") #> # A tibble: 2 × 43 #>   Country  Year Energy.type R___lsUseful  U___lsUseful    U_feed___lsUseful #>   <chr>   <dbl> <chr>       <list>        <list>          <list>            #> 1 GBR      2000 E           <dbl [2 × 2]> <dbl [13 × 13]> <dbl [12 × 13]>   #> 2 GBR      2000 X           <NULL>        <NULL>          <NULL>            #> # ℹ 37 more variables: U_EIOU___lsUseful <list>, r_EIOU___lsUseful <list>, #> #   V___lsUseful <list>, Y___lsUseful <list>, S_units___lsUseful <list>, #> #   R___lsServices <list>, U___lsServices <list>, U_feed___lsServices <list>, #> #   U_EIOU___lsServices <list>, r_EIOU___lsServices <list>, #> #   V___lsServices <list>, Y___lsServices <list>, S_units___lsServices <list>, #> #   EX.p_net___lsFinal <list>, EX.p_gross___lsFinal <list>, #> #   EX.p_net___lsUseful <list>, EX.p_gross___lsUseful <list>, …"},{"path":"/reference/phi_vec.html","id":null,"dir":"Reference","previous_headings":"","what":"A vector of phi (exergy-to-energy ratios) values — phi_vec","title":"A vector of phi (exergy-to-energy ratios) values — phi_vec","text":"Converting energy exergy requires vectors phi values. object vector assist conversion process UKEnergy2000mats energy conversion chain bundled package.","code":""},{"path":"/reference/phi_vec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A vector of phi (exergy-to-energy ratios) values — phi_vec","text":"","code":"phi_vec"},{"path":"/reference/phi_vec.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A vector of phi (exergy-to-energy ratios) values — phi_vec","text":"matrix energy products rows phi values single column.","code":""},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/primary_aggregates.html","id":null,"dir":"Reference","previous_headings":"","what":"Primary energy and exergy aggregates — primary_aggregates","title":"Primary energy and exergy aggregates — primary_aggregates","text":"Calculates aggregate primary energy data frame Supply-Use matrices.","code":""},{"path":"/reference/primary_aggregates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primary energy and exergy aggregates — primary_aggregates","text":"","code":"primary_aggregates(   .sutdata = NULL,   p_industries,   add_net_gross_cols = FALSE,   piece = \"all\",   notation = RCLabels::notations_list,   pattern_type = c(\"exact\", \"leading\", \"trailing\", \"anywhere\", \"literal\"),   prepositions = RCLabels::prepositions_list,   R = Recca::psut_cols$R,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   by = c(\"Total\", \"Product\", \"Industry\", \"Flow\"),   aggregate_primary = Recca::aggregate_cols$aggregate_primary,   net_aggregate_primary = Recca::aggregate_cols$net_aggregate_primary,   gross_aggregate_primary = Recca::aggregate_cols$gross_aggregate_primary )"},{"path":"/reference/primary_aggregates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primary energy and exergy aggregates — primary_aggregates","text":".sutdata data frame columns matrices supply-use analysis. p_industries vector names industries aggregated \"primary.\" .sutdata data frame, p_industries name column data frame. .sutdata NULL, p_industries can single vector industry names. industries p_industries appear rows resource (R) make (V) matrices columns final demand matrix (Y). Entries Y_p subtracted entries R_p + V_p obtain total primary energy aggregate, *_p primary part matrices. function find_p_industry_names() might helpful find primary industry names can identified prefixes. add_net_gross_cols boolean tells whether add net gross columns (TRUE) (FALSE). Default FALSE. piece, notation, pattern_type, prepositions Arguments control way row column matching accomplished selecting parts R, V, Y matrices primary aggregation. arguments passed matsbyname::select_rowcol_piece_byname() eventually RCLabels::match_by_pattern() RCLabels::make_or_pattern(). Default values piece = \"\", notation = RCLabels::notations_list, pattern_type = \"exact\", prepositions = RCLabels::prepositions_list. R, V, Y See Recca::psut_cols. One \"Total\", \"Product\", \"Industry\", \"Flow\" indicate desired aggregation: \"Total\": aggregation Product Flow (default), \"Product\": aggregation energy carrier (Crude oil, Primary solid biofuels, etc.), \"Industry\" \"Flow\": aggregation Industry (Production, Imports, Exports, etc.). aggregate_primary, net_aggregate_primary, gross_aggregate_primary names aggregates primary energy output.","code":""},{"path":"/reference/primary_aggregates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primary energy and exergy aggregates — primary_aggregates","text":"list data frame containing aggregate primary energy.","code":""},{"path":"/reference/primary_aggregates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Primary energy and exergy aggregates — primary_aggregates","text":"default, function adds single column primary energy aggregates name aggregate_primary. add_net_gross_cols TRUE (default FALSE), two columns created: net_aggregate_primary gross_aggregate_primary. net gross output (add_net_gross_cols = TRUE), columns contain identical values. Use add_net_gross_cols = TRUE later wish combine results finaldemand_aggregates(), provides net gross outputs.","code":""},{"path":"/reference/primary_aggregates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primary energy and exergy aggregates — primary_aggregates","text":"","code":"library(matsbyname) p_industries <- c(\"Resources - Crude\", \"Resources - NG\") # Calculate primary total aggregates res <- UKEnergy2000mats %>%   tidyr::pivot_wider(names_from = \"matrix.name\", values_from = \"matrix\") %>%   Recca::primary_aggregates(p_industries = p_industries, by = \"Total\") tibble::as_tibble(res) #> # A tibble: 4 × 13 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 5 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   EX.p <dbl> res[[Recca::aggregate_cols$aggregate_primary]] #> [1] 0 0 0 0 # Above, only 1 aggregate column is created, because there is no # difference between net and gross aggregation for primary energy. # Below, both net and gross aggregation columns are created, # for compatibility with the [finaldemand_aggregates()] function. # Net and gross primary aggregates are identical. res2 <- UKEnergy2000mats %>%   tidyr::pivot_wider(names_from = \"matrix.name\", values_from = \"matrix\") %>%   Recca::primary_aggregates(p_industries = p_industries,                             add_net_gross_cols = TRUE,                             by = \"Total\") tibble::as_tibble(res2) #> # A tibble: 4 × 14 #>   Country  Year Energy.type Last.stage R             U        U_EIOU   U_feed   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 6 more variables: V <list>, Y <list>, r_EIOU <list>, S_units <list>, #> #   EX.p_net <dbl>, EX.p_gross <dbl> res2[[Recca::aggregate_cols$net_aggregate_primary]] #> [1] 0 0 0 0 res2[[Recca::aggregate_cols$gross_aggregate_primary]] #> [1] 0 0 0 0"},{"path":"/reference/prod_ind_names_colnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Names of data frame columns containing Product and Industry matrix row and column names — prod_ind_names_colnames","title":"Names of data frame columns containing Product and Industry matrix row and column names — prod_ind_names_colnames","text":"list data frame column names. data frame columns contain vectors unique Product Industry column names R, U, V, Y matrices.","code":""},{"path":"/reference/prod_ind_names_colnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Names of data frame columns containing Product and Industry matrix row and column names — prod_ind_names_colnames","text":"","code":"prod_ind_names_colnames"},{"path":"/reference/prod_ind_names_colnames.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Names of data frame columns containing Product and Industry matrix row and column names — prod_ind_names_colnames","text":"list 2 entries. product_names name data frame column contains Products. Default \"Product.names\". industry_names name data frame column contains Industries. Default \"Industry.names\".","code":""},{"path":"/reference/products_unit_homogeneous.html","id":null,"dir":"Reference","previous_headings":"","what":"Tell whether ECC products are unit-homogenous — products_unit_homogeneous","title":"Tell whether ECC products are unit-homogenous — products_unit_homogeneous","text":"Returns TRUE products unit-homogeneous according S_units matrix FALSE otherwise.","code":""},{"path":"/reference/products_unit_homogeneous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tell whether ECC products are unit-homogenous — products_unit_homogeneous","text":"","code":"products_unit_homogeneous(   .sutmats = NULL,   S_units = \"S_units\",   keep_details = FALSE,   products_unit_homogeneous = \".products_unit_homogeneous\" )"},{"path":"/reference/products_unit_homogeneous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tell whether ECC products are unit-homogenous — products_unit_homogeneous","text":".sutmats data frame supply-use table matrices matrices arranged columns. S_units S_units matrix name column .sutmats contains . Default \"S_units\". keep_details TRUE, per-product results returned; FALSE, per-ECC results returned. products_unit_homogeneous name boolean tells whether products S_units unit-homogeneous output. Default \".products_unit_homogeneous\".","code":""},{"path":"/reference/products_unit_homogeneous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tell whether ECC products are unit-homogenous — products_unit_homogeneous","text":"list data frame containing TRUE products S_units unit-homogeneous, FALSE otherwise. importFrom magrittr extract2","code":""},{"path":"/reference/products_unit_homogeneous.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tell whether ECC products are unit-homogenous — products_unit_homogeneous","text":"","code":"library(magrittr) library(tidyr) UKEnergy2000mats %>%   spread(key = \"matrix.name\", value = \"matrix\") %>%   products_unit_homogeneous() %>%   extract2(\".products_unit_homogeneous\") #> [1] TRUE TRUE TRUE TRUE"},{"path":"/reference/propulsion_eu.products.html","id":null,"dir":"Reference","previous_headings":"","what":"A list of Propulsion useful work products — propulsion_eu.products","title":"A list of Propulsion useful work products — propulsion_eu.products","text":"list Propulsion useful work products","code":""},{"path":"/reference/propulsion_eu.products.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A list of Propulsion useful work products — propulsion_eu.products","text":"","code":"propulsion_eu.products"},{"path":"/reference/propulsion_eu.products.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A list of Propulsion useful work products — propulsion_eu.products","text":"list 3 entries. MP useful work product (Eu.product) Marine propulsion RoP useful work product (Eu.product) Road propulsion RaP useful work product (Eu.product) Rail propulsion","code":""},{"path":"/reference/psut_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Physical Supply-Use Table (PSUT) data frame column names — psut_cols","title":"Physical Supply-Use Table (PSUT) data frame column names — psut_cols","text":"string list containing named names columns PSUT data frames. Items list provide default values column name function arguments throughout Recca package.","code":""},{"path":"/reference/psut_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Physical Supply-Use Table (PSUT) data frame column names — psut_cols","text":"","code":"psut_cols"},{"path":"/reference/psut_cols.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Physical Supply-Use Table (PSUT) data frame column names — psut_cols","text":"string list 23 entries. resources,R name column wide--matrices data frame containing resource (R) matrices. U_feed name column wide--matrices data frame containing use (U) matrices exclude energy industry use. U_eiou name column wide--matrices data frame containing use (U) matrices contain exclusively energy industry use. U name column wide data--matrices frame containing use (U) matrices sum U_feed U_eiou matrices. r_eiou name column wide--matrices data frame containing ratio U_eiou U matrices. make,V name column wide--matrices data frame containing make (V) matrices. final_demand,Y name column wide--matrices data frame containing final demand (Y) matrices. phi name column wide--matrices data frame containing exergy--energy-ratio (phi) matrices. S_units name column wide--matrices data frame containing unit summation (S_units) matrices. matvals name column tidy data frame containing matrices. matnames name column tidy data frame containing matrix names. sector name column tidy data frame containing sector names. country name column tidy data frame containing names countries. year name column tidy data frame containing years. method name column tidy data frame containing method accounting primary equivalent renewable electricity. energy_type name column tidy data frame containing names energy types. last_stage name column tidy data frame last stages energy conversion chain.","code":""},{"path":"/reference/psut_cols.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Physical Supply-Use Table (PSUT) data frame column names — psut_cols","text":"Note values repeated, thereby providing synonyms. E.g., resources R point \"R\" column name.","code":""},{"path":"/reference/psut_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Physical Supply-Use Table (PSUT) data frame column names — psut_cols","text":"","code":"psut_cols #> $resources #> [1] \"R\" #>  #> $R #> [1] \"R\" #>  #> $use #> [1] \"U\" #>  #> $U #> [1] \"U\" #>  #> $U_feed #> [1] \"U_feed\" #>  #> $U_eiou #> [1] \"U_EIOU\" #>  #> $r_eiou #> [1] \"r_EIOU\" #>  #> $make #> [1] \"V\" #>  #> $V #> [1] \"V\" #>  #> $final_demand #> [1] \"Y\" #>  #> $Y #> [1] \"Y\" #>  #> $B #> [1] \"B\" #>  #> $s_units #> [1] \"S_units\" #>  #> $matvals #> [1] \"matvals\" #>"},{"path":"/reference/quasi-quote-assign.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — :=","title":"Pipe operator — :=","text":"See rlang:::= details.","code":""},{"path":"/reference/quasi-quote-assign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — :=","text":"","code":"x := y"},{"path":"/reference/region_aggregates.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate into regions — region_aggregates","title":"Aggregate into regions — region_aggregates","text":"Aggregates data frame according regions given column data frame. data frame (.sut_data) contain metadata columns (including many_colname few_colname) wide--matrices.","code":""},{"path":"/reference/region_aggregates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate into regions — region_aggregates","text":"","code":"region_aggregates(   .sut_data,   many_colname = IEATools::iea_cols$country,   few_colname = Recca::aggregate_cols$region,   drop_na_few = FALSE,   year = IEATools::iea_cols$year,   method = IEATools::iea_cols$method,   energy_type = IEATools::iea_cols$energy_type,   last_stage = IEATools::iea_cols$last_stage,   matrix_cols = c(R = Recca::psut_cols$R, U = Recca::psut_cols$U, U_feed =     Recca::psut_cols$U_feed, U_eiou = Recca::psut_cols$U_eiou, r_eiou =     Recca::psut_cols$r_eiou, V = Recca::psut_cols$V, Y = Recca::psut_cols$Y, S_units =     Recca::psut_cols$S_units),   matrix_names = Recca::psut_cols$matnames,   matrix_values = Recca::psut_cols$matvals )"},{"path":"/reference/region_aggregates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate into regions — region_aggregates","text":".sut_data wide--matrices matsindf-style data frame PSUT matrices. many_colname name column .sut_data contains \"many\" descriptions, example countries need aggregated continents. Default IEATools::iea_cols$country. few_colname column .sut_data contains \"\" descriptions, example continents countries aggregated. Default Recca::aggregate_cols$region. drop_na_few boolean tells whether ignore (aggregate) rows  NA values few_colname. See details. Default FALSE. year, method, energy_type, last_stage See IEATools::iea_cols. matrix_cols Names columns .sut_data containing matrices. Default vector names Recca::psut_cols: R, U, U_feed, U_eiou, r_eiou, V, Y, S_units. matrix_names, matrix_values Internal column names. See Recca::psut_cols.","code":""},{"path":"/reference/region_aggregates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate into regions — region_aggregates","text":"aggregated version .sut_data wherein many_colname column replaced few_colname specified aggregation_map.","code":""},{"path":"/reference/region_aggregates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate into regions — region_aggregates","text":"argument drop_na_few controls happens item many_colname corresponding value few_colname. condition can occur , say, \"WRLD\" country. \"WRLD\" (country many_colname) aggregated \"World\" (region few_colname). circumstances, well-formed aggregation_map leave NA few_colname. Setting drop_na_few eliminate rows NA few_colname aggregation NA rows end NA outgoing data frame. default value drop_na_few FALSE, setting TRUE result data loss. need opt behavior know want.","code":""},{"path":"/reference/region_aggregates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate into regions — region_aggregates","text":"","code":"library(dplyr) library(matsbyname) library(tidyr) mats_GBR <- UKEnergy2000mats %>%   tidyr::pivot_wider(names_from = matrix.name, values_from = matrix) # Add other countries, by duplicating and renaming GBR mats <- dplyr::bind_rows(mats_GBR,                          mats_GBR %>% dplyr::mutate(Country = \"USA\"),                          mats_GBR %>% dplyr::mutate(Country = \"FRA\")) # Establish the aggregation map. agg_df <- list(EUR = c(\"GBR\", \"FRA\"), AMR = \"USA\") %>%   matsbyname::agg_map_to_agg_table(few_colname = \"Continent\", many_colname = \"Country\") # Aggregate into continents dplyr::left_join(mats, agg_df, by = \"Country\") %>%   region_aggregates(many_colname = \"Country\", few_colname = \"Continent\") #> # A tibble: 8 × 12 #>    Year Energy.type Last.stage Country R             S_units  U_EIOU   U_feed   #>   <dbl> <chr>       <chr>      <chr>   <list>        <list>   <list>   <list>   #> 1  2000 E           Final      AMR     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2  2000 E           Final      EUR     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3  2000 E           Services   AMR     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4  2000 E           Services   EUR     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 5  2000 E           Useful     AMR     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 6  2000 E           Useful     EUR     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 7  2000 X           Services   AMR     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 8  2000 X           Services   EUR     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 4 more variables: V <list>, Y <list>, U <list>, r_EIOU <list>"},{"path":"/reference/remove_neu.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove Non-energy use from an energy conversion chain — remove_neu","title":"Remove Non-energy use from an energy conversion chain — remove_neu","text":"Frequently, Non-energy use removed energy conversion chain, final demand, useful stage, final stage, primary stage. function removes Non-energy use via \"upstream swim\" new_Y().","code":""},{"path":"/reference/remove_neu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove Non-energy use from an energy conversion chain — remove_neu","text":"","code":"remove_neu(   .sutmats,   neu_product_pattern = RCLabels::make_or_pattern(c(\"NEU\", nonenergy_products)),   neu_industry_pattern = RCLabels::make_or_pattern(\"Non-energy use\", pattern_type =     \"leading\"),   method = \"solve\",   R = Recca::psut_cols$R,   U = Recca::psut_cols$U,   U_feed = Recca::psut_cols$U_feed,   U_eiou = Recca::psut_cols$U_eiou,   r_eiou = Recca::psut_cols$r_eiou,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   S_units = Recca::psut_cols$S_units,   prime_suffix = \"_prime\",   R_prime = paste0(Recca::psut_cols$R, prime_suffix),   U_prime = paste0(Recca::psut_cols$U, prime_suffix),   U_feed_prime = paste0(Recca::psut_cols$U_feed, prime_suffix),   U_eiou_prime = paste0(Recca::psut_cols$U_eiou, prime_suffix),   r_eiou_prime = paste0(Recca::psut_cols$r_eiou, prime_suffix),   V_prime = paste0(Recca::psut_cols$V, prime_suffix),   Y_prime = paste0(Recca::psut_cols$Y, prime_suffix),   S_units_prime = paste0(Recca::psut_cols$S_units, prime_suffix) )"},{"path":"/reference/remove_neu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove Non-energy use from an energy conversion chain — remove_neu","text":".sutmats data frame named list PSUT matrices. neu_product_pattern string regex pattern identifies Non-energy use rows final demand (Y) matrix. Default RCLabels::make_or_pattern(c(\"NEU\", nonenergy_products)), meaning \"NEU\" product several non-energy uses removed product rows. neu_industry_pattern string regex pattern identifies Non-energy use columns final demand (Y) matrix. Default RCLabels::make_or_pattern(\"Non-energy use\", pattern_type = \"leading\"), specifies string \"Non-energy use\" leading part column name Y matrix. approach allows \"Non-energy use X\" columns removed. method method upstream swim conducted. Default \"solve\" usual solve() R. argument passed matsbyname::invert_byname(). R, U, U_feed, U_eiou, r_eiou, V, Y, S_units String names matrix columns list items .psut_mats. Alternatively, arguments can single matrices. Default values strings Recca::psut_cols. prime_suffix suffix names modified matrices. Default \"_prime\". R_prime, U_prime, U_feed_prime, U_eiou_prime, r_eiou_prime, V_prime, Y_prime, S_units_prime Output names. Defaults formed appending \"_prime\" default names.","code":""},{"path":"/reference/remove_neu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove Non-energy use from an energy conversion chain — remove_neu","text":"version energy conversion chain Non-energy use industries products removed.","code":""},{"path":"/reference/remove_neu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove Non-energy use from an energy conversion chain — remove_neu","text":"Although function remove_neu(), can used remove row column final demand matrix calculate remaining ECC overriding default value neu_industry_pattern neu_product_pattern arguments. Note data frame list passed .sutmats, original matrices remain columns, new columns added *_prime matrices. Callers may wish delete original matrices returned data frame.","code":""},{"path":"/reference/remove_neu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove Non-energy use from an energy conversion chain — remove_neu","text":"","code":"UKEnergy2000mats |>   tidyr::spread(key = matrix.name, value = matrix) |>   dplyr::filter(Last.stage != \"Services\") |>   # This data frame does not contain \"Non-energy use\",   # so remove \"Residential\" instead.   Recca::remove_neu(neu_product_pattern = \"^NG|^MD\",                     neu_industry_pattern = \"^Residential\") #> # A tibble: 2 × 20 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 12 more variables: U_feed <list>, V <list>, Y <list>, r_EIOU <list>, #> #   R_prime <list>, U_prime <list>, U_feed_prime <list>, U_EIOU_prime <list>, #> #   r_EIOU_prime <list>, V_prime <list>, Y_prime <list>, S_units_prime <list>"},{"path":"/reference/replace_html_codes.html","id":null,"dir":"Reference","previous_headings":"","what":"Un-escape HTML codes in text — replace_html_codes","title":"Un-escape HTML codes in text — replace_html_codes","text":"Occasionally, need un-escape HTML codes text. text contains HTML codes, replaced replacements, , default, describe replacements \"&amp;\", \"&lt;\", \"&gt;\" (\"&\", \"<\", \">\", respectively).","code":""},{"path":"/reference/replace_html_codes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Un-escape HTML codes in text — replace_html_codes","text":"","code":"replace_html_codes(   text,   replacements = list(c(\"&amp;\", \"&\"), c(\"&lt;\", \"<\"), c(\"&gt;\", \">\")) )"},{"path":"/reference/replace_html_codes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Un-escape HTML codes in text — replace_html_codes","text":"text vector (one-dimensional list) character strings replacements list string pairs. pair consists encoded string unencoded string, order. Default list(c(\"&amp;\", \"&\"), c(\"&lt;\", \"<\"), c(\"&gt;\", \">\"))","code":""},{"path":"/reference/replace_html_codes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Un-escape HTML codes in text — replace_html_codes","text":"text vector, vector un-encoded strings. text list strings, list un-encoded strings structure. possible, outgoing list simplified structure, even point conversion vector.","code":""},{"path":"/reference/replace_html_codes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Un-escape HTML codes in text — replace_html_codes","text":"HTML codes can arrive text read Excel file openxlsx package due bug documented .","code":""},{"path":"/reference/replace_html_codes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Un-escape HTML codes in text — replace_html_codes","text":"","code":"replace_html_codes(list(\"a\", \"&amp;\", \"&lt;\", \"&gt;\", \"bcd\")) #> [1] \"a\"   \"&\"   \"<\"   \">\"   \"bcd\" replace_html_codes(list(c(\"&amp;\", \"&amp;\"), c(\"&lt;\", \"&lt;\"), c(\"&gt;\", \"&gt;\"))) #> [[1]] #> [1] \"&\" \"&\" #>  #> [[2]] #> [1] \"<\" \"<\" #>  #> [[3]] #> [1] \">\" \">\" #>"},{"path":"/reference/resource_industries.html","id":null,"dir":"Reference","previous_headings":"","what":"Resource industries — resource_industries","title":"Resource industries — resource_industries","text":"Identifies resource industries.","code":""},{"path":"/reference/resource_industries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resource industries — resource_industries","text":"","code":"resource_industries(   .sutdata = NULL,   R = \"R\",   U = \"U\",   V = \"V\",   r_industries = \"r_industries\" )"},{"path":"/reference/resource_industries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resource industries — resource_industries","text":".sutdata list data frame containing use matrix(ces) make matrix(ces) R resource (R) matrix name column .sutmats contains . Default \"R\". U use (U) matrix name column .sutmats contains . Default \"U\". V make (V) matrix name column .sutmats contains . Default \"V\". r_industries name resource industry vector output. Default \"r_industries\".","code":""},{"path":"/reference/resource_industries.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resource industries — resource_industries","text":"list data frame .sutdata additional column (named value p_industries argument) containing resource industries row","code":""},{"path":"/reference/resource_industries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Resource industries — resource_industries","text":"Resource industries industries make product without using products. R given, industries automatically included output. Additional resource industries identified interrogating resources (R), use (U) make (V) matrices. Resource industries , definition, present R matrix, zeroes column use matrix (U) least one non-zero value row make (V) matrix. Argument value descriptions written assuming .sutdata data frame. Alternatively, .sutdata can unspecified, U V can matrices. case, return value list single item (r_industries) contains vector names resource industries U V matrices.","code":""},{"path":"/reference/resource_industries.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Resource industries — resource_industries","text":"","code":"library(tidyr) UKEnergy2000mats %>%   spread(key = matrix.name, value = matrix) %>%   resource_industries() #> # A tibble: 4 × 13 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 5 more variables: U_feed <list>, V <list>, Y <list>, r_EIOU <list>, #> #   r_industries <list>"},{"path":"/reference/reverse.html","id":null,"dir":"Reference","previous_headings":"","what":"Reverse an energy conversion chain — reverse","title":"Reverse an energy conversion chain — reverse","text":"Leontief's original input-output analysis involved swimming \"upstream\" estimate economy needed different final demand observed. different resources available? analysis resources become final demand (vice versa) make becomes use (vice versa). , analysis dealing reversed energy conversion chain (ECC). function performs reversal.","code":""},{"path":"/reference/reverse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reverse an energy conversion chain — reverse","text":"","code":"reverse(   .sutmats = NULL,   R = Recca::psut_cols$R,   U = Recca::psut_cols$U,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   R_rev = paste0(Recca::psut_cols$R, \"_rev\"),   U_rev = paste0(Recca::psut_cols$U, \"_rev\"),   V_rev = paste0(Recca::psut_cols$V, \"_rev\"),   Y_rev = paste0(Recca::psut_cols$Y, \"_rev\") )"},{"path":"/reference/reverse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reverse an energy conversion chain — reverse","text":".sutmats input ECC R R matrix ECC reversed. (Default \"R\".) U U matrix ECC reversed. (Default \"U\".) V V matrix ECC reversed. (Default \"V\".) Y Y matrix ECC reversed. (Default \"Y\".) R_rev name R matrix reversed ECC. (Default \"R_rev\".) U_rev name U matrix reversed ECC. (Default \"U_rev\".) V_rev name V matrix reversed ECC. (Default \"V_rev\".) Y_rev name Y matrix reversed ECC. (Default \"Y_rev\".)","code":""},{"path":"/reference/reverse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reverse an energy conversion chain — reverse","text":"reversed version ECC described R, U, V, Y.","code":""},{"path":"/reference/reverse.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reverse an energy conversion chain — reverse","text":"reverse ECC, R, U, V, Y matrices need transposed swapped: R Y U V. function performs operations.","code":""},{"path":"/reference/reverse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reverse an energy conversion chain — reverse","text":"","code":"library(dplyr) library(Recca) library(tidyr) mats <- UKEnergy2000mats %>%   spread(key = \"matrix.name\", value = \"matrix\") %>%   reverse() mats$R_rev[[1]] #>             Diesel [from Dist.] Elect [from Grid] NG [from Dist.] #> Residential                   0              6000           25000 #> Transport                 14750                 0               0 #>             Petrol [from Dist.] #> Residential                   0 #> Transport                 26000 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" mats$U_rev[[1]] #>                     Crude dist. Diesel dist. Elect. grid Gas wells & proc. #> Crude [from Dist.]        47500            0           0                 0 #> Crude [from Fields]           0            0           0                 0 #> Diesel                        0            0           0                 0 #> Diesel [from Dist.]           0        15500           0                 0 #> Elect                         0            0           0                 0 #> Elect [from Grid]             0            0        6275                 0 #> NG [from Dist.]               0            0           0                 0 #> NG [from Wells]               0            0           0             43000 #> Petrol                        0            0           0                 0 #> Petrol [from Dist.]           0            0           0                 0 #>                     NG dist. Oil fields Oil refineries Petrol dist. #> Crude [from Dist.]         0          0              0            0 #> Crude [from Fields]        0      50000              0            0 #> Diesel                     0          0          20500            0 #> Diesel [from Dist.]        0          0              0            0 #> Elect                      0          0              0            0 #> Elect [from Grid]          0          0              0            0 #> NG [from Dist.]        41000          0              0            0 #> NG [from Wells]            0          0              0            0 #> Petrol                     0          0          26500            0 #> Petrol [from Dist.]        0          0              0        26500 #>                     Power plants #> Crude [from Dist.]             0 #> Crude [from Fields]            0 #> Diesel                         0 #> Diesel [from Dist.]            0 #> Elect                       6400 #> Elect [from Grid]              0 #> NG [from Dist.]                0 #> NG [from Wells]                0 #> Petrol                         0 #> Petrol [from Dist.]            0 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" mats$V_rev[[1]] #>                   Crude Crude [from Dist.] Crude [from Fields] Diesel #> Crude dist.           0                500               47500      0 #> Diesel dist.          0                  0                   0  15500 #> Elect. grid           0                  0                   0      0 #> Gas wells & proc.     0                  0                   0      0 #> NG dist.              0                  0                   0      0 #> Oil fields        50000                  0                2500      0 #> Oil refineries        0              47000                   0   5000 #> Petrol dist.          0                  0                   0      0 #> Power plants          0                  0                   0      0 #>                   Diesel [from Dist.] Elect Elect [from Grid]    NG #> Crude dist.                        25     0                25     0 #> Diesel dist.                      350     0                 0     0 #> Elect. grid                         0  6400                 0     0 #> Gas wells & proc.                  50     0                25 43000 #> NG dist.                           25     0                25     0 #> Oil fields                         50     0                25     0 #> Oil refineries                      0     0                75     0 #> Petrol dist.                      250     0                 0     0 #> Power plants                        0     0               100     0 #>                   NG [from Dist.] NG [from Wells] Petrol Petrol [from Dist.] #> Crude dist.                     0               0      0                   0 #> Diesel dist.                    0               0      0                   0 #> Elect. grid                     0               0      0                   0 #> Gas wells & proc.               0            2000      0                   0 #> NG dist.                        0           41000      0                   0 #> Oil fields                      0               0      0                   0 #> Oil refineries                  0               0      0                   0 #> Petrol dist.                    0               0  26500                 500 #> Power plants                16000               0      0                   0 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" mats$Y_rev[[1]] #>       Resources [of Crude] Resources [of NG] #> Crude                50000                 0 #> NG                       0             43000 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\""},{"path":"/reference/row_col_types.html","id":null,"dir":"Reference","previous_headings":"","what":"Names of row and column types in PSUT matrices — row_col_types","title":"Names of row and column types in PSUT matrices — row_col_types","text":"list row column types.","code":""},{"path":"/reference/row_col_types.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Names of row and column types in PSUT matrices — row_col_types","text":"","code":"row_col_types"},{"path":"/reference/row_col_types.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Names of row and column types in PSUT matrices — row_col_types","text":"list 2 entries. product_type name product row column type. Default \"Product\". industry_type name industry row column type. Default \"Industry\".","code":""},{"path":"/reference/sankey_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Sankey diagram data frame column names — sankey_cols","title":"Sankey diagram data frame column names — sankey_cols","text":"string list containing named names columns Sankey data frames. Items list provide default values column name function arguments throughout Recca package.","code":""},{"path":"/reference/sankey_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sankey diagram data frame column names — sankey_cols","text":"","code":"sankey_cols"},{"path":"/reference/sankey_cols.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sankey diagram data frame column names — sankey_cols","text":"string list 1 entries. sankey name column wide--matrices data frame containing Sankey diagrams.","code":""},{"path":"/reference/sankey_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sankey diagram data frame column names — sankey_cols","text":"","code":"sankey_cols #> $sankey #> [1] \"Sankey\" #>"},{"path":"/reference/separate_RV.html","id":null,"dir":"Reference","previous_headings":"","what":"Separate resource (R) and make (V) matrices from make plus resource (R_plus_V) matrices — separate_RV","title":"Separate resource (R) and make (V) matrices from make plus resource (R_plus_V) matrices — separate_RV","text":"Resource industries industries make product without using products. Resource industries identified interrogating use (U) make (R_plus_V) matrices. Resource industries zeroes column use matrix (U) least one non-zero value row make (R_plus_V) matrix.","code":""},{"path":"/reference/separate_RV.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Separate resource (R) and make (V) matrices from make plus resource (R_plus_V) matrices — separate_RV","text":"","code":"separate_RV(.sutmats = NULL, U = \"U\", R_plus_V = \"R_plus_V\", R = \"R\", V = \"V\")"},{"path":"/reference/separate_RV.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Separate resource (R) and make (V) matrices from make plus resource (R_plus_V) matrices — separate_RV","text":".sutmats list data frame containing use matrix(ces) make matrix(ces) U use (U) matrix name column .sutmats contains . Default \"U\". R_plus_V R_plus_V matrix name column .sutmats contains . Default \"R_plus_V\". R name resource (R) matrix output. Default \"R\". V name make (V) matrix output. Default \"V\".","code":""},{"path":"/reference/separate_RV.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Separate resource (R) and make (V) matrices from make plus resource (R_plus_V) matrices — separate_RV","text":"list data frame containing R V matrices","code":""},{"path":"/reference/separate_RV.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Separate resource (R) and make (V) matrices from make plus resource (R_plus_V) matrices — separate_RV","text":"resource matrix (R) industries rows products columns. elements R indicate extraction resources biosphere. industries R reserves extracted products. function uses resource_industries function identify resource industries R_plus_V matrix. Thereafter, function extracts resource industries R_plus_V matrix form R matrix. Finally, R matrix subtracted R_plus_V matrix saved V matrix. resource industries R_plus_V matrix, warning emitted, R matrix created, changes made R_plus_V matrix. separate_RV inverse combine_RV.","code":""},{"path":"/reference/separate_RV.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Separate resource (R) and make (V) matrices from make plus resource (R_plus_V) matrices — separate_RV","text":"","code":"library(dplyr) library(tidyr) UKEnergy2000mats %>%   spread(key = \"matrix.name\", value = \"matrix\") %>%   # Rename the V matrix, because it includes the R matrix.   rename(     R_plus_V = V   ) %>%   separate_RV() #> Warning: No R created in separate_RV #> Warning: No R created in separate_RV #> Warning: No R created in separate_RV #> Warning: No R created in separate_RV #> Warning: Name collision in matsindf::matsindf_apply(). The following arguments appear both in .dat and in the output of `FUN`: R #> # A tibble: 4 × 14 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 6 more variables: U_feed <list>, R_plus_V <list>, Y <list>, r_EIOU <list>, #> #   R <list>, V <list>"},{"path":"/reference/simplify_edge_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Simplify an edge list — simplify_edge_list","title":"Simplify an edge list — simplify_edge_list","text":"PSUT energy conversion chain edge can simplified product one supplier (.e., one \"\"). , every \"\" node product can product's \"\" \"\". See examples.","code":""},{"path":"/reference/simplify_edge_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simplify an edge list — simplify_edge_list","text":"","code":"simplify_edge_list(   edge_list,   from = \"From\",   to = \"To\",   value = \"Value\",   product = \"Product\" )"},{"path":"/reference/simplify_edge_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simplify an edge list — simplify_edge_list","text":"edge_list edge list simplified name column edge list. (Default \"\".) name column edge list. (Default \"\".) value name value column edge list. (Default \"Value\".) product name product column edge list. (Default \"Product\".)","code":""},{"path":"/reference/simplify_edge_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simplify an edge list — simplify_edge_list","text":"simplified edge list","code":""},{"path":"/reference/simplify_edge_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simplify an edge list — simplify_edge_list","text":"","code":"el <- data.frame(From = c(\"A\", \"Oil\"), To = c(\"Oil\", \"C\"),                  Value = c(42, 42), Product = c(\"Oil\", \"Oil\"),                  stringsAsFactors = FALSE) # Oil flows from A to C through its product node (Oil) el #>   From  To Value Product #> 1    A Oil    42     Oil #> 2  Oil   C    42     Oil # Simplify to have Oil flow from A to C without the product node simplify_edge_list(el) #>   From To Value Product #> 1    A  C    42     Oil"},{"path":"/reference/startsWith_any_of.html","id":null,"dir":"Reference","previous_headings":"","what":"Tell if a string starts with any of a vector of strings — startsWith_any_of","title":"Tell if a string starts with any of a vector of strings — startsWith_any_of","text":"function returns TRUE x starts strings target FALSE otherwise.","code":""},{"path":"/reference/startsWith_any_of.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tell if a string starts with any of a vector of strings — startsWith_any_of","text":"","code":"startsWith_any_of(x, prefixes)"},{"path":"/reference/startsWith_any_of.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tell if a string starts with any of a vector of strings — startsWith_any_of","text":"x string (vector list strings) prefixes vector list strings","code":""},{"path":"/reference/startsWith_any_of.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tell if a string starts with any of a vector of strings — startsWith_any_of","text":"TRUE x starts strings target, FALSE otherwise. x vector list strings, return value length x contains result applying test item x.","code":""},{"path":"/reference/startsWith_any_of.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tell if a string starts with any of a vector of strings — startsWith_any_of","text":"function vectorized. x vector list strings, return value length x contains result applying test (x start target) item x.","code":""},{"path":"/reference/startsWith_any_of.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tell if a string starts with any of a vector of strings — startsWith_any_of","text":"","code":"startsWith_any_of(x = \"prefix - suffix\", prefixes = c(\"a\", \"b\", \"prefix\")) #> [1] TRUE startsWith_any_of(x = \"prefix - suffix\", prefixes = c(\"a\", \"b\", \"c\")) #> [1] FALSE startsWith_any_of(x = \"prefix - suffix\", prefixes = \"suffix\") #> [1] FALSE startsWith_any_of(x = c(\"Production - Crude\", \"Production - NG\",                          \"Exports - Oil\", \"Exports - Crude\"),                    prefixes = c(\"Production\", \"Imports\")) #> [1]  TRUE  TRUE FALSE FALSE"},{"path":"/reference/verify_IEATable_energy_balance.html","id":null,"dir":"Reference","previous_headings":"","what":"Confirm that an IEA-style data frame conserves energy. — verify_IEATable_energy_balance","title":"Confirm that an IEA-style data frame conserves energy. — verify_IEATable_energy_balance","text":"Energy balances confirmed (within tol) every combination grouping variables .ieatidydata.","code":""},{"path":"/reference/verify_IEATable_energy_balance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confirm that an IEA-style data frame conserves energy. — verify_IEATable_energy_balance","text":"","code":"verify_IEATable_energy_balance(   .ieatidydata,   ledger.side = \"Ledger.side\",   energy = \"E.dot\",   supply = \"Supply\",   consumption = \"Consumption\",   err = \".err\",   tol = 1e-06 )"},{"path":"/reference/verify_IEATable_energy_balance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confirm that an IEA-style data frame conserves energy. — verify_IEATable_energy_balance","text":".ieatidydata IEA-style data frame containing grouping columns (typically Country, Year, Product, others), Ledger.side column, energy column (E.ktoe). .ieatidydata grouped prior sending function. ledger.side name column .ieatidydata contains ledger side information (string). Default \"Ledger.side\". energy name column .ieatidydata contains energy data (string). Default \"E.ktoe\". supply identifier supply data ledger.side column (string). Default \"Supply\". consumption identifier consumption data ledger.side column (string). Default \"Consumption\". err name error column output. Default \".err\". tol maximum amount Supply Consumption can balance","code":""},{"path":"/reference/verify_IEATable_energy_balance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confirm that an IEA-style data frame conserves energy. — verify_IEATable_energy_balance","text":"data frame containing grouping variables additional column whose name value err. err column 0.","code":""},{"path":"/reference/verify_IEATable_energy_balance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Confirm that an IEA-style data frame conserves energy. — verify_IEATable_energy_balance","text":"sure group .ieatidydata prior calling function, shown example. energy balance every group, data frame additional column err returned. energy balance observed one groups, warning emitted.","code":""},{"path":"/reference/verify_IEATable_energy_balance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Confirm that an IEA-style data frame conserves energy. — verify_IEATable_energy_balance","text":"","code":"library(dplyr) UKEnergy2000tidy %>%   filter(Last.stage %in% c(\"Final\", \"Useful\")) %>%   group_by(Country, Year, Energy.type, Last.stage) %>%   verify_IEATable_energy_balance(energy = \"E.dot\") #> # A tibble: 2 × 7 #> # Groups:   Country, Year, Energy.type [1] #>   Country  Year Energy.type Last.stage ESupply EConsumption  .err #>   <chr>   <dbl> <chr>       <chr>        <dbl>        <dbl> <dbl> #> 1 GBR      2000 E           Final       71750        71750      0 #> 2 GBR      2000 E           Useful      25915.       25915.     0"},{"path":"/reference/verify_SUT_energy_balance.html","id":null,"dir":"Reference","previous_headings":"","what":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance","title":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance","text":"Energy balances confirmed Product (within tol) every row .sutmats.","code":""},{"path":"/reference/verify_SUT_energy_balance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance","text":"","code":"verify_SUT_energy_balance(   .sutmats = NULL,   R = \"R\",   U = \"U\",   V = \"V\",   Y = \"Y\",   tol = 1e-06,   SUT_energy_balance = \".SUT_energy_balance\" )"},{"path":"/reference/verify_SUT_energy_balance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance","text":".sutmats SUT-style data frame columns matrices, including U, V, Y columns. R resources (R) matrix name column .sutmats contains . Default \"R\". U use (U) matrix name column .sutmats contains . Default \"U\". V make (V) matrix name column .sutmatsthat contains . Default \"V\". Y final demand (Y) matrix name column .sutmats contains . Default \"Y\". tol maximum amount Supply Consumption can balance. Default 1e-6. SUT_energy_balance name booleans telling energy balance. Default \".SUT_energy_balance\".","code":""},{"path":"/reference/verify_SUT_energy_balance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance","text":"list data frame saying whether .sutmats balance.","code":""},{"path":"/reference/verify_SUT_energy_balance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance","text":"energy balance every row, .sutmats returned additional column, execution returns caller. energy balance observed one rows, warning emitted, additional column (SUT_energy_blance) indicates problem occurred, FALSE showing energy balance.","code":""},{"path":"/reference/verify_SUT_energy_balance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance","text":"","code":"library(dplyr) library(tidyr) verify_SUT_energy_balance(UKEnergy2000mats %>%                             dplyr::filter(Last.stage %in% c(\"Final\", \"Useful\")) %>%                             tidyr::spread(key = matrix.name, value = matrix),                           tol = 1e-4) #> # A tibble: 2 × 13 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 5 more variables: U_feed <list>, V <list>, Y <list>, r_EIOU <list>, #> #   .SUT_energy_balance <lgl>"},{"path":"/reference/verify_SUT_energy_balance_with_units.html","id":null,"dir":"Reference","previous_headings":"","what":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance_with_units","title":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance_with_units","text":"energy balance every row, .sutmats returned two additional columns, execution returns caller. energy balance observed one rows, warning emitted, columns named SUT_prod_energy_blance SUT_ind_energy_blance added .sutmats. FALSE indicates energy balance.","code":""},{"path":"/reference/verify_SUT_energy_balance_with_units.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance_with_units","text":"","code":"verify_SUT_energy_balance_with_units(   .sutmats = NULL,   R = \"R\",   U = \"U\",   V = \"V\",   Y = \"Y\",   S_units = \"S_units\",   tol = 1e-06,   SUT_prod_energy_balance = \".SUT_prod_energy_balance\",   SUT_ind_energy_balance = \".SUT_ind_energy_balance\" )"},{"path":"/reference/verify_SUT_energy_balance_with_units.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance_with_units","text":".sutmats SUT-style data frame containing columns R (optionally), U, V, Y, S_units. R resource (R) matrix name column .sutmats contains . Default \"R\". U use (U) matrix name column .sutmats contains . Default \"U\". V make (V) matrix name column .sutmatsthat contains . Default \"V\". Y final demand (Y) matrix name column .sutmats contains . Default \"Y\". S_units S_units matrix name column .sutmats contains . Default \"S_units\". tol maximum amount energy can balance. Default 1e-6. SUT_prod_energy_balance name booleans telling product energy balance. Default \".SUT_prod_energy_balance\". SUT_ind_energy_balance name booleans telling product energy balance. Default \".SUT_inds_energy_balance\".","code":""},{"path":"/reference/verify_SUT_energy_balance_with_units.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance_with_units","text":".sutmats additional columns.","code":""},{"path":"/reference/verify_SUT_energy_balance_with_units.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance_with_units","text":"function called side-effect testing whether energy balance .sutmats. product industry energy balance verified. Units (supplied S_units matrix) respected.","code":""},{"path":"/reference/verify_SUT_energy_balance_with_units.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Confirm that an SUT-style data frame conserves energy. — verify_SUT_energy_balance_with_units","text":"","code":"library(tidyr) verify_SUT_energy_balance_with_units(UKEnergy2000mats %>%                                        tidyr::spread(key = matrix.name, value = matrix),                                        tol = 1e-3) #> # A tibble: 4 × 14 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 6 more variables: U_feed <list>, V <list>, Y <list>, r_EIOU <list>, #> #   .SUT_prod_energy_balance <lgl>, .SUT_ind_energy_balance <lgl>"},{"path":"/reference/verify_SUT_industry_production.html","id":null,"dir":"Reference","previous_headings":"","what":"Confirm that all Industries in an SUT-style data frame produce energy. — verify_SUT_industry_production","title":"Confirm that all Industries in an SUT-style data frame produce energy. — verify_SUT_industry_production","text":"transformation process industry consumes energy (U matrix) make energy (V matrix), certainly error. (contrast, can Industries make energy consume , Industries involved Production. final demand sectors consume energy produce .) function emits warning Industry U matrix found consume energy make energy. Look industry_production_OK column output see rows .sutmats exhibit problem. Look problem_industries column output see industries exhibit problem.","code":""},{"path":"/reference/verify_SUT_industry_production.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confirm that all Industries in an SUT-style data frame produce energy. — verify_SUT_industry_production","text":"","code":"verify_SUT_industry_production(   .sutmats = NULL,   R = \"R\",   U = \"U\",   V = \"V\",   industry_production_OK = \".industry_production_OK\",   problem_industries = \".problem_industries\" )"},{"path":"/reference/verify_SUT_industry_production.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confirm that all Industries in an SUT-style data frame produce energy. — verify_SUT_industry_production","text":".sutmats SUT-style data frame containing metadata columns (typically Country, Year, Ledger.side, Product, etc.) columns SUT matrices, including U V. R resources (R) matrix name column .sutmats contains . Default \"R\". U use (U) matrix name column .sutmats contains . Default \"U\". V make (V) matrix name column .sutmatsthat contains . Default \"V\". industry_production_OK name column output tells whether industries produce something. Default \".industry_production_OK\". problem_industries name column output tells transformation processes consume energy produce anything.","code":""},{"path":"/reference/verify_SUT_industry_production.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confirm that all Industries in an SUT-style data frame produce energy. — verify_SUT_industry_production","text":".sutmats added column named value industry_production_OK.","code":""},{"path":"/reference/verify_SUT_industry_production.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Confirm that all Industries in an SUT-style data frame produce energy. — verify_SUT_industry_production","text":"","code":"library(tidyr) verify_SUT_industry_production(UKEnergy2000mats %>%                                  spread(key = matrix.name, value = matrix)) #> # A tibble: 4 × 14 #>   Country  Year Energy.type Last.stage R             S_units  U        U_EIOU   #>   <chr>   <dbl> <chr>       <chr>      <list>        <list>   <list>   <list>   #> 1 GBR      2000 E           Final      <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 2 GBR      2000 E           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 3 GBR      2000 E           Useful     <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> 4 GBR      2000 X           Services   <dbl [2 × 2]> <dbl[…]> <dbl[…]> <dbl[…]> #> # ℹ 6 more variables: U_feed <list>, V <list>, Y <list>, r_EIOU <list>, #> #   .industry_production_OK <lgl>, .problem_industries <list>"},{"path":"/reference/verify_chop_energy_sum.html","id":null,"dir":"Reference","previous_headings":"","what":"Verify energy sum after chop calculations — verify_chop_energy_sum","title":"Verify energy sum after chop calculations — verify_chop_energy_sum","text":"R Y chop calculations involve isolating rows columns R Y matrices, performing downstream swims (new_R_ps()) upstream swims (new_Y()), creating ECC portions follow row column R support creation row column Y. performing downstream upstream swim, sum isolated (chopped) ECCs equal original ECC. function performs energy balance verification.","code":""},{"path":"/reference/verify_chop_energy_sum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Verify energy sum after chop calculations — verify_chop_energy_sum","text":"","code":"verify_chop_energy_sum(   .sut_data = NULL,   tol = 1e-04,   R_mat,   U_mat,   U_feed_mat,   V_mat,   Y_mat,   R_chop_list,   U_chop_list,   U_feed_chop_list,   V_chop_list,   Y_chop_list )"},{"path":"/reference/verify_chop_energy_sum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Verify energy sum after chop calculations — verify_chop_energy_sum","text":".sut_data optional data frame energy conversion chain matrices. tol tolerance within energy balance assumed OK. Default 1e-4. R_mat, U_mat, U_feed_mat, V_mat, Y_mat matrices original ECC. R_chop_list, U_chop_list, U_feed_chop_list, V_chop_list, Y_chop_list Lists matrices different upstream swims corresponding different rows columns Y.","code":""},{"path":"/reference/verify_chop_energy_sum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Verify energy sum after chop calculations — verify_chop_energy_sum","text":"TRUE energy balance observed, FALSE otherwise.","code":""},{"path":"/reference/verify_chop_energy_sum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Verify energy sum after chop calculations — verify_chop_energy_sum","text":"various *_chop_list arguments lists matrices formed isolating (chopping) different parts R Y. matrices R_chop_list, U_chop_list, U_feed_chop_list V_chop_list, Y_chop_list sum R, U, U_feed, V, Y, respectively. public function. internal helper function chop_R() chop_Y().","code":""},{"path":"/reference/waste_edges.html","id":null,"dir":"Reference","previous_headings":"","what":"Create waste energy edges for an edge map — waste_edges","title":"Create waste energy edges for an edge map — waste_edges","text":"Waste edges created W matrix.","code":""},{"path":"/reference/waste_edges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create waste energy edges for an edge map — waste_edges","text":"","code":"waste_edges(   U_mat,   V_mat,   from = \"From\",   to = \"To\",   value = \"Value\",   product = \"Product\",   waste = \"Waste\" )"},{"path":"/reference/waste_edges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create waste energy edges for an edge map — waste_edges","text":"U_mat use matrix. V_mat make matrix. name edge list column containing source nodes. (Default \"\".) name edge list column containing destination nodes. (Default \"\".) value name edge list column containing magnitudes flows. (Default \"Value\".) product name edge list column containing product edge list flow. (Default \"Product\".) waste name waste product destination node wastes. (Default \"Waste\".)","code":""},{"path":"/reference/waste_edges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create waste energy edges for an edge map — waste_edges","text":"waste energy edges computed Umat Vmat matrices","code":""},{"path":"/reference/waste_edges.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create waste energy edges for an edge map — waste_edges","text":"waste argument supplies name waste flow (default \"Waste\") name destination waste flows.","code":""},{"path":"/reference/waste_edges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create waste energy edges for an edge map — waste_edges","text":"","code":"library(dplyr) library(matsbyname) library(tidyr) sutmats <- UKEnergy2000mats %>% spread(key = matrix.name, value = matrix) edge_list(sutmats)$`Edge list`[[1]] %>% filter(Product == \"Waste\") #>                From    To Value Product edge_id From_node_id To_node_id #> 1       Crude dist. Waste   550   Waste      31            1         13 #> 2      Diesel dist. Waste   350   Waste      32            4         13 #> 3       Elect. grid Waste   125   Waste      33            6         13 #> 4 Gas wells & proc. Waste  2075   Waste      34            9         13 #> 5          NG dist. Waste    50   Waste      35            8         13 #> 6        Oil fields Waste  2575   Waste      36            2         13 #> 7    Oil refineries Waste  5075   Waste      37            3         13 #> 8      Petrol dist. Waste   750   Waste      38           10         13 #> 9      Power plants Waste  9700   Waste      39            5         13"},{"path":"/reference/write_ecc_to_excel.html","id":null,"dir":"Reference","previous_headings":"","what":"Write energy conversion chain matrices in an Excel file — write_ecc_to_excel","title":"Write energy conversion chain matrices in an Excel file — write_ecc_to_excel","text":"often helpful see energy conversion chain (ECC) matrices Excel format, arranged spatially. function takes ECC matrices writes Excel file.","code":""},{"path":"/reference/write_ecc_to_excel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write energy conversion chain matrices in an Excel file — write_ecc_to_excel","text":"","code":"write_ecc_to_excel(   .psut_data = NULL,   path,   overwrite_file = FALSE,   pad = 2,   include_io_mats = FALSE,   R = Recca::psut_cols$R,   U = Recca::psut_cols$U,   V = Recca::psut_cols$V,   Y = Recca::psut_cols$Y,   r_eiou = Recca::psut_cols$r_eiou,   U_eiou = Recca::psut_cols$U_eiou,   U_feed = Recca::psut_cols$U_feed,   S_units = Recca::psut_cols$S_units,   .wrote_mats_colname = \"Wrote mats\",   UV_bg_color = \"#FDF2D0\",   RY_bg_color = \"#D3712D\",   calculated_bg_color = \"#D9D9D9\",   col_widths = 7 )"},{"path":"/reference/write_ecc_to_excel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write energy conversion chain matrices in an Excel file — write_ecc_to_excel","text":".psut_data list data frame energy conversion chains. path path Excel file created. overwrite_file boolean tells whether want overwrite file path, already exists. pad number rows columns adjacent matrices Excel sheet. Default 2. include_io_mats boolean tells whether include input-output matrices worksheets written function. Input-output matrices obtained calc_io_mats(). Default FALSE. R, U, U_feed, U_eiou, r_eiou, V, Y, S_units Names ECC matrices actual matrices. See Recca::psut_cols. .wrote_mats_colname name outgoing column tells whether worksheet written successfully. Default \"Wrote mats\". UV_bg_color color cells containing U V matrices. Default creamy yellow. RY_bg_color color cells containing R Y matrices. Default rust color. calculated_bg_color color cells containing calculated matrices. Default gray. col_widths widths columns matrices. Default 7 save space.","code":""},{"path":"/reference/write_ecc_to_excel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write energy conversion chain matrices in an Excel file — write_ecc_to_excel","text":"unmodified version .psut_data (NULL) list incoming matrices.","code":""},{"path":"/reference/write_ecc_to_excel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write energy conversion chain matrices in an Excel file — write_ecc_to_excel","text":".psut_data PSUT data frame, row written different tab output file path.","code":""},{"path":"/reference/write_ecc_to_excel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write energy conversion chain matrices in an Excel file — write_ecc_to_excel","text":"","code":"if (FALSE) { ecc <- UKEnergy2000mats %>%   tidyr::spread(key = \"matrix.name\", value = \"matrix\") ecc_temp_path <- tempfile(pattern = \"write_excel_ecc_test_file\", fileext = \".xlsx\") write_ecc_to_excel(ecc, path = ecc_temp_path, overwrite = TRUE) }"},{"path":"/news/index.html","id":"recca-0151-2023-11-15","dir":"Changelog","previous_headings":"","what":"Recca 0.1.51 (2023-11-15)","title":"Recca 0.1.51 (2023-11-15)","text":"Fixed bug calc_agg_eta_pfus() efficiencies calculated incorrectly primary energy different depending value Last.stage column. Still 748 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0150-2023-11-15-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.50 (2023-11-15)","title":"Recca 0.1.50 (2023-11-15)","text":"New function calc_agg_eta_pfus() calculates primary, final, useful, services aggregates associated efficiencies. Now 748 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0149-2023-11-03-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.49 (2023-11-03)","title":"Recca 0.1.49 (2023-11-03)","text":"remove_neu() now also removes non-energy use products rows Y. Now re-exporting IEATools::nonenergy_use. Now 727 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0148-2023-10-27-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.48 (2023-10-27)","title":"Recca 0.1.48 (2023-10-27)","text":"New function remove_neu() eliminates “Non-energy useX” (“X” additional string ” Industry”) final demand matrix (Y) swims upstream new_Y() remove primary stage useful stage energy associated Non-energy use. Now 717 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0147-2023-10-23-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.47 (2023-10-23)","title":"Recca 0.1.47 (2023-10-23)","text":"Fixed bug EIOU efficiency calculated calc_eta_fu_Y_eiou() gave 0 matrix. Hat-tip Emmanuel Aramendia spotting issue assisting debugging. Still 712 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0146-2023-10-16-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.46 (2023-10-16)","title":"Recca 0.1.46 (2023-10-16)","text":"Minor updates documentation. argument pfu_aggregates() now correctly chooses default value (“Total”) unspecified. Still 712 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0145-2023-09-21-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.45 (2023-09-21)","title":"Recca 0.1.45 (2023-09-21)","text":"Complete aggregation vignette. Still 712 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0144-2023-09-21-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.44 (2023-09-21)","title":"Recca 0.1.44 (2023-09-21)","text":"Fixed bug node_edge_list() caused failure rowtypes coltypes columns present. Still 712 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0143-2023-08-18-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.43 (2023-08-18)","title":"Recca 0.1.43 (2023-08-18)","text":"Completed aggregations vignette. New function pfu_aggregates() work progress (eventually) make calculating primary, final, useful aggregates easier. Breaking change: U U_feed arguments removed finaldemand_aggregates(), replaced U_eiou, calculated U U_feed internally, U_eiou assumed present energy conversion chain representations. argument finaldemand_aggregates() can now “Industry”, treated synonym “Sector”. Now returning S_units_prime column chopping matrices. Wrapped matrices .matrix() guard sparse matrices causing failure calc_yqfgW(). Now 712 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0142-2023-06-02-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.42 (2023-06-02)","title":"Recca 0.1.42 (2023-06-02)","text":"Fixed bug writing Matrix objects failed write_ecc_to_excel(). Thanks Pierre Jacques reporting problem. New function calc_eta_fu_Y_eiou() calculates final--useful efficiencies every entry Y U_EIOU matrices, responding feature request Pierre Jacques. Now 641 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0141-2023-04-28-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.41 (2023-04-28)","title":"Recca 0.1.41 (2023-04-28)","text":"Responded policy changes matsindf::matsindf_apply() setting default arguments NULL several internal functions. region_aggregates() gains drop_na_few argument tells whether eliminate rows NA few_colname. “Resources - Crude” –> “Resources [Crude]” “Crude - Fields” –> “Crude [Fields]” “MD - Car engines” –> “MD [Car engines]” changes align example ECC naming conventions now use throughout package various pipelines. chop_R() now also chops rows (industries), since now including exogenous sources energy R matrix. New function get_all_products_and_industries() generates lists unique product industry names ECC aware RCLabels-type pieces row column names. Net EROI calculations removed, gross values calculated. Still 632 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0140-2023-01-25-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.40 (2023-01-25)","title":"Recca 0.1.40 (2023-01-25)","text":"version contains fixes continuous integration build system. changes code. Remove use Remotes: field DESCRIPTION. Instead, now using pkgdepends syntax extra-packages: fields R_CMD-check.yaml test-coverage.yaml. Update latest version GitHub action test coverage. Still 672 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0139-2023-01-24-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.39 (2023-01-24)","title":"Recca 0.1.39 (2023-01-24)","text":"Tests passing test rigs GitHub Actions. Tests failing due new code correctly detects unit errors (inhomogeneity) upstream swim calculations services last stage ECC. Move tests associated verify_cols_missing() Recca package matsindf. tests didn’t belong Recca, verify_cols_missing() longer Recca. Eliminated data frame rows couple tests producing NA values due unit inhomogeneity. Switched simpler formulas derived MKH new_R_ps(). Eliminated tidyselect warnings. write_ecc_to_excel() now ensures columns U rows V , even means adding zero columns U zero rows V. change makes Excel calculations easier. chopR() now checks ability swim downstream R_prime = R re-create original energy conversion chain, thereby bringing consistency chopY(). approach identifies numerical precision errors cause problem. chopR() now uses calc_io_mats(direction = \"downstream\"), thereby consistently using calc_io_mats() upstream downstream swims. calc_io_mats() gains new argument direction tells whether input-output matrices “upstream” “downstream” swims. finaldemand_aggregates() now produces true 0 instead 1x1 matrix without row column labels columns names U_EIOU Y match fd_sectors. Fixed two bugs new_Y(). compensatory formula errors appeared edge cases. Aggregations now optional (default) chop_R() chop_Y(). Renamed effects_aggregates() footprint_aggregates() chop_R() chop_Y(). New function effects_aggregates() swims downstream R matrix final demand column (energy carrier) R matrix calculates primary final demand aggregates. footprint_aggregates() now checks chopped ECCs sum original ECC every calculation. region_aggregates() now correctly eliminates few_colname incoming data frame rows. footprint_aggregates() now also includes *_prime_colname matrices nested data frame. calc_io_mats() calc_L() gain method tol arguments control matrix inversion. calc_eta_pfd() now includes columns names efficiencies output. feature assist pivoting efficiencies later. New function footprint_aggregates() calculates primary final demand aggregates isolated row column Y. new_Y() now also produced matrices U_feed, U_eiou, r_eiou output. W matrix longer included output new_Y(). W can always calculated V^T - U. New function write_ecc_to_excel() stores ECCs spatial format Excel. ECC matrices written Excel file: R, U, V, Y, U_feed, U_eiou, r_eiou, S_units. primary_aggregates() finaldemand_aggregates() longer require p_industries fd_sectors present incoming list data frame. Rather, p_industries fd_sectors treated parameters apply items incoming list rows incoming data frame. change brings consistency functions use matsindf::matsindf_apply() internally. New function group_aggregates() aggregates PSUT matrices according aggregation map. New function despecified_aggregates() aggregates PSUT matrices piece row column labels. New argument add_net_gross_cols primary_aggregates() tells whether add net gross primary energy columns. (Net gross primary energy aggregate columns contain identical values, presence net gross columns may make easier mesh results finaldemand_aggregates() function, produces net gross columns different.) aggregate_regions() now returns empty data frame expected columns input data frame rows. Now 672 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0138-2022-04-02-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.38 (2022-04-02)","title":"Recca 0.1.38 (2022-04-02)","text":"Removed unnecessary assertion matsbyname available aggregation functions. Eliminated finaldemand_aggregates_with_units(), nobody using . New function calc_eta_pfd() calculates gross net efficiencies primary final demand. New function region_aggregates() calculates regional aggregates according columns data frame. New look pkgdown website. extend_to_exergy() gains new arguments mat_piece, phi_piece, notation, prepositions enable flexible row column name matching various matrices phi vectors. addition, extend_to_exergy() now uses matsbyname::vec_from_store_byname() internally correctly handle hatized vector multiplication. Now 556 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0137-2021-10-13-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.37 (2021-10-13)","title":"Recca 0.1.37 (2021-10-13)","text":"Added details Recca vignette, including additional equations embodied matrices. New function extend_to_exergy() calculates exergy representation energy conversion chain given energy representation energy conversion chain. Now 530 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0136-2021-09-10-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.36 (2021-09-10)","title":"Recca 0.1.36 (2021-09-10)","text":"Get started file updated. matrices definitions (G, H, E) needed updated. Removed redundant IO matrices (C_feed, D_feed, O_feed). 512 tests Test coverage remains 100%","code":""},{"path":"/news/index.html","id":"recca-0135-2021-08-20-doi","dir":"Changelog","previous_headings":"","what":"Recca 0.1.35 (2021-08-20)","title":"Recca 0.1.35 (2021-08-20)","text":"R matrix formulation now adopted input output calculations, upstream downstream swims, well embodied energy calculations. Added new file new_R_ps_example.xlsx demonstrates equations swimming “downstream.” Updated stable active status badges.","code":""},{"path":"/news/index.html","id":"recca-0134-2021-04-11","dir":"Changelog","previous_headings":"","what":"Recca 0.1.34 (2021-04-11)","title":"Recca 0.1.34 (2021-04-11)","text":"Fix lingering problems R-CMD-check move GitHub Actions continuous integration testing. Still 435 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0133-2021-04-11","dir":"Changelog","previous_headings":"","what":"Recca 0.1.33 (2021-04-11)","title":"Recca 0.1.33 (2021-04-11)","text":"Move Travis GitHub Actions continuous integration testing. Still 435 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0132-2021-03-16","dir":"Changelog","previous_headings":"","what":"Recca 0.1.32 (2021-03-16)","title":"Recca 0.1.32 (2021-03-16)","text":"Modified aggregation functions use simpler (verbose) statements choose aggregation functions. change works around error calling aggregation functions packages. Now 435 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0131-2021-02-25","dir":"Changelog","previous_headings":"","what":"Recca 0.1.31 (2021-02-25)","title":"Recca 0.1.31 (2021-02-25)","text":"New argument aggregation functions: pattern_type tells match primary final demand sector names aggregation. Now 421 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0130-2021-02-22","dir":"Changelog","previous_headings":"","what":"Recca 0.1.30 (2021-02-22)","title":"Recca 0.1.30 (2021-02-22)","text":"Fixed bugs finaldemand_aggregates() finaldemand_aggregates_with_units() argument fd_sectors respected gross energy aggregation. Now 417 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0129-2021-02-01","dir":"Changelog","previous_headings":"","what":"Recca 0.1.29 (2021-02-01)","title":"Recca 0.1.29 (2021-02-01)","text":"method_q_calculation argument added calc_io_mats() function. enables calculate q vector using either consumption-side supply-side perspective.","code":""},{"path":"/news/index.html","id":"recca-0128-2020-12-23","dir":"Changelog","previous_headings":"","what":"Recca 0.1.28 (2020-12-23)","title":"Recca 0.1.28 (2020-12-23)","text":"New function find_p_industry_names() looks R, V, Y matrices find names primary industries (industries produce primary energy). function looks prefixes among row (R V) column (Y) names identify primary industries. Now 416 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0127-2020-12-08","dir":"Changelog","previous_headings":"","what":"Recca 0.1.27 (2020-12-08)","title":"Recca 0.1.27 (2020-12-08)","text":"Move IEA aggregation functions package IEATools package. Now using package constants names aggregate columns. Column names match similar names IEATools. Now using better function-matching -selecting code finaldemand_aggregates() Now 411 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0126-2020-12-06","dir":"Changelog","previous_headings":"","what":"Recca 0.1.26 (2020-12-06)","title":"Recca 0.1.26 (2020-12-06)","text":"primary_aggregates(), finaldemand_aggregates(), andfinaldemand_aggregates_with_units()now require column ofp_industriesorfd_sectorsinstead vector    .sutdatais data frame.   change works around problem common use case    caller create thefd_sectorscolumn column names ofY` vectors data frame. Use R markdown documentation (`term` instead \\code{term}). Use package constants column name arguments (Recca::sankey_cols$sankey instead “Sankey”). Now 413 tests, passing. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0125-2020-09-17","dir":"Changelog","previous_headings":"","what":"Recca 0.1.25 (2020-09-17)","title":"Recca 0.1.25 (2020-09-17)","text":"New author Emmanuel Aramendia. Welcome! Test coverage now 100%. Created new function calc_embodied_EIOU() calculates different embodied EIOU matrices given final demand Created new function calc_erois() calculates different vector product-level industry-level EROIs using different assumptions. Created new function calc_E_EIOU() calculates E_EIOU matrix EIOU energy use unit industry output, split product. also calculates direct energy extension vector e_EIOU total EIOU energy use unit industry output. Fixed bug one vignettes related move U_excl_EIOU U_feed. prep_UK2000.R prep_perfectsub.R scripts fixed work IEATools, now uses U_feed instead U_excl_EIOU. Now 407 tests, pass. Test coverage remains 100%.","code":""},{"path":"/news/index.html","id":"recca-0124-2020-03-17","dir":"Changelog","previous_headings":"","what":"Recca 0.1.24 (2020-03-17)","title":"Recca 0.1.24 (2020-03-17)","text":"Now 337 tests, passing. Test coverage remains 100%. Now using U_feed everywhere. Calculate Z_feed A_feed calc_io_mats().","code":""},{"path":"/news/index.html","id":"recca-0123-2020-03-17","dir":"Changelog","previous_headings":"","what":"Recca 0.1.23 (2020-03-17)","title":"Recca 0.1.23 (2020-03-17)","text":"Added ... argument make_sankey(), passes arguments networkD3::sankeyNetwork().","code":""},{"path":"/news/index.html","id":"recca-0122-2020-05-02","dir":"Changelog","previous_headings":"","what":"Recca 0.1.22 (2020-05-02)","title":"Recca 0.1.22 (2020-05-02)","text":"Fixed bug primary_aggregates(). primary_aggregates() assuming either R V matrix () contain industries counted total primary energy supply (production, imports, exports, etc.). However, true. R resource industries, imports, exports, marine aviation bunkers, stock changes excluded R. However, imports, exports, marine aviation bunkers, stock changes included total primary energy supply. removed conditional xor check appearance TPES industries R V. Everything seems working now.","code":""},{"path":"/news/index.html","id":"recca-0121-2020-03-27","dir":"Changelog","previous_headings":"","what":"Recca 0.1.21 (2020-03-27)","title":"Recca 0.1.21 (2020-03-27)","text":"Now 332 tests, pass. Test coverage now 100%. Implemented energy balance checking new_R_ps() tolerance, default 1e-6.","code":""},{"path":"/news/index.html","id":"recca-0120-2020-03-27","dir":"Changelog","previous_headings":"","what":"Recca 0.1.20 (2020-03-27)","title":"Recca 0.1.20 (2020-03-27)","text":"R V matrices R V arguments nothing supplied R argument R + V supplied V argument. Worked around bug openxlsx::read.xlsx() HTML-escapes referenced cells contain “&”, “<”, “>”. See https://github.com/awalker89/openxlsx/issues/393 details. Switched using openxlsx package reading data directly Excel files, eliminating need export .csv files UKEnergy2000tidy data frame. primary_aggregates() now properly handles PSUT matrices formulated R matrices. Fixed typos Recca.Rmd vignette.","code":""},{"path":"/news/index.html","id":"recca-0119-2020-02-19","dir":"Changelog","previous_headings":"","what":"Recca 0.1.19 (2020-02-19)","title":"Recca 0.1.19 (2020-02-19)","text":"Removed dependency package qgraph. qgraph depended upon graph, apparently longer available CRAN. dependency qgraph graphical representations ECCs. , graphical representations ECCs presently implemented Recca. Future versions Recca may implement graphical representations. can reassess packages graphing Sankey diagrams later date.","code":""},{"path":"/news/index.html","id":"recca-0118-2020-01-17","dir":"Changelog","previous_headings":"","what":"Recca 0.1.18 (2020-01-17)","title":"Recca 0.1.18 (2020-01-17)","text":"Updates synchronize recent changes packages. particular, one place grouping column data frame NA entries causing warning emitted. Now, grouping happens splitting data frame rows NA entries without. Grouping sorting happens rows without NA values.","code":""},{"path":"/news/index.html","id":"recca-0117-2019-02-25","dir":"Changelog","previous_headings":"","what":"Recca 0.1.17 (2019-02-25)","title":"Recca 0.1.17 (2019-02-25)","text":"First draft completed vignette. Removed ecc_layout(). used, create_sankey() function, anyway.","code":""},{"path":"/news/index.html","id":"recca-0116-2019-02-16","dir":"Changelog","previous_headings":"","what":"Recca 0.1.16 (2019-02-16)","title":"Recca 0.1.16 (2019-02-16)","text":"Now automatically building Travis. Added new reverse() function change flow direction ECC. reverse() useful downstream swim functions. longer summing columns U matrix. Instead, cleaning 0 columns U comparing names columns original U. Eliminated @importFrom statements fully-qualifying function calls. Test coverage now 100%.","code":""},{"path":"/news/index.html","id":"recca-0115-2019-01-09","dir":"Changelog","previous_headings":"","what":"Recca 0.1.15 (2019-01-09)","title":"Recca 0.1.15 (2019-01-09)","text":"First draft new-functions vignette now complete, including demonstrations new_R_ps() new_k_ps() functions.","code":""},{"path":"/news/index.html","id":"recca-0114-2019-01-07","dir":"Changelog","previous_headings":"","what":"Recca 0.1.14 (2019-01-07)","title":"Recca 0.1.14 (2019-01-07)","text":"New function make_sankey() says: makes Sankey diagram. make_sankey() first function optionally uses resource (R) matrix. edge_list() also now accepts resource (R) matrix input. vignette describing new*() functions now section new_R_ps().","code":""},{"path":"/news/index.html","id":"recca-0113-2018-12-21","dir":"Changelog","previous_headings":"","what":"Recca 0.1.13 (2018-12-21)","title":"Recca 0.1.13 (2018-12-21)","text":"calc_F_footprint_effects() now cleans rows columns (deletes rows columns containing 0s) calculating row column fractions. calc_F_footprint_effects() now calculates row column fractions using matsbyname::fractionize_byname(), providing speed boost.","code":""},{"path":"/news/index.html","id":"recca-0112-2018-12-02","dir":"Changelog","previous_headings":"","what":"Recca 0.1.12 (2018-12-02)","title":"Recca 0.1.12 (2018-12-02)","text":"Added vignette discussing interactions among new_* functions.","code":""},{"path":"/news/index.html","id":"recca-0111-2018-12-02","dir":"Changelog","previous_headings":"","what":"Recca 0.1.11 (2018-12-02)","title":"Recca 0.1.11 (2018-12-02)","text":"Updates embodied energy calculations conform updated matsbyname::hatinv_byname() handles 0 values better.","code":""},{"path":"/news/index.html","id":"recca-0110-2018-11-29","dir":"Changelog","previous_headings":"","what":"Recca 0.1.10 (2018-11-29)","title":"Recca 0.1.10 (2018-11-29)","text":"Now importing magrittr pipe high level. Now using matsbyname::hatinv_byname() function instead matsbyname::hatize_byname() %>% matsbyname::invert_byname(). Breaking change: arguments Recca functions longer named *_colname. ’m standardizing argument names. new approach yields better code calling functions individual matrices: every matrix needs named. using functions operate data frame default values column names mean data frames can piped functions called parameters. Furthermore, change allows lists output previous functions used later function calls without name changes. example, f1 produces list l named item z, z input f2. previous naming convention require user mapping z z_colname: f2(z_colname = l$z). new naming convention allows f2(l), l contains named item z, f2 argument new named z (named z_colname ). ways, new argument naming convention elegant previous *_colname approach. Building vignette describes package. New test simple, 1-industry ECC. Now 316 tests.","code":""},{"path":"/news/index.html","id":"recca-019-2018-11-08","dir":"Changelog","previous_headings":"","what":"Recca 0.1.9 (2018-11-08)","title":"Recca 0.1.9 (2018-11-08)","text":"Breaking change: reconstruct_UV() –> new_Y(). change allows several new_*() functions assess changes ECC part ECC changes. New function new_k_ps() assesses changes ECC proportion inputs industry change assumption perfect substitution. New functions products_unit_homogeneous(), inputs_unit_homogeneous(), outputs_unit_homogeneous() test whether products, inputs industries, outputs industries unit-homogeneous.","code":""},{"path":"/news/index.html","id":"recca-018-2018-07-27","dir":"Changelog","previous_headings":"","what":"Recca 0.1.8 (2018-07-27)","title":"Recca 0.1.8 (2018-07-27)","text":"Added new function node_list creates node list edge list.","code":""},{"path":"/news/index.html","id":"recca-017-2018-07-26","dir":"Changelog","previous_headings":"","what":"Recca 0.1.7 (2018-07-26)","title":"Recca 0.1.7 (2018-07-26)","text":"Added new function edge_list creates edge list U, V, Y matrices.","code":""},{"path":"/news/index.html","id":"recca-016-2018-07-09","dir":"Changelog","previous_headings":"","what":"Recca 0.1.6 (2018-07-09)","title":"Recca 0.1.6 (2018-07-09)","text":"Fixed bug verify_IEATable_energy_balance. err –> .name(err). Fixed bug S_units_from_tidy. Needed change argument name matsindf::collapse_to_matrices values –> matvals.","code":""},{"path":"/news/index.html","id":"recca-015-2018-07-02","dir":"Changelog","previous_headings":"","what":"Recca 0.1.5 (2018-07-02)","title":"Recca 0.1.5 (2018-07-02)","text":"Added column output verify_SUT_industry_production indicates industries problematic.","code":""},{"path":"/news/index.html","id":"recca-014-2018-06-28","dir":"Changelog","previous_headings":"","what":"Recca 0.1.4 (2018-06-28)","title":"Recca 0.1.4 (2018-06-28)","text":"Fixed bug verify_IEATable_energy_balance function: !!err –> !!.name(err)","code":""},{"path":"/news/index.html","id":"recca-013-2018-06-27","dir":"Changelog","previous_headings":"","what":"Recca 0.1.3 (2018-06-27)","title":"Recca 0.1.3 (2018-06-27)","text":"Added verify_IEATable_energy_balance function","code":""},{"path":"/news/index.html","id":"recca-012-2018-05-20","dir":"Changelog","previous_headings":"","what":"Recca 0.1.2 (2018-05-20)","title":"Recca 0.1.2 (2018-05-20)","text":"functions now use matsindf::matsindf_apply(). F functions now internal energy balance checks. Much code API cleanup. Note API changes expected, particularly name changes *_colname arguments.","code":""},{"path":"/news/index.html","id":"recca-011-2018-04-16","dir":"Changelog","previous_headings":"","what":"Recca 0.1.1 (2018-04-16)","title":"Recca 0.1.1 (2018-04-16)","text":"New function calc_io_mats: calculate input-output (PSUT version) matrices, including y, q, g, W, Z, D, C, , L_ixp, L_pxp. New function reconstruct_UV(): Reconstruct energy conversion chain (new U V matrices) new final demand matrix (Y)","code":""},{"path":"/news/index.html","id":"recca-010-2018-04-12","dir":"Changelog","previous_headings":"","what":"Recca 0.1.0 (2018-04-12)","title":"Recca 0.1.0 (2018-04-12)","text":"Initial version UKEnergy2000tidy, UKEnergy2000mats Functions check energy balance Functions perform aggregation calculations primary energy final demand Stub LaTeX vignette","code":""}]

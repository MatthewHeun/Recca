#' Layout for graph representation of an energy conversion chain
#'
#' Industries and products are interleaved from left to right,
#' starting with the first industry, followed by the first product.
#' Industries and products alternate until all products are exhausted.
#' Finally, the last industry (which should be final demand) is placed at the far right.
#'
#' @param Industries a data frame consisting of columns named
#'        \code{industry_colname}, \code{stage_colname}, and \code{group_colname}.
#'        Entries in \code{industry_colname} must be names of industries.
#'        Entries in \code{stage_colname} must be names of left-to-right stages in the ECC.
#'        Industries (or sectors) in final demand must be included in the \code{Industries}
#'        data frame.
#'        Industries that provide "storage" must also be included in the \code{Industries}
#'        data frame (such as Stock changes, International aviation and marine bunkers, and
#'        Statistical differences), their \code{stage_colname} value being \code{storage_stagename}.
#'        All industries with \code{storage_stagename} are laid out
#'        along the top of the network.
#'        The left-to-right order of stages in the network layout generated by this function
#'        is taken from the order of appearance of stages in the \code{stage_colname} column.
#'        The left-to-right order of storage industries is given by
#'        the appearance order of the industries in \code{industry_colname}.
#'        Entries in \code{group_colname} give groups of industries or products to keep together
#'        at each stage. The top-to-bottom order of groups is taken from the appearance order
#'        in \code{group_colname}.
#' @param Products a data frame consisting of same columns as \code{Industries},
#'        except that \code{product_colname} takes the place of \code{industry_colname}.
#' @param industry_colname the name of the column in \code{Industries} containing
#'        names of industries (a string).
#'        Default is "Industries".
#' @param product_colname the name of the column in \code{Products} containing
#'        names of products (a string).
#'        Default is "Products".
#' @param stage_colname the name of the columns in \code{Industries} and \code{Products}
#'        containing names of stages (a string).
#'        The left-to-right order of stages in the network layout
#'        is determined by the top-to-bottom
#'        order in which stage names appear in the
#'        \code{Industries} and \code{Products} data frames.
#' @param group_colname the name of the column in \code{Industries} and \code{Products}
#'        containing industries and products that should be grouped together vertically
#'        at a stage (a string).
#'        The top-to-bottom order of groups at a stage is give by the order of appearance
#'        in \code{group_colname}.
#' @param storage_stagename the name of the stage in \code{stage_colname} of \code{Industries}
#'        that identifies a "storage" industry (a string).
#'        Default is "Storage".
#' @param node_name_colname the name of the output column containing node names
#'        (industries and products).
#' @param x_colname the name of the output column containing x coordinates for each node.
#' @param y_colname the name of the output column containing y coordinates for each node.
#'
#' @return a data frame with three columns.
#'         The first column contains node names and is named \code{node_name_colname}.
#'         The second column contains x coordinates for the nodes and is named \code{x_colname}.
#'         The third column contains y coordinates for the nodes and is named \code{y_colname}.
#'
#' @importFrom rlang :=
#' @importFrom rlang .data
#' @importFrom magrittr %>%
#' @importFrom magrittr set_rownames
#' @importFrom dplyr mutate
#' @importFrom dplyr filter
#' @importFrom dplyr select
#' @importFrom dplyr rename
#' @importFrom dplyr arrange
#' @importFrom dplyr left_join
#' @importFrom dplyr group_by
#' @importFrom dplyr count
#' @importFrom tibble rownames_to_column
#'
#' @export
ecc_layout <- function(Industries,
                       Products,
                       industry_colname = "Industry",
                       product_colname = "Product",
                       stage_colname = "Stage",
                       storage_stagename = "Storage",
                       group_colname = "Group",
                       # Output columns
                       node_name_colname = "Node_name",
                       x_colname = "x",
                       y_colname = "y"){
  # Extract storage industries from the Industries data frame.
  Storage <- Industries %>%
    filter((!!as.name(stage_colname)) == storage_stagename)
  Industries_less_Storage <- Industries %>%
    filter((!!as.name(stage_colname)) != storage_stagename)
  # Ensure that the number of industry stages (less storage)
  # is one more than the number of product stages.
  N_industry_stages <- Industries_less_Storage %>%
    select(!!as.name(stage_colname)) %>%
    unique() %>%
    nrow()
  N_product_stages <- Products %>%
    select(!!as.name(stage_colname)) %>%
    unique() %>%
    nrow()
  stopifnot(N_industry_stages - N_product_stages == 1)
  # Set groups for the Group variable based on order of appearance.
  # These groups will be used later for ordering the y coordinates of nodes.
  grps <- rbind(Industries_less_Storage %>% select(!!as.name(group_colname)),
                Products %>% select(!!as.name(group_colname))) %>%
    filter(!is.na(!!as.name(group_colname))) %>%
    unique()
  grps <- set_rownames(grps, 1:nrow(grps))
  # Set levels for groups in order of their appearance.
  # These levels will be used later for calculating the y coordinates for the nodes.
  Industries <- Industries %>%
    mutate(
      !!as.name(group_colname) := factor(!!as.name(group_colname), levels = grps[[group_colname]])
    )
  Industries_less_Storage <- Industries_less_Storage %>%
    mutate(
      !!as.name(group_colname) := factor(!!as.name(group_colname), levels = grps[[group_colname]])
    )
  Products <- Products %>%
    mutate(
      !!as.name(group_colname) := factor(!!as.name(group_colname), levels = grps[[group_colname]])
    )
  Storage <- Storage %>%
    mutate(
      !!as.name(group_colname) := factor(!!as.name(group_colname), levels = grps[[group_colname]])
    )
  # Left-to-right order across the network is taken from the order of appearance
  # in the respective data frames.
  inds <- Industries_less_Storage %>% select(!!as.name(industry_colname)) %>% unique()
  prods <- Products %>% select(!!as.name(product_colname)) %>% unique()
  stor <- Storage %>% select(!!as.name(industry_colname)) %>% unique()
  # Make data frames of stage numbers.
  # This process is easy for industries and products
  # but takes additional calculations for storage industries (later).
  i_stage_colname <- paste0("i_", stage_colname)
  Industry_stage_order <- data.frame(temp = Industries_less_Storage %>%
                                       select(!!as.name(stage_colname)) %>%
                                       unique()) %>%
    rownames_to_column(var = i_stage_colname) %>%
    mutate(
      !!as.name(i_stage_colname) := as.numeric(!!as.name(i_stage_colname)),
      !!as.name(i_stage_colname) := 2 * (!!as.name(i_stage_colname)) - 1
    )
  Product_stage_order <- data.frame(temp = Products %>%
                                      select(!!as.name(stage_colname)) %>%
                                      unique()) %>%
    rownames_to_column(var = i_stage_colname) %>%
    mutate(
      !!as.name(i_stage_colname) := as.numeric(!!as.name(i_stage_colname)),
      !!as.name(i_stage_colname) := 2 * (!!as.name(i_stage_colname))
    )
  # Join these *_stage_order data frames
  Stage_coords <- rbind(Industry_stage_order %>%
                          rename(!!as.name(x_colname) := !!as.name(i_stage_colname)),
                        Product_stage_order %>%
                          rename(!!as.name(x_colname) := !!as.name(i_stage_colname))) %>%
    arrange(!!as.name(x_colname))
  # Now work on storage industries.
  # Figure out where to place them in x dimension.
  x_max <- max(Industry_stage_order[[i_stage_colname]], Product_stage_order[[i_stage_colname]])
  # 1-based coordinate system for stages.
  # Align storage industries with other industries.
  # Doing so will avoid vertical flows from products to storage.
  x_center <- (x_max + 1) / 2
  # Find out how many storage industries we have.
  N_storage <- nrow(stor)
  # Find x coordinate of first Storage industry
  x_first_storage <- x_center - (N_storage - 1) / 2
  # Join with list of storage industries
  Storage_coords <- data.frame(temp = Storage %>%
                                 select(!!as.name(industry_colname)) %>%
                                 unique()) %>%
    mutate(
      !!as.name(x_colname) := seq(from = x_first_storage,
                                  to = x_first_storage - 1 + N_storage,
                                  by = 1)
    ) %>%
    left_join(Storage, by = industry_colname) %>%
    rename(
      !!as.name(node_name_colname) := !!as.name(industry_colname)
    )

  # Join Stage_coords to a list of industries and products to create the list of nodes.
  Node_coords <- rbind(
    Industries_less_Storage %>% rename(!!as.name(node_name_colname) := !!as.name(industry_colname)),
    Products %>% rename(!!as.name(node_name_colname) := !!as.name(product_colname))
  ) %>%
    left_join(Stage_coords, by = stage_colname) %>%
    group_by(!!as.name(x_colname), !!as.name(group_colname)) %>%
    # Put nodes in correct order.
    # First group on stage (x coordinate) followed by
    # the Group within each stage.
    arrange(!!as.name(x_colname), !!as.name(group_colname))

  # At this point, all x coordinates have been decided and are in the Node_coords data frame.
  # Furthermore, the Node_coords data frame is in the correct order for y coordinates.
  # So work on y coordinates.
  # Figure out the number of nodes in each stage
  N_nodes <- Node_coords %>%
    group_by(!!as.name(stage_colname)) %>%
    count()
  y_max <- max(N_nodes$n)
  y_center <- (y_max + 1) / 2

  # Use dplyr::do to make y coordinates
  Node_coords2 <- Node_coords %>%
    # Re-group according to x_colname only,
    # thereby ensuring that we apply y coords to each stage independently.
    group_by(!!as.name(x_colname)) %>%
    mutate(
      # Add a column for the row number in each group.
      i_group = row_number()
    ) %>%
    # Add a column (n) that gives the number of nodes in each stage
    left_join(N_nodes, by = stage_colname) %>%
    mutate(
      # Calculate the column of y coordinates
      # using the number within each group (i_group) and
      # the total number of nodes in the group (n)
      !!as.name(y_colname) := y_center + (i_group - n)
    )
    # Figure out y coordinate for each stage independently.
    do(
      !!as.name(y_colname) := .data %>%
        remove_rownames() %>%
        rownames() %>%
        unlist() %>%
        print()
    )





  # # When we know y_max, we can put the Storage industries one level higher
  # Storage_coords <- Storage_coords %>%
  #   mutate(
  #     y = y_max + 1
  #   )
  #
  #
  #
  #
  #
  # # rbind with coordinates for storage nodes
  # rbind(Storage_coords) %>%
  #
  #


  return(Node_coords)
}

#' Layout for network representation of an energy conversion chain
#'
#' Industries and products are interleaved from left to right,
#' starting with the first industry, followed by the first product.
#' Industries and products alternate until all products are exhausted.
#' Finally, the last industry (which should be final demand) is placed at the far right.
#' Storage industries are arranged across the top of the network.
#'
#' @param Industries a data frame consisting of columns named
#'        \code{industry_colname}, \code{stage_colname}, and \code{group_colname}.
#'        Entries in \code{industry_colname} must be names of industries.
#'        Entries in \code{stage_colname} must be names of left-to-right stages in the ECC.
#'        Industries (or sectors) in final demand must be included in the \code{Industries}
#'        data frame.
#'        Industries that provide "storage" must also be included in the \code{Industries}
#'        data frame (such as Stock changes, International aviation and marine bunkers, and
#'        Statistical differences), their \code{stage_colname} value being \code{storage_stagename}.
#'        All industries with \code{storage_stagename} are laid out
#'        along the top of the network.
#'        The left-to-right order of stages in the network layout generated by this function
#'        is taken from the order of appearance of stages in the \code{stage_colname} column.
#'        The left-to-right order of storage industries is given by
#'        the appearance order of the industries in \code{industry_colname}.
#'        Entries in \code{group_colname} give groups of industries or products to keep together
#'        at each stage. The top-to-bottom order of groups is taken from the appearance order
#'        in \code{group_colname}.
#' @param Products a data frame consisting of same columns as \code{Industries},
#'        except that \code{product_colname} takes the place of \code{industry_colname}.
#'        Note that the number of stages in \code{Products} must be one less than then
#'        number of stages in \code{Industries}, not counting storage industries.
#' @param industry_colname the name of the column in \code{Industries} containing
#'        names of industries (a string).
#'        Default is "\code{Industry}".
#' @param product_colname the name of the column in \code{Products} containing
#'        names of products (a string).
#'        Default is "\code{Product}".
#' @param stage_colname the name of the columns in \code{Industries} and \code{Products}
#'        containing names of stages (a string).
#'        The left-to-right order of stages in the network layout
#'        is determined by the top-to-bottom
#'        order in which stage names appear in the
#'        \code{Industries} and \code{Products} data frames.
#'        Default is "\code{Stage}".
#' @param group_colname the name of the column in \code{Industries} and \code{Products}
#'        containing industries and products that should be grouped together vertically
#'        at a stage (a string).
#'        The top-to-bottom order of groups at a stage is give by the order of appearance
#'        in \code{group_colname}.
#'        Default is "\code{Group}".
#'        \code{group_colname} is optional.
#' @param storage_stagename the name of the stage in \code{stage_colname} of \code{Industries}
#'        that identifies a "storage" industry (a string).
#'        Default is "\code{Storage}".
#' @param node_name_colname the name of the output column containing node names
#'        (industries and products).
#'        Node names are taken from the \code{industry_colname} of \code{Industries}
#'        and the \code{product_colname} of \code{Products}.
#'        Default is "\code{Node_name}".
#' @param x_colname the name of the output column containing x coordinates for each node.
#'        Default is Default is "\code{x}".
#' @param y_colname the name of the output column containing y coordinates for each node.
#'        Default is Default is "\code{y}".
#'
#' @return a matrix with three columns.
#'         The first column contains node names and is named \code{node_name_colname}.
#'         The second column contains x coordinates for the nodes and is named \code{x_colname}.
#'         The third column contains y coordinates for the nodes and is named \code{y_colname}.
#'
#' @importFrom rlang :=
#' @importFrom rlang .data
#' @importFrom magrittr %>%
#' @importFrom magrittr set_rownames
#' @importFrom dplyr arrange
#' @importFrom dplyr count
#' @importFrom dplyr filter
#' @importFrom dplyr group_by
#' @importFrom dplyr left_join
#' @importFrom dplyr mutate
#' @importFrom dplyr rename
#' @importFrom dplyr row_number
#' @importFrom dplyr select
#' @importFrom tibble rownames_to_column
#'
#' @export
ecc_layout <- function(Industries,
                       Products,
                       industry_colname = "Industry",
                       product_colname = "Product",
                       stage_colname = "Stage",
                       storage_stagename = "Storage",
                       group_colname = "Group",
                       # Output columns
                       node_name_colname = "Node_name",
                       x_colname = "x",
                       y_colname = "y"){
  # The group_colname is optional.
  # If the column is not present, add and fill with a single group (group_colname).
  if (!(group_colname %in% names(Industries))) {
    Industries <- Industries %>% mutate(
      !!as.name(group_colname) := group_colname
    )
  }
  if (!(group_colname %in% names(Products))) {
    Products <- Products %>% mutate(
      !!as.name(group_colname) := group_colname
    )
  }
  # Extract storage industries from the Industries data frame.
  Storage <- Industries %>%
    filter((!!as.name(stage_colname)) == storage_stagename)
  Industries_less_Storage <- Industries %>%
    filter((!!as.name(stage_colname)) != storage_stagename)
  # Ensure that the number of industry stages (less storage)
  # is one more than the number of product stages.
  N_industry_stages <- Industries_less_Storage %>% select(!!as.name(stage_colname)) %>% unique() %>% nrow()
  N_product_stages <- Products %>% select(!!as.name(stage_colname)) %>% unique() %>% nrow()
  if (N_industry_stages - N_product_stages != 1) {
    stop(paste0("N_industry_stages = ", N_industry_stages,
                ". N_product_stages = ", N_product_stages, ". ",
                "There should be one more industry stages than product stages. "),
         call. = FALSE)
  }
  # Set groups for the Group variable based on order of appearance.
  # These groups will be used later for ordering the y coordinates of nodes.
  grps <- rbind(Industries_less_Storage %>% select(!!as.name(group_colname)),
                Products %>% select(!!as.name(group_colname))) %>%
    filter(!is.na(!!as.name(group_colname))) %>% unique()
  grps <- set_rownames(grps, 1:nrow(grps))
  # Set levels for groups in order of their appearance.
  # These levels will be used later for calculating the y coordinates for the nodes.
  Industries <- Industries %>%
    mutate(
      !!as.name(group_colname) := factor(!!as.name(group_colname), levels = grps[[group_colname]])
    )
  Industries_less_Storage <- Industries_less_Storage %>%
    mutate(
      !!as.name(group_colname) := factor(!!as.name(group_colname), levels = grps[[group_colname]])
    )
  Products <- Products %>%
    mutate(
      !!as.name(group_colname) := factor(!!as.name(group_colname), levels = grps[[group_colname]])
    )
  Storage <- Storage %>%
    mutate(
      !!as.name(group_colname) := factor(!!as.name(group_colname), levels = grps[[group_colname]])
    )
  # Make data frames of stage numbers.
  # Left-to-right order across the network is taken from the order of appearance
  # in the respective data frames.
  # This process is simpler for industries and products
  # but takes additional calculations for storage industries (later).
  i_stage_colname <- paste0("i_", stage_colname)
  Industry_stage_order <- data.frame(temp = Industries_less_Storage %>%
                                       select(!!as.name(stage_colname)) %>%
                                       unique()) %>%
    rownames_to_column(var = i_stage_colname) %>%
    mutate(
      !!as.name(i_stage_colname) := as.numeric(!!as.name(i_stage_colname)),
      !!as.name(i_stage_colname) := 2 * (!!as.name(i_stage_colname)) - 1
    )
  Product_stage_order <- data.frame(temp = Products %>%
                                      select(!!as.name(stage_colname)) %>%
                                      unique()) %>%
    rownames_to_column(var = i_stage_colname) %>%
    mutate(
      !!as.name(i_stage_colname) := as.numeric(!!as.name(i_stage_colname)),
      !!as.name(i_stage_colname) := 2 * (!!as.name(i_stage_colname))
    )
  # Join these *_stage_order data frames
  Stage_coords <- rbind(Industry_stage_order %>%
                          rename(!!as.name(x_colname) := !!as.name(i_stage_colname)),
                        Product_stage_order %>%
                          rename(!!as.name(x_colname) := !!as.name(i_stage_colname))) %>%
    arrange(!!as.name(x_colname))

  # Join Stage_coords to a list of industries and products to create the list of nodes.
  Node_coords <- rbind(
    Industries_less_Storage %>% rename(!!as.name(node_name_colname) := !!as.name(industry_colname)),
    Products %>% rename(!!as.name(node_name_colname) := !!as.name(product_colname))
  ) %>%
    left_join(Stage_coords, by = stage_colname) %>%
    group_by(!!as.name(x_colname), !!as.name(group_colname)) %>%
    # Put nodes in correct order.
    # First group on stage (x coordinate) followed by
    # the Group within each stage.
    arrange(!!as.name(x_colname), !!as.name(group_colname))

  # At this point, all x coordinates have been decided and are in the Node_coords data frame.
  # Furthermore, the Node_coords data frame is in the correct order for y coordinates.
  # So work on y coordinates.
  # Figure out the number of nodes in each stage
  N_nodes <- Node_coords %>%
    group_by(!!as.name(stage_colname)) %>%
    count()
  # The count function automatically creates a column named "n".
  # We need this name later, so declare it here.
  n_colname <- "n"
  y_max <- max(N_nodes[[n_colname]])
  # y_center is the y coordinate that gives a horizontal line
  # that serves as the vertical center of the network layout
  # (not including storage nodes).
  y_center <- (y_max + 1) / 2

  # Calculate y coordinates
  i_group_colname <- ".i_group"
  Node_coords <- Node_coords %>%
    # Re-group according to x_colname only,
    # thereby ensuring that we apply y coords to each stage independently.
    group_by(!!as.name(x_colname)) %>%
    mutate(
      # Add a column for the row number (i) within each group (_group).
      !!as.name(i_group_colname) := row_number()
    ) %>%
    # Add a column (n) that gives the number of nodes in each stage
    left_join(N_nodes, by = stage_colname) %>%
    mutate(
      # Calculate the column of y coordinates
      # using the index within each group (i_group) and
      # the total number of nodes in the group (n)
      !!as.name(y_colname) := (y_max + 1) -
                              (y_center + (!!as.name(i_group_colname)) - ((!!as.name(n_colname)) + 1)/2)
    ) %>%
    # select only relevant columns
    select(!!as.name(node_name_colname), !!as.name(x_colname), !!as.name(y_colname))

  # Figure out where to place storage in x dimension.
  # Align storage industries with other industries.
  # Doing so will avoid vertical flows from products to storage.
  x_max <- max(Industry_stage_order[[i_stage_colname]], Product_stage_order[[i_stage_colname]])
  # Calculate the center of the x dimension.
  x_center <- (x_max + 1) / 2
  # Find out how many storage industries we have.
  N_storage <- nrow(Storage)
  # Find x coordinate of first Storage industry
  x_first_storage <- x_center - (N_storage - 1) / 2
  # If we have no Storage industries, we're done and can return Node_coords now.
  if (nrow(Storage) == 0) {
    return(Node_coords %>% as.matrix())
  }
  # We have some Storage nodes.
  # Calculate coordinates for storage nodes.
  Storage_coords <- data.frame(temp = Storage %>%
                                 select(!!as.name(industry_colname)) %>%
                                 unique()) %>%
    mutate(
      # !!as.name(x_colname) := seq(from = x_first_storage,
      #                             to = x_first_storage - 1 + N_storage,
      #                             by = 1)
      !!as.name(x_colname) := x_first_storage:(x_first_storage - 1 + N_storage)
    ) %>%
    left_join(Storage, by = industry_colname) %>%
    rename(
      !!as.name(node_name_colname) := !!as.name(industry_colname)
    ) %>%
    mutate(
      # Add the y coordinate
      !!as.name(y_colname) := y_max + 1
    ) %>%
    # Select only columns that we want in output
    select(!!as.name(node_name_colname), !!as.name(x_colname), !!as.name(y_colname))
  # Finally, rbind Node_coords and Storage_coords and return
  rbind(as.data.frame(Node_coords), Storage_coords) %>%
    as.matrix()
}

---
title: "Recca"
author: "Matthew Kuperus Heun"
date: "`r Sys.Date()`"
header-includes:
   - \usepackage{amsmath}
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{matsindf Vignette}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: recca.bib
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(dplyr)
library(matsbyname)
library(matsindf)
library(Recca)
library(tidyr)
library(tibble)
```

<!-- Establish some helpful LaTeX shortcuts for equations -->
\newcommand{\transpose}[1]{#1^\mathrm{T}}
\newcommand{\inverse}[1]{#1^{\mathrm{-}1}}
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\colvec}[1]{\mathbf{#1}}
\newcommand{\rowvec}[1]{\transpose{\colvec{#1}}}
\newcommand{\inversetranspose}[1]{\transpose{\left( \inverse{\mat{#1}} \right)}}
\newcommand{\transposeinverse}[1]{\inverse{\left( \transpose{\mat{#1}} \right)}}
\newcommand{\hatinv}[1]{\inverse{\widehat{#1}}}

## Introduction

`Recca` (`R` Energy Conversion Chain Analysis)
is an `R` package that enables
energy and exergy analysis of energy conversion chains.
`Recca` makes extensive use of a matrix-based PSUT analysis technique
that first appeared in 
[Heun et al. [-@Heun:2018]](https://doi.org/10.1016/j.apenergy.2018.05.109).


## Data for examples

For the examples that follow, we'll use the `UKEnergy2000mats` data frame.
Each row of `UKEnergy2000mats` data frame represents 
another version of a portion of the ECC for the UK in 2000.


## Design philosophy

The functions in `Recca` are flexible and can be used with either a data frame as input
(and names of columns as arguments to `Recca` function) or with matrices as inputs.
Outputs are either named columns appended to the input data frame or named matrices in a list.
The functions in `Recca` have default names for arguments which follow a standard nomenclature.
It is recommended that the default names be used whenever possible, 
thereby allowing cleaner code.


## Determine the I-O structure of an Energy Conversion Chain (ECC)

### With individual matrices

To determine the I-O structure of an ECC, use the `calc_io_mats` function.

```{r}
library(tidyr)
mats <- UKEnergy2000mats %>% 
  spread(key = matrix.name, value = matrix) %>% 
  mutate(
    Last.stage = factor(Last.stage, levels = c("final", "useful", "services")),
    Energy.type = factor(Energy.type, levels = c("E.ktoe", "X.ktoe"))
  ) %>% 
  arrange(Last.stage, Energy.type) # Put rows in a natural order
# Use the calc_io_mats function with individual matrices, 
# each taken from the UKEnergy2000mats data frame.
U <- mats$U[[1]]
V <- mats$V[[1]]
Y <- mats$Y[[1]]
S_units <- mats$S_units[[1]]
IO_list <- calc_io_mats(U = U, V = V, Y = Y, S_units = S_units)
```

Most `Recca` functions return a list when called with individual matrices as arguments.
The `calc_io_mats` function returns several I-O matrices in a list.

```{r}
class(IO_list)
names(IO_list)
IO_list[["y"]]
```

### Using a data frame

Most `Recca` functions can also operate on a data frame.
When a data frame is supplied to a `Recca` function in the `.sutmats` argument, 
most other input arguments must be strings 
that identify the names of appropriate columns in `.sutmats` containing vectors or matrices.
Helpfully, the default values for other input arguments conforms to a standard nomenclature.
If you're using the standard nomenclature, 
most `Recca` functions can be called without any arguments.
This approach yields very clean piped code, 
because we rely upon names for input and output columns
given by the default arguments to `calc_io_mats`.

To illustrate the above features of `Recca` functions, 
we'll apply the `calc_io_mats` function to the entire `UKEnergy2000mats` data frame, 
calculating appropriate I-O matrices for each row.
Used in this way, `Recca` functions act like specialized `dplyr::mutate` functions,
with new columns added to the right side of the data frame supplied to the `.sutmats` argument.

```{r}
IO_df <- mats %>% calc_io_mats()
```

By inspecting `IO_df`, we can see, for example, 
that one $\colvec{y}$ vector was calculated for 
each row of `mats`.
The same is true for all I-O matrices calculated by `calc_io_mats`.

```{r}
class(IO_df)
names(IO_df)
glimpse(IO_df)
IO_df[["y"]][[1]]
IO_df[["y"]][[2]]
IO_df[["y"]][[3]]
IO_df[["y"]][[4]]
```





## Conclusion

This vignette demonstrated the use of the `Recca` package. 


## References
